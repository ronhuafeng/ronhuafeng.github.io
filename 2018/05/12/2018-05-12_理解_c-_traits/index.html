<!doctype html><html lang=zh-cn><head><title>理解 C++ Traits // 不是追风少年</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.101.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="bef0rewind"><meta name=description content><link rel=stylesheet href=https://blog.formalscience.com/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><meta name=twitter:card content="summary"><meta name=twitter:title content="理解 C++ Traits"><meta name=twitter:description content="C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 type_relation 的成员 relation 获取比较结果。当前代码输出：
type_relation<bool, int>: different type_relation<int, int>: different 这段代码并未实现预期功能，因为比较 bool 和 int，以及 int 和 int 时，都输出 &#34;different&#34; 。下面继续完善这个 trait 实现。"><meta property="og:title" content="理解 C++ Traits"><meta property="og:description" content="C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 type_relation 的成员 relation 获取比较结果。当前代码输出：
type_relation<bool, int>: different type_relation<int, int>: different 这段代码并未实现预期功能，因为比较 bool 和 int，以及 int 和 int 时，都输出 &#34;different&#34; 。下面继续完善这个 trait 实现。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.formalscience.com/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-05-02T19:43:00+00:00"><meta property="article:modified_time" content="2018-05-02T19:43:00+00:00"></head><body><header class=app-header><a href=https://blog.formalscience.com/><img class=app-header-avatar src=/avatar.jpg alt=bef0rewind></a><h1>不是追风少年</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/categories/>Categories</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>当你在追着风，风也在推着你</p><div class=app-header-social><a href=https://github.com/ronhuafeng target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>我的 GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>理解 C++ Traits</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>May 2, 2018</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>1 min read</div></div></header><div class=post-content><p>C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。</p><p>C++ 之父 Bjarne Stroustrup 说：</p><blockquote><p>Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.</p></blockquote><p>嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。</p><p><img src=/uploads/trait1.png alt=trait1></p><p>这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 <code>type_relation</code> 的成员 <code>relation</code> 获取比较结果。当前代码输出：</p><pre tabindex=0><code class=language-output data-lang=output>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: different
</code></pre><p>这段代码并未实现预期功能，因为比较 <code>bool</code> 和 <code>int</code>，以及 <code>int</code> 和 <code>int</code> 时，都输出 <code>"different"</code> 。下面继续完善这个 trait 实现。</p><p><img src=/uploads/trait2.png alt=trait2></p><p>第 11 行的类型参数种使用 <code>&lt;T, T></code> （即两个相同的类型）进行模式匹配。这段代码输出：</p><pre tabindex=0><code class=language-output data-lang=output>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: equal
</code></pre><p>输出结果正确完成了类型比较的功能。</p><hr><p><strong>实现</strong></p><p>trait 的实现基于 C++ 的模板引擎（template engine），能够在**编译时期（compile time）**将模板（基于最匹配的模式）展开。如果要在 Golang 或者 Java 种实现类似功能，可以使用反射或者 interface 之类的方法，而这些方法都是在运行时（runtime）进行判定，不可避免带来性能开销。</p><hr><p><strong>进阶</strong></p><p>除了可以比较两个类型是否相等，还可以在类型参数上添加其他约束，例如：<code>*</code>、<code>[]</code> 等。下面是一个稍微复杂一些的版本：</p><p><img src=/uploads/trait3.png alt=trait3></p><pre tabindex=0><code class=language-output data-lang=output>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: equal
type_relation&lt;int*, int&gt;: is pointer of
type_relation&lt;int[], int&gt;: is array of
type_relation&lt;int[4], int&gt;: is array (length 4) of
</code></pre><p>当然这个“进阶”仅仅是比上面的例子复杂了一些，trait 还有更多能力。
C++ 的模板引擎为 C++ 提供了强大的元编程（meta programming）能力，也使得现代的 C++ 代码看上去比较奇怪。
事实上模板引擎是图灵完备的，如果使用好的话，能够将 C++ 的易用性和优雅性提升到一个高度（从那些看不到模板实现细节的用户的视角）。</p><hr><p><strong>感想</strong></p><p>每次 C++ 标准更新的新闻我都看到了，从 C++0X、C++11、C++14 到 C++17，新出的特性一直在关注，可却从来没有真正编写一段程序去试试这些特性。这让我很伤感。</p><p>看到新的语言就想去尝试，OCaml、Clojure、Haskell …… 这些语言都很有特色，OCaml 让我体会到模式匹配的爽快，Clojure 让我体会到 S-表达式的自由和 Lisp 宏的强大，Haskell 让我体会到抽象的威力以及自己脑容量的有限。可是工作中用的最多的还是 Python、Java 和 C，当然还有 PHP （这个不能忘）。</p><p>想我和 C++ 的关系，最初的时候还是看的 Bjarne Stroustrup 的《The C++ Programming Language》。后来怎么就越走越远了呢？虽然现在工作中暂时依旧用不到，还是希望以此为契机，了解更多模板引擎可以做的事情。</p><p>追逐过的其他语言，各有各的契机，或许是缘分，或许是喜欢，或许是虚荣。现在都不敢说自己会 C++ 了。
如果当时能够更专注一些，自己目前的职业轨迹会不会有所区别？</p><p>想起最初自己理解 Haskell 里 <code>Monad</code> 概念的时候，一头雾水。后来懂了，就是懂了。为什么偏爱某一种语言呢？我也搞不清楚自己。</p><p>也许爱情也是如此，回忆当初做的不同结果是否能够更好？也许。记住过往，抗拒住回忆的诱惑，很难，但不得不做。喜欢的，就喜欢着吧。有些事情就是不行，正如有些事情莫名其妙地发生。</p><p>Just live with it.</p></div><div class=post-footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//bef0rewind-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></main></body></html>