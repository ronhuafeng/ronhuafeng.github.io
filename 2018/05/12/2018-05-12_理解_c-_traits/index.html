<!doctype html><html lang=en><head><title>理解 C++ Traits :: 不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 type_relation 的成员 relation 获取比较结果。当前代码输出：
type_relation&amp;lt;bool, int&amp;gt;: different type_relation&amp;lt;int, int&amp;gt;: different 这段代码并未实现预期功能，因为比较 bool 和 int，以及 int 和 int 时，都输出 &amp;quot;different&amp;quot; 。下面继续完善这个 trait 实现。"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="理解 C++ Traits"><meta property="og:description" content="C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 type_relation 的成员 relation 获取比较结果。当前代码输出：
type_relation&amp;lt;bool, int&amp;gt;: different type_relation&amp;lt;int, int&amp;gt;: different 这段代码并未实现预期功能，因为比较 bool 和 int，以及 int 和 int 时，都输出 &amp;quot;different&amp;quot; 。下面继续完善这个 trait 实现。"><meta property="og:url" content="https://blog.formalscience.com/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="技术记录"><meta property="article:published_time" content="2018-05-12 00:00:00 +0000 UTC"></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://blog.formalscience.com/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/>理解 C++ Traits</a></h1><div class=post-meta><span class=post-date>2018-05-12</span></div><div class=post-content><div><p>C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。</p><p>C++ 之父 Bjarne Stroustrup 说：</p><blockquote><p>Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.</p></blockquote><p>嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。</p><p><img src=/uploads/trait1.png alt=trait1></p><p>这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 <code>type_relation</code> 的成员 <code>relation</code> 获取比较结果。当前代码输出：</p><pre tabindex=0><code class=language-output data-lang=output>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: different
</code></pre><p>这段代码并未实现预期功能，因为比较 <code>bool</code> 和 <code>int</code>，以及 <code>int</code> 和 <code>int</code> 时，都输出 <code>"different"</code> 。下面继续完善这个 trait 实现。</p><p><img src=/uploads/trait2.png alt=trait2></p><p>第 11 行的类型参数种使用 <code>&lt;T, T></code> （即两个相同的类型）进行模式匹配。这段代码输出：</p><pre tabindex=0><code class=language-output data-lang=output>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: equal
</code></pre><p>输出结果正确完成了类型比较的功能。</p><hr><p><strong>实现</strong></p><p>trait 的实现基于 C++ 的模板引擎（template engine），能够在**编译时期（compile time）**将模板（基于最匹配的模式）展开。如果要在 Golang 或者 Java 种实现类似功能，可以使用反射或者 interface 之类的方法，而这些方法都是在运行时（runtime）进行判定，不可避免带来性能开销。</p><hr><p><strong>进阶</strong></p><p>除了可以比较两个类型是否相等，还可以在类型参数上添加其他约束，例如：<code>*</code>、<code>[]</code> 等。下面是一个稍微复杂一些的版本：</p><p><img src=/uploads/trait3.png alt=trait3></p><pre tabindex=0><code class=language-output data-lang=output>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: equal
type_relation&lt;int*, int&gt;: is pointer of
type_relation&lt;int[], int&gt;: is array of
type_relation&lt;int[4], int&gt;: is array (length 4) of
</code></pre><p>当然这个“进阶”仅仅是比上面的例子复杂了一些，trait 还有更多能力。
C++ 的模板引擎为 C++ 提供了强大的元编程（meta programming）能力，也使得现代的 C++ 代码看上去比较奇怪。
事实上模板引擎是图灵完备的，如果使用好的话，能够将 C++ 的易用性和优雅性提升到一个高度（从那些看不到模板实现细节的用户的视角）。</p><hr><p><strong>感想</strong></p><p>每次 C++ 标准更新的新闻我都看到了，从 C++0X、C++11、C++14 到 C++17，新出的特性一直在关注，可却从来没有真正编写一段程序去试试这些特性。这让我很伤感。</p><p>看到新的语言就想去尝试，OCaml、Clojure、Haskell …… 这些语言都很有特色，OCaml 让我体会到模式匹配的爽快，Clojure 让我体会到 S-表达式的自由和 Lisp 宏的强大，Haskell 让我体会到抽象的威力以及自己脑容量的有限。可是工作中用的最多的还是 Python、Java 和 C，当然还有 PHP （这个不能忘）。</p><p>想我和 C++ 的关系，最初的时候还是看的 Bjarne Stroustrup 的《The C++ Programming Language》。后来怎么就越走越远了呢？虽然现在工作中暂时依旧用不到，还是希望以此为契机，了解更多模板引擎可以做的事情。</p><p>追逐过的其他语言，各有各的契机，或许是缘分，或许是喜欢，或许是虚荣。现在都不敢说自己会 C++ 了。
如果当时能够更专注一些，自己目前的职业轨迹会不会有所区别？</p><p>想起最初自己理解 Haskell 里 <code>Monad</code> 概念的时候，一头雾水。后来懂了，就是懂了。为什么偏爱某一种语言呢？我也搞不清楚自己。</p><p>也许爱情也是如此，回忆当初做的不同结果是否能够更好？也许。记住过往，抗拒住回忆的诱惑，很难，但不得不做。喜欢的，就喜欢着吧。有些事情就是不行，正如有些事情莫名其妙地发生。</p><p>Just live with it.</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>