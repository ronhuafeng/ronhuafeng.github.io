<!doctype html><html lang=en><head><title>Go to Rust （一） :: 不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这几天看了 Rust 文档，把一些概念整理一下。
通过 cargo 新建一个项目，然后去管理其生命流程，这种现代做法很方便。 对于 statement 和 expression 的使用方式和 scheme 有些类似，可以返回最后一个 expression 的值。 可能返回错误的地方使用 Result 类型，很类似 Haskell 的处理流程。 模式匹配的方式很像 Ocaml 。 ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。 Option 类型就是 Haskell 的 Maybe 。 generics 的设计不知道有没有参考 C++ 的 template 概念。 目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Go to Rust （一）"><meta property="og:description" content="这几天看了 Rust 文档，把一些概念整理一下。
通过 cargo 新建一个项目，然后去管理其生命流程，这种现代做法很方便。 对于 statement 和 expression 的使用方式和 scheme 有些类似，可以返回最后一个 expression 的值。 可能返回错误的地方使用 Result 类型，很类似 Haskell 的处理流程。 模式匹配的方式很像 Ocaml 。 ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。 Option 类型就是 Haskell 的 Maybe 。 generics 的设计不知道有没有参考 C++ 的 template 概念。 目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。"><meta property="og:url" content="https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="技术记录"><meta property="article:section" content="tech-notes"><meta property="article:published_time" content="2018-12-26 00:00:00 +0000 UTC"></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/>Go to Rust （一）</a></h1><div class=post-meta><span class=post-date>2018-12-26</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>Golang</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/rust/>Rust</a>&nbsp;</span><div class=post-content><div><p>这几天看了 Rust 文档，把一些概念整理一下。</p><ul><li>通过 <code>cargo</code> 新建一个项目，然后去管理其生命流程，这种现代做法很方便。</li><li>对于 <code>statement</code> 和 <code>expression</code> 的使用方式和 scheme 有些类似，可以返回最后一个 <code>expression</code> 的值。</li><li>可能返回错误的地方使用 <code>Result</code> 类型，很类似 Haskell 的处理流程。</li><li>模式匹配的方式很像 Ocaml 。</li><li>ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。</li><li><code>Option</code> 类型就是 Haskell 的 <code>Maybe</code> 。</li><li>generics 的设计不知道有没有参考 C++ 的 template 概念。</li></ul><p>目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>