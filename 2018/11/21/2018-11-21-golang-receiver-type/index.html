<!doctype html><html><head><title>Golang Receiver Type 探索</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/vendor/js/jquery.min.js></script>
<script src=/vendor/js/popper.min.js></script>
<script src=/vendor/js/bootstrap.min.js></script>
<script src=/vendor/js/smooth-scroll.polyfills.min.js></script>
<link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script>
<link rel=stylesheet href=https://blog.formalscience.com/scss/journal.min.77eac5c8bcc1927d36f437f2a34261971c85fb5cefee0f634e7b4a0b58e375d9.css integrity="sha256-d+rFyLzBkn029Dfyo0JhlxyF+1zv7g9jTntKC1jjddk=" media=screen><link rel=stylesheet href=https://blog.formalscience.com/scss/dark-mode.min.16a4bdf22c3281a2a85f9f6530a29c293748f042a72c9a62a46170ac92f58f62.css integrity="sha256-FqS98iwygaKoX59lMKKcKTdI8EKnLJpipGFwrJL1j2I=" media=screen><script src=https://blog.formalscience.com//js/loadCSS.js></script>
<script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons")</script><script src=https://blog.formalscience.com//js/table.js></script>
<script src=https://blog.formalscience.com//js/toc.js></script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=https://blog.formalscience.com/><div class=nav-title>不是追风少年</div></a><div class=nav-link-list><a class="a-block nav-link-item false" href=/posts>归档</a>
<a class="a-block nav-link-item false" href=/categories>分类</a>
<a class="a-block nav-link-item false" href=/tags>标签</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
2022 不是追风少年</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#1-%e5%8f%82%e8%80%83 v-on:click=closeDrawer id=1-参考-nav>1. 参考</a></li></ul></ul><ul><ul><li><a href=#2-duck-typing-%e4%b8%8e%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8 v-on:click=closeDrawer id=2-duck-typing-与方法调用-nav>2. Duck typing 与方法调用</a></li></ul></ul><ul><ul><li><a href=#3-%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0 v-on:click=closeDrawer id=3-成员函数的参数-nav>3. 成员函数的参数</a></li></ul></ul><ul><ul><li><a href=#4-%e4%bd%bf%e7%94%a8%e6%8e%a5%e5%8f%a3%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0 v-on:click=closeDrawer id=4-使用接口调用函数-nav>4. 使用接口调用函数</a></li></ul></ul><ul><ul><li><a href=#5-%e6%b3%a8%e5%85%a5%e4%be%9d%e8%b5%96 v-on:click=closeDrawer id=5-注入依赖-nav>5. 注入依赖</a></li></ul></ul><ul><ul><li><a href=#6-%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6 v-on:click=closeDrawer id=6-内部机制-nav>6. 内部机制</a></li></ul></ul><ul><ul><li><a href=#7-%e6%80%bb%e7%bb%93 v-on:click=closeDrawer id=7-总结-nav>7. 总结</a></li></ul></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item false" href=/posts>归档</a>
<a class="a-block drawer-menu-item false" href=/categories>分类</a>
<a class="a-block drawer-menu-item false" href=/tags>标签</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#1-%e5%8f%82%e8%80%83 v-on:click=closeDrawer id=1-参考-nav>1. 参考</a></li></ul></ul><ul><ul><li><a href=#2-duck-typing-%e4%b8%8e%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8 v-on:click=closeDrawer id=2-duck-typing-与方法调用-nav>2. Duck typing 与方法调用</a></li></ul></ul><ul><ul><li><a href=#3-%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0 v-on:click=closeDrawer id=3-成员函数的参数-nav>3. 成员函数的参数</a></li></ul></ul><ul><ul><li><a href=#4-%e4%bd%bf%e7%94%a8%e6%8e%a5%e5%8f%a3%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0 v-on:click=closeDrawer id=4-使用接口调用函数-nav>4. 使用接口调用函数</a></li></ul></ul><ul><ul><li><a href=#5-%e6%b3%a8%e5%85%a5%e4%be%9d%e8%b5%96 v-on:click=closeDrawer id=5-注入依赖-nav>5. 注入依赖</a></li></ul></ul><ul><ul><li><a href=#6-%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6 v-on:click=closeDrawer id=6-内部机制-nav>6. 内部机制</a></li></ul></ul><ul><ul><li><a href=#7-%e6%80%bb%e7%bb%93 v-on:click=closeDrawer id=7-总结-nav>7. 总结</a></li></ul></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=https://blog.formalscience.com/>不是追风少年</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://blog.formalscience.com/><div class=single-column-header-title>不是追风少年</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>Golang Receiver Type 探索<div class=post-meta><time itemprop=datePublished>2018-11-21 00:00</time>
<i class=material-icons>folder</i>
<a href=/categories/>[技术记录 tech-notes]</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/tags/golang>golang</a>
&nbsp;
<a href=/tags/programming-language>programming language</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body><h2 id=1-参考>1. 参考</h2><p>在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。</p><ul><li><a href=https://golang.google.cn/ref/spec#Method_sets>https://golang.google.cn/ref/spec#Method_sets</a></li><li><a href=https://golang.google.cn/ref/spec#Types>https://golang.google.cn/ref/spec#Types</a></li><li><a href=https://golang.google.cn/ref/spec#Struct_types>https://golang.google.cn/ref/spec#Struct_types</a></li><li><a href=https://golang.google.cn/ref/spec#Composite_literals>https://golang.google.cn/ref/spec#Composite_literals</a></li></ul><p>核心的概念是 method sets：</p><blockquote><p>A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). Further rules apply to structs containing embedded fields, as described in the section on struct types. Any other type has an empty method set. In a method set, each method must have a unique non-blank method name.</p><p>The method set of a type determines the interfaces that the type implements and the methods that can be called using a receiver of that type.</p></blockquote><p>下面的一些细节基本上都和这段描述相关。</p><h2 id=2-duck-typing-与方法调用>2. Duck typing 与方法调用</h2><p>在很多面向对象的语言中，一个对象都可以“拥有”一些方法，使用例如 <code>obj.f(a, b, c)</code> 的形式进行调用。结合语言的类型系统，通过“扩展”、“继承”、“实现”等术语，我们可以将不同的类组织起来。在 Go 语言中采用的是 “duck typing”，没有显式的类型关系定义关键字。当一个类型实现了一个接口的全部方法时，那这个类型就被视为实现了这个接口。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Duck</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Bark</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>A</span> <span style=color:#66d9ef>struct</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>struct</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>A</span>) <span style=color:#a6e22e>Bark</span>() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>iA</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>A</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>iA</span>).(<span style=color:#a6e22e>Duck</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;&amp;A{} is Duck&#34;</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;&amp;A{} is not Duck&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>iB</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>B</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>iB</span>).(<span style=color:#a6e22e>Duck</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;&amp;B{} is Duck&#34;</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;&amp;B{} is not Duck&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>&amp;A{} is Duck
&amp;B{} is not Duck
</code></pre><p>我们可以用原始的类型去调用一个方法，也可以使用一个接口去调用方法。这里就涉及到方法调用者的问题：什么样的对象是一个合法的方法调用者？</p><p>至少 <code>A{}</code> 不是，因为我们实现 <code>Duck</code> 接口的时候，使用的是 <code>func (*A) Bark()</code> 进行的定义，而非 <code>func (A) Bark()</code>。这样就导致了只有 <code>A</code> 类型对象的指针类型才能作为方法调用者去调用 <code>Bark</code> 方法。</p><h2 id=3-成员函数的参数>3. 成员函数的参数</h2><p>在实现中，调用某个类型的成员方法，第一个参数其实是这个方法的实现对象自身，即如果是一个指针的方法，就是这个指针的值，如果是一个对象，就是这个对象的值。</p><p>下面使用 Go 1.8.3 展示，因为当前最新的 Go 编译器在打印 stack trace 的时候不再打印函数的参数（这个例子中）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>R1</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>R1</span>) <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	println(<span style=color:#e6db74>&#34;received&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;just a panic&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>R1</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	println(<span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>0xc420039f70
received 1
panic: just a panic

goroutine 1 [running]:
main.(*R1).f(0xc420039f70, 0x1)
	/Users/bef0rewind/Projects/net example/src/main/receiver_type.go:9 +0xa3
main.main()
	/Users/bef0rewind/Projects/net example/src/main/receiver_type.go:16 +0x5a
</code></pre><p>Stack trace 中函数 <code>f</code> 第一个值是指针 <code>r</code> 的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>R1</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>R1</span>) <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	println(<span style=color:#e6db74>&#34;received&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;just a panic&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>R1</span>) <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	println(<span style=color:#e6db74>&#34;received&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;just a panic&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>R1</span>{<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>9</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	println(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	(<span style=color:#a6e22e>r</span>).<span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>7
received 1
panic: just a panic

goroutine 1 [running]:
main.R1.g(0x7, 0x9, 0x1)
	/Users/bef0rewind/Projects/net example/src/receiver_type/main/args.go:15 +0xa3
main.main()
	/Users/bef0rewind/Projects/net example/src/receiver_type/main/args.go:22 +0x58
</code></pre><p>Stack trace 中函数 <code>g</code> 第一个值是 <code>r</code> 的值 <code>7</code> 和 <code>9</code>。</p><p>从这个实现方式中我们可以推断以下几点：</p><ul><li>Go 语言采用参数传值的方式进行函数调用，因此如果对象很大，使用的对象本身调用函数会带来大量的复制</li><li>不可能在函数调用中改变函数外的调用者，因为传到函数内部的只是调用者的副本</li></ul><h2 id=4-使用接口调用函数>4. 使用接口调用函数</h2><p>基于这样的成员函数实现方式，我们可以尝试另外一种调用方式：使用接口类型调用一个函数。
这里不是将一个对象转换成特定的接口然后去调用函数，而是使用接口类型本身去进行函数调用。
这种方式在 Go 1.9 中开始支持，在 Go 1.10 开始写入 Go 的 specs。这个例子使用的是 Go master 分支的版本，可能是 Go 1.11。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>M</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>M</span>) <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	println(<span style=color:#e6db74>&#34;I;m M, with&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IM</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>M</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>IM</span>.<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>m</span>, <span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>I;m M, with 7
</code></pre><p>此外还能使用匿名接口类型去调用函数，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>M</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>M</span>) <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	println(<span style=color:#e6db74>&#34;I;m M, with&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>M</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>interface</span>{<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>)}.<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>m</span>, <span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果与上面的一段采用 <code>IM</code> 接口定义的例子是一样的。</p><h2 id=5-注入依赖>5. 注入依赖</h2><p>有时候一个对象在实例化的时候，它的一些成员方法的行为可能还没有确定，需要依赖外界注入。此时我们可以在对象类型定义中内嵌一个接口，然后在后期传入一个接口的实例来确定其行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>BinaryOp</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Compute</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ComputeNode</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>BinaryOp</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ComputeNode</span>) <span style=color:#a6e22e>Result</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>BinaryOp</span>.<span style=color:#a6e22e>Compute</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>y</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Add</span> <span style=color:#66d9ef>struct</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>Add</span>) <span style=color:#a6e22e>Compute</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Multi</span> <span style=color:#66d9ef>struct</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>Multi</span>) <span style=color:#a6e22e>Compute</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ComputeNode</span>{<span style=color:#a6e22e>x</span>:<span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>y</span>:<span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>BinaryOp</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Add</span>{}
</span></span><span style=display:flex><span>	println(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Result</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>BinaryOp</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Multi</span>{}
</span></span><span style=display:flex><span>	println(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Result</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>5
6
</code></pre><p>注意一定要记得传入接口的实例，在这个例子中如果不给 <code>node</code> 传入一个 <code>BinaryOp</code> 接口实例，那 <code>node.BinaryOp</code> 是 <code>nil</code>，在调用 <code>Compute</code> 方法的时候就会发生异常。例如将上面的 <code>main</code> 函数稍作修改：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ComputeNode</span>{<span style=color:#a6e22e>x</span>:<span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>y</span>:<span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//node.BinaryOp = &amp;Add{}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	println(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Result</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x104d8d7]

goroutine 1 [running]:
main.(*ComputeNode).Result(...)
	/Users/bef0rewind/Projects/net example/src/receiver_type/main/injection.go:13
main.main()
	/Users/bef0rewind/Projects/net example/src/receiver_type/main/injection.go:32 +0x47
</code></pre><h2 id=6-内部机制>6. 内部机制</h2><p>内部机制有一些细节。大体就是一个接口 <code>i</code> 包含两部分内容（指针），一个是接口代表的方法的集合，一个实现这个接口的具体对象；而一个对象 <code>obj</code>，它包含了自己的内存中的值，也能通过其类型获取到 <code>obj</code> 实现的方法集合。</p><p>将这两个概念记住，在实现一些模式的时候就会少很多心智负担。</p><h2 id=7-总结>7. 总结</h2><p>Go 语言的这套基于 “duck typing” 的机制好不好，争论有很多。不过我一向对这些争论没有特别的倾向，至少理解其机制之后按照其设计思路来用还可以正常使用，而且里面没有复杂的概念和例外情形。</p><p>也许我的理解有偏差，但现在还没有发现什么矛盾的地方。</p><hr width=100% id=EOF><p style=color:#777>Last modified on 2018-11-21</p></div></div><nav class=post-pagination><a class=newer-posts href=https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/>Next<br>Escape from escape analysis</a>
<a class=older-posts href=https://blog.formalscience.com/drafts/call-cc/>Previous<br>Call/CC (call-with-current-continuation) 概念学习</a></nav><div class=post-comment-wrapper><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="bef0rewind-blog",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
2022 不是追风少年</div></div><script>let app;app=new Vue({el:"#app",data:{scrollY:0,navOpacity:0,isDrawerOpen:!1,mounted:!1,isDarkMode:!1},methods:{sgn(e,t){let n=1/(1-2*e);return t<=e?0:t>=1-e?1:n*(t-e)},handleScroll(){this.scrollY=window.scrollY,this.navOpacity=this.sgn(0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*.8))));const{navBar:n,navBackground:e,navTitle:t,extraContainer:s,streamContainer:o}=this.$refs;this.navOpacity>=1?(e.style.opacity=1,t.style.opacity=1):(e.style.opacity=0,t.style.opacity=0)},handleResize(){const{navBar:n,navBackground:s,navTitle:o,extraContainer:e,streamContainer:t}=this.$refs;e.style.left=t.offsetWidth-e.offsetWidth+"px"},navBarHeight(){return this.$refs.navBar.offsetHeight},pageHeadHeight(){return this.$refs.pageHead.offsetHeight},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen,document.getElementsByTagName("html")[0].style.overflow=this.isDrawerOpen?"hidden":"unset"},closeDrawer(){this.isDrawerOpen=!1,document.getElementsByTagName("html")[0].style.overflow=this.isDrawerOpen?"hidden":"unset"},toggleDarkMode(){this.isDarkMode=!this.isDarkMode,this.isDarkMode==!0?(document.cookie="night=1;path=/",document.body.classList.add("night")):(document.cookie="night=0;path=/",document.body.classList.remove("night"))}},created(){window.addEventListener("scroll",this.handleScroll),window.addEventListener("resize",this.handleResize),window._nonDesktop=function(){let e=!1;return function(t){(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(t.substr(0,4)))&&(e=!0)}(navigator.userAgent||navigator.vendor||window.opera),e};var e=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*=\s*([^;]*).*$)|^.*$/,"$1");e==""?window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches:e=="1"&&this.toggleDarkMode()},mounted(){this.handleScroll(),this.handleResize(),this.mounted=!0},destroyed(){window.removeEventListener("scroll",this.handleScroll),window.removeEventListener("resize",this.handleResize)}})</script><script src=https://blog.formalscience.com//js/journal.js></script></body></html>