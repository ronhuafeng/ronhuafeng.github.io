<!doctype html><html lang=en><head><title>Golang 中学到的新东西 :: 不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&amp;amp;s[0]) var ptr unsafe.Pointer s := ((*[1&amp;lt;&amp;lt;10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(&amp;amp;s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;amp;o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) map 实现 整个页面的内容对我来说都是新的：https://tiancaiamao."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Golang 中学到的新东西"><meta property="og:description" content="数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&amp;amp;s[0]) var ptr unsafe.Pointer s := ((*[1&amp;lt;&amp;lt;10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(&amp;amp;s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;amp;o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) map 实现 整个页面的内容对我来说都是新的：https://tiancaiamao."><meta property="og:url" content="https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="技术记录"><meta property="article:published_time" content="2018-01-14 00:00:00 +0000 UTC"></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/>Golang 中学到的新东西</a></h1><div class=post-meta><span class=post-date>2018-01-14</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>Golang</a>&nbsp;</span><div class=post-content><div><h1 id=数据类型>数据类型<a href=#数据类型 class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=string-类型><code>string</code> 类型<a href=#string-类型 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><code>string</code> 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。</p><h2 id=slice-leftrightarrow-unsafepointer><code>slice</code> $\leftrightarrow$ <code>unsafe.Pointer</code><a href=#slice-leftrightarrow-unsafepointer class=hanchor arialabel=Anchor>&#8983;</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>200</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>0</span>])
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> ((<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>ptr</span>))[:<span style=color:#ae81ff>200</span>]
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s1</span> = <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cap</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}{<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>length</span>, <span style=color:#a6e22e>length</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span>[]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s1</span>))
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sliceHeader</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>SliceHeader</span>)((<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>o</span>)))
</span></span><span style=display:flex><span><span style=color:#a6e22e>sliceHeader</span>.<span style=color:#a6e22e>Cap</span> = <span style=color:#a6e22e>length</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sliceHeader</span>.<span style=color:#a6e22e>Len</span> = <span style=color:#a6e22e>length</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sliceHeader</span>.<span style=color:#a6e22e>Data</span> = uintptr(<span style=color:#a6e22e>ptr</span>)
</span></span></code></pre></div><h1 id=map-实现><code>map</code> 实现<a href=#map-实现 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>整个页面的内容对我来说都是新的：https://tiancaiamao.gitbooks.io/go-internals/content/zh/02.3.html
不过这个页面描述的内容和最新的 Golang source 有一定差别。</p><p>读 <code>HashMap</code> 的实现，里面的一些核心关键词：<code>bucket</code>、<code>overflow</code> 让我理解起来有些困难。查询 <code>HashMap</code> 相关的一些资料后有了进一步了解。</p><ol><li><code>bucket</code> 一般使用某种 <code>array</code> 管理，从 <code>key</code> 经过 <code>hash-function</code> 映射的 <code>hash-value</code>（可能截取一部分，也可以视作 sub-hash，我自己编的）作为 <code>index</code> 直接得到。一个 <code>bucket</code> 中可能包含多个不同的 <code>hash-value</code> ，它们截取那一部分得到的 <code>index</code> 相同。因此 <code>bucket</code> 会用一个数据结构管理这些冲突的值，可能是 <code>linked-list</code> 或者 <code>tree-map</code> 之类的。这些内部的数据结构中的 <code>node</code> 存储着真正对应 <code>map</code> 的 <code>key\value</code> 对(pair)。</li><li>如果 <code>bucket</code> 太满了，比如元素的数量超过 <code>bucket</code> 数量一定倍数（<code>load factor</code>），则会进行扩容，所有元素都被 <code>rehashed</code> 到一个新的值。</li><li>采用这种方式实现 <code>HashMap</code>，<code>bucket</code> 可以有两种选择：</li></ol><ul><li><strong>Direct chaining</strong> 只存一个指向冲突元素集合的 <code>header</code></li><li><strong>Seperate Chaining</strong> 在 <code>bucket</code> 存一部分（一个）元素集合（Golang <code>HashMap</code> 实现里放了 8 个），和一个指向剩下冲突元素集合的 <code>header</code></li></ul><ol start=4><li>上面 <code>header</code> 指向的元素集合叫 <code>overflow list</code> 或者 <code>overflow some-other-data-structure</code></li></ol><p>有了这些背景后，看代码应该会比较清晰了。</p><p>目前 Golang 中的 <code>bucket</code> 是为 <code>insert</code> 操作优化的，找到第一个空余位置就可以插入，但是删除的时候要把所有相同 <code>key</code> 的元素都删掉，要遍历 <code>bucket</code> 的 <code>overflow</code> 集合。</p><p>如果 key 或者 value 小于 128 字节，那么它们是直接在 <code>bucket</code> 存储值，否则存指向数据的指针。</p><h1 id=nil-语义><code>nil</code> 语义<a href=#nil-语义 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>按照 Golang 规范，任何类型在未初始化时都对应一个零值：</p><ul><li><code>bool</code> $\rightarrow$ <code>true</code></li><li><code>integer</code> $\rightarrow$ <code>0</code></li><li><code>string</code> $\rightarrow$ <code>""</code></li><li><code>pointer</code>/<code>function</code>/<code>interface</code>/<code>slice</code>/<code>channel</code>/<code>map</code> $\rightarrow$ <code>nil</code></li></ul><h2 id=关于-interface>关于 <code>interface{}</code><a href=#关于-interface class=hanchor arialabel=Anchor>&#8983;</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>           <span style=color:#75715e>// v == nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}  <span style=color:#75715e>// i == nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>v</span>              <span style=color:#75715e>// i != nil
</span></span></span></code></pre></div><h2 id=关于-channel>关于 <code>channel</code><a href=#关于-channel class=hanchor arialabel=Anchor>&#8983;</a></h2><p>一些操作规则：</p><ul><li>读写一个 <code>nil</code> 的 <code>channel</code> 会立即阻塞</li><li>读一个关闭的 <code>channel</code> 会立刻返回一个 <code>channel</code> 元素类型的零值，即 <code>chan int</code> 会返回 <code>0</code></li><li>写一个关闭的 <code>channel</code> 会导致 <code>panic</code></li></ul><h1 id=函数调用>函数调用<a href=#函数调用 class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=汇编>汇编<a href=#汇编 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>可以看一下这个 Golang 的官方介绍页面：https://golang.org/doc/asm</p><p><strong>add.go</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>add</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#66d9ef>uint64</span>
</span></span></code></pre></div><p><strong>add_amd64.s</strong> 或使用其他平台后缀，和 <strong>add.go</strong> 在同一个目录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>TEXT</span>    <span style=color:#960050;background-color:#1e0010>·</span>Add<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(SB),<span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    a<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(FP),BX
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    b<span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(FP),BP
</span></span><span style=display:flex><span><span style=color:#a6e22e>ADDQ</span>    BP,BX
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BX,res<span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(FP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>RET</span>     ,
</span></span></code></pre></div><h2 id=golang-调用-c>Golang 调用 C<a href=#golang-调用-c class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>add.c</strong> ，和 <strong>add.go</strong> 在同一个目录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#960050;background-color:#1e0010>·</span>Add(uint64 a, uint64 b, uint64 ret) {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    FLUSH(<span style=color:#f92672>&amp;</span>ret);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译这个包：<code>go install add</code></p><p>C 文件中需要包含 <code>runtime.h</code> 头文件。因为 Golang 使用特殊寄存器存放像全局 <code>struct G</code> 和 <code>struct M</code> ，包含这个文件可以让所有链接到 Go 的 C 文件感知这一点，避免编译器使用这些特定的寄存器做其他用途。</p><p>上面示例中返回值为空，使用 <code>ret</code> 作为返回值，<code>FLUSH</code> 在 <code>pkg/runtime/runtime.h</code> 中定义为 <code>USED()</code> ，防止编译器优化掉对某个变量的赋值操作（因为看不到这个变量在后面其他地方使用了）。</p><h2 id=函数调用时的内存布局>函数调用时的内存布局<a href=#函数调用时的内存布局 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Golang 中使用的 C 编译器是 plan9 的 C 编译器，与 gcc 有一定差异。
这个页面中有部分基础介绍：
<a href=https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.1.html>https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.1.html</a></p><p>如果返回多个值，<code>func f(a, b int) (d, e int)</code> 内存布局如下所示：</p><pre tabindex=0><code>slot for e
slot for d
b
a 
&lt;- SP
</code></pre><p>调用后为</p><pre tabindex=0><code>slot for e
slot for d
b
a &lt;- FP
PC &lt;- SP
f&#39;s stack
</code></pre><p>plan9 的 C 汇编器对被调用函数的参数值的修改是会返回到调用函数中的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BX,d<span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(FP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BX,e<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(FP)
</span></span></code></pre></div><h1 id=go-关键字><code>go</code> 关键字<a href=#go-关键字 class=hanchor arialabel=Anchor>&#8983;</a></h1><p><code>f(1, 2, 3)</code> 的汇编:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>    f(SB)
</span></span></code></pre></div><p><code>go f(1, 2, 3)</code> 的汇编：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PUSHQ</span>   <span style=color:#66d9ef>$</span>f(SB)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PUSHQ</span>   <span style=color:#66d9ef>$</span><span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>    runtime.newproc(SB)
</span></span><span style=display:flex><span><span style=color:#a6e22e>POPQ</span>    AX
</span></span><span style=display:flex><span><span style=color:#a6e22e>POPQ</span>    AX
</span></span></code></pre></div><p><code>12</code> 是参数占用的大小，<code>runtime.newproc</code> 函数接受的参数为：参数大小、新的 goroutine 要运行的函数、函数的参数。<code>runtime.newproc</code> 会新建一个栈空间，将栈参数的 12 个字节复制到新的栈空间，并让栈指针指向参数。可以看做 <code>runtime.newproc(size, f, args)</code> 。</p><h1 id=defer-关键字><code>defer</code> 关键字<a href=#defer-关键字 class=hanchor arialabel=Anchor>&#8983;</a></h1><p><code>return x</code> 不是原子语句，函数执行顺序为：</p><ol><li>给返回值赋值</li><li><code>defer</code> 调用</li><li><code>return</code></li></ol><p><code>defer</code> 实现对应 <code>runtime.deferproc</code>，其出现的地方插入指令 <code>call runtime.deferproc</code> ，函数返回之前的地方，插入 <code>call runtime.deferreturn</code> 。 goroutine 的控制结构中有一张表记录 <code>defer</code>，表以栈行为运作。</p><h1 id=continuous-stack>Continuous Stack<a href=#continuous-stack class=hanchor arialabel=Anchor>&#8983;</a></h1><p>我也基本理解了思路，具体细节可以看：https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html</p><p>最后的 <code>runtime.lessstack</code> 有些没看懂。</p><h1 id=闭包>闭包<a href=#闭包 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>闭包中引用的变量不能在栈上分配，否则闭包函数返回的时候，栈上变量的地址就失效了。</p><h2 id=逃逸分析escape-analyze>逃逸分析（escape analyze）<a href=#逃逸分析escape-analyze class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Golang 有个特性，可以自动识别哪些变量在栈上分配，哪些在堆上分配。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>Cursor</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#a6e22e>Cursor</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>X</span> = <span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noinline</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>      <span style=color:#66d9ef>$</span>type.<span style=color:#e6db74>&#34;&#34;</span>.Cursor<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(SB),(SP)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>取变量</span>c的类型<span style=color:#960050;background-color:#1e0010>，也就是</span>Cursor
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>$</span><span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>1</span>,<span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>      ,runtime.new(SB)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>调用</span>new函数<span style=color:#960050;background-color:#1e0010>，相当于</span>new(Cursor)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>$</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>      <span style=color:#ae81ff>8</span>(SP),AX    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>取</span>c.X的地址放到AX寄存器
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>      <span style=color:#66d9ef>$</span><span style=color:#ae81ff>500</span>,(AX)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>将</span>AX<span style=color:#960050;background-color:#1e0010>存放的内存地址的值赋为</span><span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>      AX,<span style=color:#e6db74>&#34;&#34;</span>.~r0<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(FP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ADDQ</span>      <span style=color:#66d9ef>$</span><span style=color:#ae81ff>16</span>,SP
</span></span></code></pre></div><p>在编译的过程中可以通过指令输出哪些变量逃逸了：<code>go build --gcflags=-m main.go</code></p><h2 id=闭包结构体>闭包结构体<a href=#闭包结构体 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>闭包将函数和它引用的环境表示为一个结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Closure</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>F</span> <span style=color:#66d9ef>func</span>()() 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>整体思路是返回闭包的时候，返回一个结构体，包含闭包返回函数的地址和引用的环境中的变量地址。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#66d9ef>$</span>type.int<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(SB),(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>$</span><span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>1</span>,<span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>    ,runtime.new(SB)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>是不是很熟悉，这一段就是</span>i <span style=color:#960050;background-color:#1e0010>=</span> new(int)    
</span></span><span style=display:flex><span><span style=color:#a6e22e>...</span>    
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#66d9ef>$</span>type.struct <span style=color:#960050;background-color:#1e0010>{</span> F uintptr<span style=color:#75715e>; A0 *int }+0(SB),(SP)    // 这个结构体就是闭包的类型</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>    ,runtime.new(SB)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>接下来相当于</span> new(Closure)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>$</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#ae81ff>8</span>(SP),AX
</span></span><span style=display:flex><span><span style=color:#a6e22e>NOP</span>    ,
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#66d9ef>$</span><span style=color:#e6db74>&#34;&#34;</span>.func<span style=color:#960050;background-color:#1e0010>·</span><span style=color:#ae81ff>001</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(SB),BP
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BP,(AX)                <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>函数地址赋值给</span>Closure的F部分
</span></span><span style=display:flex><span><span style=color:#a6e22e>NOP</span>    ,
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#f92672>&amp;</span>i<span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(SP),BP        <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>将堆中</span>new的变量i的地址赋值给Closure的值部分
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BP,<span style=color:#ae81ff>8</span>(AX)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    AX,<span style=color:#e6db74>&#34;&#34;</span>.~r1<span style=color:#f92672>+</span><span style=color:#ae81ff>40</span>(FP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ADDQ</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>24</span>,SP
</span></span><span style=display:flex><span><span style=color:#a6e22e>RET</span>    ,
</span></span></code></pre></div><h1 id=引用>引用<a href=#引用 class=hanchor arialabel=Anchor>&#8983;</a></h1><ol><li><a href=https://tiancaiamao.gitbooks.io/go-internals>https://tiancaiamao.gitbooks.io/go-internals</a></li><li><a href=http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/07_Hashing_Chaining.pdf>http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/07_Hashing_Chaining.pdf</a></li></ol></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>