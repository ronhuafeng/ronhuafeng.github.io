<!doctype html><html lang=zh-cn><head><title>Golang 中学到的新东西 // 不是追风少年</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.104.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="bef0rewind"><meta name=description content><link rel=stylesheet href=https://blog.formalscience.com/css/main.min.0fb49e70a30412f97ddfc418e18fefef1d9fcdebe45f634dbbba768b00fe1eec.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang 中学到的新东西"><meta name=twitter:description content="数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&s[0]) var ptr unsafe.Pointer s := ((*[1<<10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(&s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) map 实现 整个页面的内容对我来说都是新的：https://tiancaiamao."><meta property="og:title" content="Golang 中学到的新东西"><meta property="og:description" content="数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&s[0]) var ptr unsafe.Pointer s := ((*[1<<10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(&s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) map 实现 整个页面的内容对我来说都是新的：https://tiancaiamao."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-14T11:53:30+00:00"><meta property="article:modified_time" content="2018-01-14T11:53:30+00:00"></head><body><header class=app-header><a href=https://blog.formalscience.com/><img class=app-header-avatar src=/avatar.jpg alt=bef0rewind></a>
<span class=app-header-title>不是追风少年</span><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/categories/>Categories</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>当你在追着风，风也在推着你</p><div class=app-header-social><a href=https://github.com/ronhuafeng target=_blank rel="noreferrer noopener me"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>我的 GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Golang 中学到的新东西</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jan 14, 2018</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://blog.formalscience.com/tags/golang/>Golang</a></div></div></header><div class=post-content><h1 id=数据类型>数据类型</h1><h2 id=string-类型><code>string</code> 类型</h2><p><code>string</code> 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。</p><h2 id=slice-leftrightarrow-unsafepointer><code>slice</code> $\leftrightarrow$ <code>unsafe.Pointer</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>200</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>0</span>])
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> ((<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>ptr</span>))[:<span style=color:#ae81ff>200</span>]
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s1</span> = <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cap</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}{<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>length</span>, <span style=color:#a6e22e>length</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span>[]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s1</span>))
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>o</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sliceHeader</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>SliceHeader</span>)((<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>o</span>)))
</span></span><span style=display:flex><span><span style=color:#a6e22e>sliceHeader</span>.<span style=color:#a6e22e>Cap</span> = <span style=color:#a6e22e>length</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sliceHeader</span>.<span style=color:#a6e22e>Len</span> = <span style=color:#a6e22e>length</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sliceHeader</span>.<span style=color:#a6e22e>Data</span> = uintptr(<span style=color:#a6e22e>ptr</span>)
</span></span></code></pre></div><h1 id=map-实现><code>map</code> 实现</h1><p>整个页面的内容对我来说都是新的：https://tiancaiamao.gitbooks.io/go-internals/content/zh/02.3.html
不过这个页面描述的内容和最新的 Golang source 有一定差别。</p><p>读 <code>HashMap</code> 的实现，里面的一些核心关键词：<code>bucket</code>、<code>overflow</code> 让我理解起来有些困难。查询 <code>HashMap</code> 相关的一些资料后有了进一步了解。</p><ol><li><code>bucket</code> 一般使用某种 <code>array</code> 管理，从 <code>key</code> 经过 <code>hash-function</code> 映射的 <code>hash-value</code>（可能截取一部分，也可以视作 sub-hash，我自己编的）作为 <code>index</code> 直接得到。一个 <code>bucket</code> 中可能包含多个不同的 <code>hash-value</code> ，它们截取那一部分得到的 <code>index</code> 相同。因此 <code>bucket</code> 会用一个数据结构管理这些冲突的值，可能是 <code>linked-list</code> 或者 <code>tree-map</code> 之类的。这些内部的数据结构中的 <code>node</code> 存储着真正对应 <code>map</code> 的 <code>key\value</code> 对(pair)。</li><li>如果 <code>bucket</code> 太满了，比如元素的数量超过 <code>bucket</code> 数量一定倍数（<code>load factor</code>），则会进行扩容，所有元素都被 <code>rehashed</code> 到一个新的值。</li><li>采用这种方式实现 <code>HashMap</code>，<code>bucket</code> 可以有两种选择：</li></ol><ul><li><strong>Direct chaining</strong> 只存一个指向冲突元素集合的 <code>header</code></li><li><strong>Seperate Chaining</strong> 在 <code>bucket</code> 存一部分（一个）元素集合（Golang <code>HashMap</code> 实现里放了 8 个），和一个指向剩下冲突元素集合的 <code>header</code></li></ul><ol start=4><li>上面 <code>header</code> 指向的元素集合叫 <code>overflow list</code> 或者 <code>overflow some-other-data-structure</code></li></ol><p>有了这些背景后，看代码应该会比较清晰了。</p><p>目前 Golang 中的 <code>bucket</code> 是为 <code>insert</code> 操作优化的，找到第一个空余位置就可以插入，但是删除的时候要把所有相同 <code>key</code> 的元素都删掉，要遍历 <code>bucket</code> 的 <code>overflow</code> 集合。</p><p>如果 key 或者 value 小于 128 字节，那么它们是直接在 <code>bucket</code> 存储值，否则存指向数据的指针。</p><h1 id=nil-语义><code>nil</code> 语义</h1><p>按照 Golang 规范，任何类型在未初始化时都对应一个零值：</p><ul><li><code>bool</code> $\rightarrow$ <code>true</code></li><li><code>integer</code> $\rightarrow$ <code>0</code></li><li><code>string</code> $\rightarrow$ <code>""</code></li><li><code>pointer</code>/<code>function</code>/<code>interface</code>/<code>slice</code>/<code>channel</code>/<code>map</code> $\rightarrow$ <code>nil</code></li></ul><h2 id=关于-interface>关于 <code>interface{}</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>           <span style=color:#75715e>// v == nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}  <span style=color:#75715e>// i == nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>v</span>              <span style=color:#75715e>// i != nil
</span></span></span></code></pre></div><h2 id=关于-channel>关于 <code>channel</code></h2><p>一些操作规则：</p><ul><li>读写一个 <code>nil</code> 的 <code>channel</code> 会立即阻塞</li><li>读一个关闭的 <code>channel</code> 会立刻返回一个 <code>channel</code> 元素类型的零值，即 <code>chan int</code> 会返回 <code>0</code></li><li>写一个关闭的 <code>channel</code> 会导致 <code>panic</code></li></ul><h1 id=函数调用>函数调用</h1><h2 id=汇编>汇编</h2><p>可以看一下这个 Golang 的官方介绍页面：https://golang.org/doc/asm</p><p><strong>add.go</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>add</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#66d9ef>uint64</span>
</span></span></code></pre></div><p><strong>add_amd64.s</strong> 或使用其他平台后缀，和 <strong>add.go</strong> 在同一个目录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>TEXT</span>    <span style=color:#960050;background-color:#1e0010>·</span>Add<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(SB),<span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    a<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(FP),BX
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    b<span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(FP),BP
</span></span><span style=display:flex><span><span style=color:#a6e22e>ADDQ</span>    BP,BX
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BX,res<span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(FP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>RET</span>     ,
</span></span></code></pre></div><h2 id=golang-调用-c>Golang 调用 C</h2><p><strong>add.c</strong> ，和 <strong>add.go</strong> 在同一个目录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#960050;background-color:#1e0010>·</span>Add(uint64 a, uint64 b, uint64 ret) {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    FLUSH(<span style=color:#f92672>&amp;</span>ret);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译这个包：<code>go install add</code></p><p>C 文件中需要包含 <code>runtime.h</code> 头文件。因为 Golang 使用特殊寄存器存放像全局 <code>struct G</code> 和 <code>struct M</code> ，包含这个文件可以让所有链接到 Go 的 C 文件感知这一点，避免编译器使用这些特定的寄存器做其他用途。</p><p>上面示例中返回值为空，使用 <code>ret</code> 作为返回值，<code>FLUSH</code> 在 <code>pkg/runtime/runtime.h</code> 中定义为 <code>USED()</code> ，防止编译器优化掉对某个变量的赋值操作（因为看不到这个变量在后面其他地方使用了）。</p><h2 id=函数调用时的内存布局>函数调用时的内存布局</h2><p>Golang 中使用的 C 编译器是 plan9 的 C 编译器，与 gcc 有一定差异。
这个页面中有部分基础介绍：
<a href=https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.1.html>https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.1.html</a></p><p>如果返回多个值，<code>func f(a, b int) (d, e int)</code> 内存布局如下所示：</p><pre tabindex=0><code>slot for e
slot for d
b
a 
&lt;- SP
</code></pre><p>调用后为</p><pre tabindex=0><code>slot for e
slot for d
b
a &lt;- FP
PC &lt;- SP
f&#39;s stack
</code></pre><p>plan9 的 C 汇编器对被调用函数的参数值的修改是会返回到调用函数中的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BX,d<span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(FP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BX,e<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(FP)
</span></span></code></pre></div><h1 id=go-关键字><code>go</code> 关键字</h1><p><code>f(1, 2, 3)</code> 的汇编:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>    f(SB)
</span></span></code></pre></div><p><code>go f(1, 2, 3)</code> 的汇编：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVL</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PUSHQ</span>   <span style=color:#66d9ef>$</span>f(SB)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PUSHQ</span>   <span style=color:#66d9ef>$</span><span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>    runtime.newproc(SB)
</span></span><span style=display:flex><span><span style=color:#a6e22e>POPQ</span>    AX
</span></span><span style=display:flex><span><span style=color:#a6e22e>POPQ</span>    AX
</span></span></code></pre></div><p><code>12</code> 是参数占用的大小，<code>runtime.newproc</code> 函数接受的参数为：参数大小、新的 goroutine 要运行的函数、函数的参数。<code>runtime.newproc</code> 会新建一个栈空间，将栈参数的 12 个字节复制到新的栈空间，并让栈指针指向参数。可以看做 <code>runtime.newproc(size, f, args)</code> 。</p><h1 id=defer-关键字><code>defer</code> 关键字</h1><p><code>return x</code> 不是原子语句，函数执行顺序为：</p><ol><li>给返回值赋值</li><li><code>defer</code> 调用</li><li><code>return</code></li></ol><p><code>defer</code> 实现对应 <code>runtime.deferproc</code>，其出现的地方插入指令 <code>call runtime.deferproc</code> ，函数返回之前的地方，插入 <code>call runtime.deferreturn</code> 。 goroutine 的控制结构中有一张表记录 <code>defer</code>，表以栈行为运作。</p><h1 id=continuous-stack>Continuous Stack</h1><p>我也基本理解了思路，具体细节可以看：https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html</p><p>最后的 <code>runtime.lessstack</code> 有些没看懂。</p><h1 id=闭包>闭包</h1><p>闭包中引用的变量不能在栈上分配，否则闭包函数返回的时候，栈上变量的地址就失效了。</p><h2 id=逃逸分析escape-analyze>逃逸分析（escape analyze）</h2><p>Golang 有个特性，可以自动识别哪些变量在栈上分配，哪些在堆上分配。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>Cursor</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#a6e22e>Cursor</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>X</span> = <span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noinline</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>      <span style=color:#66d9ef>$</span>type.<span style=color:#e6db74>&#34;&#34;</span>.Cursor<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(SB),(SP)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>取变量</span>c的类型<span style=color:#960050;background-color:#1e0010>，也就是</span>Cursor
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>$</span><span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>1</span>,<span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>      ,runtime.new(SB)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>调用</span>new函数<span style=color:#960050;background-color:#1e0010>，相当于</span>new(Cursor)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>$</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>      <span style=color:#ae81ff>8</span>(SP),AX    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>取</span>c.X的地址放到AX寄存器
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>      <span style=color:#66d9ef>$</span><span style=color:#ae81ff>500</span>,(AX)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>将</span>AX<span style=color:#960050;background-color:#1e0010>存放的内存地址的值赋为</span><span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>      AX,<span style=color:#e6db74>&#34;&#34;</span>.~r0<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(FP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ADDQ</span>      <span style=color:#66d9ef>$</span><span style=color:#ae81ff>16</span>,SP
</span></span></code></pre></div><p>在编译的过程中可以通过指令输出哪些变量逃逸了：<code>go build --gcflags=-m main.go</code></p><h2 id=闭包结构体>闭包结构体</h2><p>闭包将函数和它引用的环境表示为一个结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Closure</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>F</span> <span style=color:#66d9ef>func</span>()() 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>整体思路是返回闭包的时候，返回一个结构体，包含闭包返回函数的地址和引用的环境中的变量地址。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#66d9ef>$</span>type.int<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(SB),(SP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>$</span><span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>1</span>,<span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>    ,runtime.new(SB)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>是不是很熟悉，这一段就是</span>i <span style=color:#960050;background-color:#1e0010>=</span> new(int)    
</span></span><span style=display:flex><span><span style=color:#a6e22e>...</span>    
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#66d9ef>$</span>type.struct <span style=color:#960050;background-color:#1e0010>{</span> F uintptr<span style=color:#75715e>; A0 *int }+0(SB),(SP)    // 这个结构体就是闭包的类型</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL</span>    ,runtime.new(SB)    <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>接下来相当于</span> new(Closure)
</span></span><span style=display:flex><span><span style=color:#a6e22e>PCDATA</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>$</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#ae81ff>8</span>(SP),AX
</span></span><span style=display:flex><span><span style=color:#a6e22e>NOP</span>    ,
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#66d9ef>$</span><span style=color:#e6db74>&#34;&#34;</span>.func<span style=color:#960050;background-color:#1e0010>·</span><span style=color:#ae81ff>001</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(SB),BP
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BP,(AX)                <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>函数地址赋值给</span>Closure的F部分
</span></span><span style=display:flex><span><span style=color:#a6e22e>NOP</span>    ,
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#f92672>&amp;</span>i<span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(SP),BP        <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>将堆中</span>new的变量i的地址赋值给Closure的值部分
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    BP,<span style=color:#ae81ff>8</span>(AX)
</span></span><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span>    AX,<span style=color:#e6db74>&#34;&#34;</span>.~r1<span style=color:#f92672>+</span><span style=color:#ae81ff>40</span>(FP)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ADDQ</span>    <span style=color:#66d9ef>$</span><span style=color:#ae81ff>24</span>,SP
</span></span><span style=display:flex><span><span style=color:#a6e22e>RET</span>    ,
</span></span></code></pre></div><h1 id=引用>引用</h1><ol><li><a href=https://tiancaiamao.gitbooks.io/go-internals>https://tiancaiamao.gitbooks.io/go-internals</a></li><li><a href=http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/07_Hashing_Chaining.pdf>http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/07_Hashing_Chaining.pdf</a></li></ol></div><div class=post-footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//bef0rewind-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></main></body></html>