<!doctype html><html lang=zh-cn><head><title>Golang 系统调用/Syscall // 不是追风少年</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.100.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="bef0rewind"><meta name=description content><link rel=stylesheet href=https://blog.formalscience.com/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang 系统调用/Syscall"><meta name=twitter:description content="概述 很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：
func Read(fd int, p []byte) (n int, err error) func Write(fd int, p []byte) (n int, err error) 同时，Golang 也提供了对 Syscall 的直接调用支持：
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) RawSyscall 和 RawSyscall6 是对操作系统 Syscall 的直接调用；Syscall 和 Syscall6 会在调用操作系统 Syscall 前调用 runtime·entersyscall ，在操作系统 Syscall 返回后调用 runtime·exitsyscall 。"><meta property="og:title" content="Golang 系统调用/Syscall"><meta property="og:description" content="概述 很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：
func Read(fd int, p []byte) (n int, err error) func Write(fd int, p []byte) (n int, err error) 同时，Golang 也提供了对 Syscall 的直接调用支持：
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) RawSyscall 和 RawSyscall6 是对操作系统 Syscall 的直接调用；Syscall 和 Syscall6 会在调用操作系统 Syscall 前调用 runtime·entersyscall ，在操作系统 Syscall 返回后调用 runtime·exitsyscall 。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.formalscience.com/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-15T20:59:11+00:00"><meta property="article:modified_time" content="2018-01-15T20:59:11+00:00"></head><body><header class=app-header><a href=https://blog.formalscience.com/><img class=app-header-avatar src=/avatar.jpg alt=bef0rewind></a><h1>不是追风少年</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>当你在追着风，风也在推着你</p><div class=app-header-social><a href=https://github.com/ronhuafeng target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>我的 GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Golang 系统调用/Syscall</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jan 15, 2018</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://blog.formalscience.com/tags/golang/>Golang</a></div></div></header><div class=post-content><h1 id=概述>概述</h1><p>很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>fd</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>p</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>fd</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>p</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>)
</span></span></code></pre></div><p>同时，Golang 也提供了对 Syscall 的直接调用支持：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Syscall</span>(<span style=color:#a6e22e>trap</span>, <span style=color:#a6e22e>a1</span>, <span style=color:#a6e22e>a2</span>, <span style=color:#a6e22e>a3</span> <span style=color:#66d9ef>uintptr</span>) (<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>err</span> <span style=color:#a6e22e>Errno</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Syscall6</span>(<span style=color:#a6e22e>trap</span>, <span style=color:#a6e22e>a1</span>, <span style=color:#a6e22e>a2</span>, <span style=color:#a6e22e>a3</span>, <span style=color:#a6e22e>a4</span>, <span style=color:#a6e22e>a5</span>, <span style=color:#a6e22e>a6</span> <span style=color:#66d9ef>uintptr</span>) (<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>err</span> <span style=color:#a6e22e>Errno</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RawSyscall</span>(<span style=color:#a6e22e>trap</span>, <span style=color:#a6e22e>a1</span>, <span style=color:#a6e22e>a2</span>, <span style=color:#a6e22e>a3</span> <span style=color:#66d9ef>uintptr</span>) (<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>err</span> <span style=color:#a6e22e>Errno</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RawSyscall6</span>(<span style=color:#a6e22e>trap</span>, <span style=color:#a6e22e>a1</span>, <span style=color:#a6e22e>a2</span>, <span style=color:#a6e22e>a3</span>, <span style=color:#a6e22e>a4</span>, <span style=color:#a6e22e>a5</span>, <span style=color:#a6e22e>a6</span> <span style=color:#66d9ef>uintptr</span>) (<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>err</span> <span style=color:#a6e22e>Errno</span>)
</span></span></code></pre></div><p><code>RawSyscall</code> 和 <code>RawSyscall6</code> 是对操作系统 Syscall 的直接调用；<code>Syscall</code> 和 <code>Syscall6</code> 会在调用操作系统 Syscall 前调用 <code>runtime·entersyscall</code> ，在操作系统 Syscall 返回后调用 <code>runtime·exitsyscall</code> 。</p><p>这四个函数都是使用汇编语言实现，代码和具体的硬件体系结构和操作系统有关。<code>RawSyscall</code> 和 <code>RawSyscall6</code> 的行为和 C 语言中系统调用很类似，在这里不展开描述。而 <code>Syscall</code> 和 <code>Syscall6</code> 的行为（在进行真正的系统调用前后插入额外操作）与 Golang 的调度器关系紧密，在下面会进行要点描述。</p><p><code>Syscall</code> 的关键在于 <code>runtime·entersyscall</code> 和 <code>runtime·exitsyscall</code> ，而 <code>runtime·entersyscall</code> 还有一个行为有部分差异的版本 <code>runtime·entersyscallblock</code> 。</p><h1 id=runtimeentersyscall><code>runtime·entersyscall</code></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>entersyscall</span>(<span style=color:#a6e22e>dummy</span> <span style=color:#66d9ef>int32</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reentersyscall</span>(<span style=color:#a6e22e>getcallerpc</span>(), <span style=color:#a6e22e>getcallersp</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>dummy</span>)))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reentersyscall</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Disable preemption because during this function g is in Gsyscall status,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// but can have inconsistent g-&gt;sched, do not let GC observe it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Entersyscall must not call any function that might split/grow the stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (See details in comment above.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Catch calls that might, by replacing the stack guard with something that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// will trip any stack check and leaving a flag to tell newstack to die.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>stackPreempt</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>throwsplit</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Leave SP around for GC and traceback.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> = <span style=color:#a6e22e>sp</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallpc</span> = <span style=color:#a6e22e>pc</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>_g_</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gsyscall</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> &lt; <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span> &lt; <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			print(<span style=color:#e6db74>&#34;entersyscall inconsistent &#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span>), <span style=color:#e6db74>&#34; [&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span>), <span style=color:#e6db74>&#34;,&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span>), <span style=color:#e6db74>&#34;]\n&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;entersyscall&#34;</span>)
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>traceGoSysCall</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// systemstack itself clobbers g.sched.{pc,sp} and we might
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// need them later when the G is genuinely blocked in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// syscall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>entersyscall_sysmon</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>runSafePointFn</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// runSafePointFn may stack split if run on this stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>runSafePointFn</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>syscalltick</span> = <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>sysblocktraced</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>mcache</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>m</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>_Psyscall</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>entersyscall_gcwait</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Goroutines must not split stacks in Gsyscall status (it would corrupt g-&gt;sched).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// We set _StackGuard to StackPreempt so that first split stack check calls morestack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Morestack detects this case and throws.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>stackPreempt</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>runtime·entersyscall</code> 主要完成以下几件事：</p><ol><li>声明函数为 <code>NOSPLIT</code> ，不触发栈扩展检查</li><li>禁止抢占</li><li>通过 <code>dummy</code> 参数获得调用者的 <code>SP</code> 和 <code>PC</code> 的值，并保存到 goroutine 的 <code>syscallsp</code> 和 <code>syscallpc</code> 字段。同时记录 <code>syscallstack</code> 和 <code>syscallguard</code> ，使得垃圾回收器只对系统调用前的栈进行 <strong>mark-sweep</strong> （cgo 机制也利用了 <code>entersyscall</code> 来使得 cgo 中运行的代码不受垃圾回收机制管理）。</li><li>将 goroutine 的状态切换到 Gsyscall 状态。</li><li>唤醒后台线程 <code>sysmon</code> （这个线程会监控执行 <code>syscall</code> 的线程，如果超过某个时间阈值，就会将 M 与对应的 P 解除绑定）。</li><li>置空 M 的 <code>mcache</code> 、将 P 的 <code>m</code> 字段，切换 P 的状态到 <code>Psyscall</code></li><li>检查是否需要垃圾回收</li><li>通过 <code>g->stackguard0 = StackPreempt</code> 使得出现 <em>split stack</em> 时可以通过 <code>morestack</code> 捕获并抛出错误</li><li>恢复抢占</li></ol><p>可以看到 <code>reentersyscall</code> 多次调用 <code>save</code> 保存 <code>pc</code> 和 <code>sp</code>。<code>save</code> 更新 <code>getg().sched</code> 中的 <code>sp</code> 和 <code>pc</code> ，使得调用 <code>gogo</code> 的时候可以恢复 <code>pc</code> 和 <code>sp</code> 。<code>reentersyscall</code> 中 <code>save</code> 的目的都是为 goroutine 跳回这个 <code>syscall</code> 调用者执行 <code>syscall</code> 时刻的 <code>pc</code> 和 <code>sp</code>做准备。</p><p>需要继续深入：</p><ol><li><code>StackPreempt</code></li><li><code>syscallstack</code> 和 <code>syscallguard</code> 的具体作用时机</li></ol><h1 id=runtimeentersyscallblock><code>runtime·entersyscallblock</code></h1><p>与 <code>runtime·entersyscall</code> 区别在于这个函数认为当前执行的 <code>syscall</code> 会运行较长时间，因此在函数中主动进行了 M 和 P 的解除绑定，无需等待 <code>sysmon</code> 处理。解除 M 和 P 绑定的逻辑由 <code>entersyscallblock_handoff</code> 实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>entersyscallblock_handoff</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>traceGoSysCall</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>traceGoSysBlock</span>(<span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>handoffp</span>(<span style=color:#a6e22e>releasep</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=runtimeexitsyscall><code>runtime·exitsyscall</code></h1><p>主要实现了从 <code>syscall</code> 状态中恢复的动作：</p><ol><li>尝试调用 <code>exitsyscallfast</code> ，如果 M 与 P 没有完全解除绑定，那么该操作会将 M 和 P 重新绑定；否则获取一个空闲的 P 与当前 M 绑定。如果绑定成功，返回 <code>True</code>，否则返回 <code>False</code> 进行后续步骤处理。</li><li>如果 <code>exitsyscallfast</code> 返回 <code>True</code> ，函数就直接返回；返回 <code>False</code>，则进入 <em>slow path</em> 将当前 goroutine 放到任务队列中等待调度，具体实现由 <code>mcall(exitsyscall0)</code> 实现。</li></ol><p><code>exitsyscall0</code> 这个函数比较清晰，只是对其中 <code>dropg()</code> 的目的还没想清楚。</p><p><code>runtime·exitsyscall</code> 的函数说明中提到的 <code>// Write barriers are not allowed because our P may have been stolen.</code> 也没有搞清楚，知道和 GC 有一定关系。</p><h1 id=引用>引用</h1><ol><li><a href=https://studygolang.com/articles/7005>https://studygolang.com/articles/7005</a></li></ol></div><div class=post-footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var t=document,e=t.createElement('script');e.async=!0,e.src='//bef0rewind-blog.disqus.com/embed.js',e.setAttribute('data-timestamp',+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></main></body></html>