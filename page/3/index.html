<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.101.0"><title>不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="不是追风少年"><meta property="og:description" content><meta property="og:url" content="https://blog.formalscience.com/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/index.xml rel=alternate type=application/rss+xml title=不是追风少年></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/>理解 C++ Traits</a></h1><div class=post-meta><span class=post-date>2018-05-12</span></div><div class=post-content>C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 type_relation 的成员 relation 获取比较结果。当前代码输出：
type_relation&lt;bool, int>: different type_relation&lt;int, int>: different 这段代码并未实现预期功能，因为比较 bool 和 int，以及 int 和 int 时，都输出 "different" 。下面继续完善这个 trait 实现。</div><div><a class="read-more button" href=/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/21/2018-01-21_how-does-monero-work-%E7%AC%94%E8%AE%B0/>‘How Does Monero Work?&rsquo; 笔记</a></h1><div class=post-meta><span class=post-date>2018-01-21</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/note/>note</a>&nbsp;</span><div class=post-content>Monero 门罗币的一个介绍视频
我刚买到 1070Ti 显卡时曾经想要挖过这个币，后来放弃了，觉得没有意义。不过了解这个技术的一些原理还是有价值的。
Siraj Raval 的免责声明： 
Monero 是一种不可追踪的加密货币，网络上很多非法买卖东西的人会使用它。他介绍这个技术的原因是：你应当对你的数据有控制权，而很多数据是交易数据（transactional data）。目前很多公司可以从中免费挖掘信息，用来预测你的购买行为，以便向你展示广告。理想情况下他们应当为你的数据付费，而他们付费的唯一可能是你控制着数据，而唯一控制数据的方式为数据是匿名的。为了查阅你的交易历史，</div><div><a class="read-more button" href=/2018/01/21/2018-01-21_how-does-monero-work-%E7%AC%94%E8%AE%B0/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/17/2018-01-17_%E4%B8%A4%E4%B8%AA%E7%8E%BB%E7%92%83%E7%90%83%E7%BD%91%E4%B8%8A%E6%B5%81%E4%BC%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/>两个玻璃球（网上流传的面试题）</a></h1><div class=post-meta><span class=post-date>2018-01-17</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/>面试题</a>&nbsp;</span><div class=post-content>据说这是 Google 的一个面试题：
有一栋 100 层高的大楼，有两个完全相同的玻璃球。假设从某一层开始丢下玻璃球会摔碎，利用手中的两个玻璃球确定是第几层。最少扔几次玻璃球可以确定这个临界楼层（玻璃球在这一层以及更高的楼层扔下会摔碎）？
就如孔子说过的那句名言 “I Never Said All That Shit” 一样，这个题目出自哪里我也没有去考证。下面把我的思路整理一下。
如果只有一个玻璃球，能做的就是从 1 层开始尝试扔下玻璃球，然后尝试 2 层、3 层 ……，直到某一层扔下玻璃球后摔碎。而现在有两个玻璃球，我们可以用一个玻璃球从 1 层、11 层、21 层 …… 扔下去，确定一个较小的破碎范围，然后使用第二个玻璃球确定具体的楼层。
假如总共 N 层，我们从第 X 层扔下第一个玻璃球，有两种可能性：玻璃球摔碎或者没碎。如果玻璃球摔碎，说明临界楼层在 1~X 中；如果没摔碎，则临界楼层在 X+1~N 中。
如果临界楼层在 1~N 中是均匀分布的，那么 $N > 2$ 时确定临界楼层需要扔玻璃球的最少次数可以由以下公式表示：
$$ f(N)= \min_{X \in [1, N]} {1 + f(N-X)\frac{N-X}{N} + g(X)\frac{X}{N}} $$
$f(N)$ 为使用两个玻璃球确定区间长度为 N 时的临界楼层所用次数，$g(X)$ 为使用一个玻璃球确定区间长度为 N 时的临界楼层所用次数。这个公式的三部分分别对应：
一次扔玻璃球的尝试 玻璃球未摔碎概率$\times$此时继续尝试需要的次数 $f(N-X)$（两个玻璃球） 玻璃球摔碎概率$\times$此时继续尝试需要的次数 $g(X)$（一个玻璃球）。 显然有 $f(1)=0$，$g(N)=N-1$。可以用动态规划求解 $N=100$ 时需要的最少次数。</div><div><a class="read-more button" href=/2018/01/17/2018-01-17_%E4%B8%A4%E4%B8%AA%E7%8E%BB%E7%92%83%E7%90%83%E7%BD%91%E4%B8%8A%E6%B5%81%E4%BC%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/>Golang 系统调用/Syscall</a></h1><div class=post-meta><span class=post-date>2018-01-15</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>Golang</a>&nbsp;</span><div class=post-content>概述 很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：
func Read(fd int, p []byte) (n int, err error) func Write(fd int, p []byte) (n int, err error) 同时，Golang 也提供了对 Syscall 的直接调用支持：
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) RawSyscall 和 RawSyscall6 是对操作系统 Syscall 的直接调用；Syscall 和 Syscall6 会在调用操作系统 Syscall 前调用 runtime·entersyscall ，在操作系统 Syscall 返回后调用 runtime·exitsyscall 。</div><div><a class="read-more button" href=/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/>Golang 中学到的新东西</a></h1><div class=post-meta><span class=post-date>2018-01-14</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>Golang</a>&nbsp;</span><div class=post-content>数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&s[0]) var ptr unsafe.Pointer s := ((*[1&lt;&lt;10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := <em>(</em>[]byte)(unsafe.Pointer(&s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) map 实现 整个页面的内容对我来说都是新的：https://tiancaiamao.</div><div><a class="read-more button" href=/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/13/2018-01-13_%E4%BD%BF%E7%94%A8-nvidia-%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/>使用 Nvidia 显卡加速机器学习算法的一些资料</a></h1><div class=post-meta><span class=post-date>2018-01-13</span></div><div class=post-content>Nnidia 显卡可以用来加速机器学习算法（特别是深度学习），但安装驱动过程中总会碰到这样或者那样的问题。 一个难点是安装库的时候没有下载链接，比如 Nvidia 的 Cuda/cuDNN 主页经常会出现这样的提示：
NVIDIA Developer Site is under going maintenance. The site will be back by shortly. We apologize for any inconvenience. 虽然不能按照官方路径进行下载，但经过搜索总能找到一些入口。下面是我收集的一些链接：
cuDNN 下载页面：https://developer.nvidia.com/rdp/cudnn-download 这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 cuDNN v5.1 到 cuDNN 7.0.5 的版本 CUDA 下载页面：https://developer.nvidia.com/cuda-toolkit-archive 这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 CUDA Toolkit 1.0 到 CUDA Toolkit 9.0 的版本，最新的 CUDA Toolkit 9.1 的链接仍然指向正在维护的提示页面 Ubuntu 16.04 CUDA Toolkit 9.1 下载链接：http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_9.1.85-1_amd64.deb 此外可以在这个页面找到其他 Linux 发行版的安装包：http://developer.download.nvidia.com/compute/cuda/repos/ Windows 10 版本的 CUDA Toolkit 9.1 我成功下载过一次，但是和当前的 TensorFlow 1.</div><div><a class="read-more button" href=/2018/01/13/2018-01-13_%E4%BD%BF%E7%94%A8-nvidia-%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/12/2018-01-12_%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE_protocol_labs/>一些有趣的项目 Protocol Labs</a></h1><div class=post-meta><span class=post-date>2018-01-12</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/note/>note</a>&nbsp;</span><div class=post-content>最初在 3Blue1Brown 发布的一个介绍区块链原理的视频中看到了这个组织的连接。发现比较有意思，给大家分享一下~
项目的使命：
We believe the internet has become humanity’s most important technology. We build protocols, systems, and tools to improve how it works. Today, we are focused on how we store, locate, and move information.
我们相信互联网已成为人类最重要的技术。我们构建提升互联网工作能力的协议、系统和工具。当前我们集中在如何存储、定位和移动信息的工作上。
这段文字翻译得有点机器翻译风格。
项目地址：https://protocol.ai/projects/ ，目前上面有 5 个项目：
Filecoin 加密货币，Miners 通过向网络提供存储空间来获取 Filecoin ，使用者通过消耗 Filecoin 来在去中心化的网络中存储加密后的文件。 IPFS (InterPlanetary File System) 一种新型协议，用来使网络去中心化。IPFS 通过内容寻址和数字签名来创建完全去中心化和分布式的应用。IPFS 使得网络更快、更安全以及更加开放。 这是一段 YouTube 上的介绍视频：https://www.youtube.com/watch?v=8CMxDNuuAiQ ，介绍了 IPFS 的一些基本使用方法。根据我的理解，这是通过 content-address（immutable hash） 访问的分布式加密文件系统，可以通过命令行、网页界面等多种方式进行访问，有点类似 Samba，不过是分布式的。Siraj Raval 制作的一个视频：https://www.youtube.com/watch?v=BA2rHlbB5i0 ，也对 IPFS 进行了介绍，主要对 Why 的部分进行阐述。 带宽，多个客户端对中心节点访问 延迟 弹性 Resiliency，中心节点失效（网络断开或者数据删除）后无法进行数据访问 中心化 Centralization，主流网站掌控所有数据，用户无从得知数据的使用方式，此外会受到政府或者其他势力的干扰。 使用的技术：Chord、DHT、bit swap(bittorrent mechanism)、MerkleDAG Libp2p 一个模块化的网络栈，把一系列传输协议和 peer-to-peer 协议整合在一起，方便开发者构建大型、健壮的 p2p 网络 IPLD 去中心化网络（content-addressable web）的数据模型，它通过加密哈希值的方式连接了所有数据，使得数据的遍历和彼此链接更加容易。网站的示意图中连接了 bitcoin、以太坊、IPFS、Git Repo 等。 Multiformats 这个项目是面向未来验证系统（future-proof systems）的协议集合， 自描述的格式可以让你的系统可以互操作和具有可升级性。</div><div><a class="read-more button" href=/2018/01/12/2018-01-12_%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE_protocol_labs/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2017/11/11/2017-11-11-bar/>Bar</a></h1><div class=post-meta><span class=post-date>2017-11-11</span></div><div class=post-content>import "blog.formalscience.com/nothing" func main() { nothing.bar() } I dreamed about death this morning.
I dreamed about false dreams this morning.
I woke up tired.
I made some coffee with milk or without milk.
I saw some videos on Youtube and Bilibili.
I wrote this blog.</div><div><a class="read-more button" href=/2017/11/11/2017-11-11-bar/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2017/01/24/2017-01-24_%E6%88%91%E4%B8%80%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/>我一生的故事</a></h1><div class=post-meta><span class=post-date>2017-01-24</span></div><div class=post-content>我一生的故事 我终于去看了《降临》。最初知道 特德·姜／Ted Chiang 的《你一生的故事 ／Story of Your Life》要被搬上银幕的时候，我内心很激动，因为这是我非常喜欢的一篇科幻小说。不过担忧也是有的，很多科幻小说以电影的形式展现时，感觉上总是有些残缺，或囿于电影技术，或囿于艺术表现形式，或者就是书的读者有不切实际的期望。
再次听说相关消息时，已经是在美国上映的消息了，影片名称是《降临》，相比原书的标题这个名称显得更加科幻一些。然后听说到的就是各种好评，我本来期待着北邮人上什么时候会有下载资源，因为感觉国内没可能上映了。后来知道的就是上映的消息，直到今天观影结束。
我相信关注一些电影公众号的人肯定已经被剧透了，在此我就不再描述剧情了。对于我来说，看过中文版的小说，又看了英文版的小说，然后看了电影。在已经知道了剧情的前提下看电影，和已经知道了未来的人生的前提下继续生活有些相似之处。不过我头脑仍然只能处理从过去向未来流动的线形时间，而不是书中／电影中的 没有方向的文字。
语言真的可以影响人的思考方式吗？
作为《你一生的故事》理论基石的是语言相对性原理（萨丕尔-沃夫假说）。这是一个关于人类语言的假说：
认为不同语言裡所包含的文化概念和分类会影响语言使用者对于现实世界的认知，也就是说不同的语言的使用者会因语言差异而产生思考方式，行为方式的不同。
七肢桶（书中外星人因其外形得到的称呼）的文字是非线形的文字，复杂的文字在简单的文字之上通过改变结构得到，它们在表达一个思想之前就获得了这个思想对应文字的全部形状。同样对于它们来说，复杂的物理学定律，特别是人类目前没有掌握的关于时间空间的部分，比基础的牛顿定律来说更容易理解。光为什么沿着时间最短路径行进？我们可能需要量子理论来计算光行进所有可能路径然后对每一条路径进行积分算出其概率。对于七肢桶来说，光沿着最短路径行进就是其目的。
每个文明的科技进展路线和其环境有很大关系，一个内陆国家是发展出强大航海科技的可能性是很小的。对于七肢桶来说谈论过去和未来是没有意义的，它们只是向着目的前进。（即使这个“目的”在“未来”发生）也许这是看待世界的两种方式，就像在在时域和频域对一个信号进行不同的观察。
女主角在和七肢桶接触以及学习了其文字 —— “七文” 后，逐渐领悟了自己的未来。电影或书中出现未来的地方就容易出现矛盾。特别集中在人知道了未来之后能否改变未来这一问题上。有一种观点认为预知未来和自由意志之间只能二择其一。女主角在学习文字语言的过程中，到底是获取了预知未来的能力，还是放弃了自由意志？
预知未来的人不会奢谈未来，读过岁月之书的人不会承认自己读过它。 —— 《你一生的故事 ／Story of Your Life》 特德·姜／Ted Chiang
人们讴歌自由意志，然而又同时梦想可以预知未来。 —— 《我一生的故事》 乱说话的跳跳 ／ Bef0rewind
女主角在知道自己女儿将来会因为罕见病去世之后，依然（此处用选择或者决定都不合适）生下了她。后来她把自己对未来的预知告诉丈夫后，丈夫对她的行为感到愤怒，他们的婚姻也结束了。
对于电影中出现的一个小高潮，商将军告诉女主角自己的私人号码。有人质疑，女主角既然能够看见未来，为什么需要在未来的商将军告诉她这一信息。也许语言对她的影响是逐步产生的，未来的画面满满展开在了她面前，而在此刻她注定不知道这一信息。未来的商将军也受到了 “七文” 的影响，对女主角说：你应该（should）给我打电话。
书中最后没有提到七肢桶来到地球的目的，电影中给出了一个目的：三千年后七肢桶需要人类的帮助（它们在未来里看不到自己的目的了吗？）。电影中女主角对七肢桶的文字出版了教科书，讲授相关知识，也许会对地球人的思维产生影响吧。我也想过，七文会主导世界吗，地球人也会出现某种进化吧。好多语言会消失啊，对应的文明也消失了吧。
我讲过的两段话：
时间旅行故事中最美妙的因素就是时间。我在过去种下一颗种子，现在收获了一棵大树。
一个能够沿着时间轴前进后退的生命和一个只能单向前进的生命，哪个更有趣？前者已知所有，后者并不知道未来。如果前者眼中时间是一条线段（端点可能在无穷处），线段两端是其诞生和终结，可能还是对前面是否有尽头的未知有意思一点。
在英剧《奇异博士》五十周年特别篇 The Day Of The Doctor 中，三代博士使用的是同一个计算终端。当最老的博士在他的终端启动了计算，到了第三代博士手中的终端就处于计算了几百年之后的状态，得到了计算结果。
时间，只有时间。
我如果在书中，会是一个什么角色呢？我会有什么样的行为？作为一个希望与外星智慧生命接触的人，如果真有外星飞船降临，我得不到与它们见面的机会，毕竟我不是有特殊技能的人士。除非我是男主角，那外星生命可能出于某种目的同我接触。
有一点特别感动，父母会走到生命的尽头，孩子也会。我想到自己未来的孩子，我与你的故事，我会成为一个怎样的父亲，也许很久之前我就知道了呀。
一些相关的科幻小说
《与拉玛相会／Rendezvous with Rama》 阿瑟·克拉克／Arthur C. Clarke
一艘外星飞船从地球附近飞过，人类登陆上去后除了发现了高级自动机器人外，对于是否有智慧生命控制飞船以及其目的仍旧一无所知。最后随着飞船离地球远去，留给人类的只是一个谜。人是多么渴望自己有邻居，然而这个邻居确毫无回应地走了。
《海伯利安／Hyperion》丹·西蒙斯／Dan Simmons
这是一个背景宏大的故事，我们未来是否能够与人类的创造物（AI）和平共处？爆发战争的话，双方都要穿越时空传送回战力进行决斗。如果有更高级的生命，人类被其接纳的条件是什么？需要超越肉体形态，或者和 AI 进行合体产生新的生命吗？是否要保持人类的纯粹，还是对自身进行改造，适应地球之外的环境，在未来更广阔的世界中进化？
《永恒的终结／The End of Eternity》艾萨克·阿西莫夫 ／Isaac Asimov</div><div><a class="read-more button" href=/2017/01/24/2017-01-24_%E6%88%91%E4%B8%80%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2017/01/18/2017-01-18_ingress-passcode-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/>Ingress_Passcode_自动提交</a></h1><div class=post-meta><span class=post-date>2017-01-18</span></div><div class=post-content>什么是 Passcode？ 根据 Ingress 中文游戏指南 的讲解，Passcode 是 Ingress 提供的一种奖励。
使用 Investigation Board 来了解 Ingress 的最新剧情并寻求对 Niantic Project, NIA, XM, Shapers 以及各阵营不同问题的答案。 可以使用隐藏在这些报告之中的 Passcode 来兑换道具（Resonator，XMP 等），XM 或者 AP。
另外，一些官方活动会向到场者赠送包含 Passcode 的卡片，特定的官方周边也会赠送此类卡片。卡片上的 Passcode 一般能够兑换活动徽章。
注：在很多社交网站上可以找到有效的 Passcode
在 iOS 平台的 Ingress 客户端上 Passcode 兑换功能不可用，因此只能使用 Intel Map 来兑换。
在 Intel Map 上兑换 在右上方点击 Passcode 输入你的 passcode，然后点击 SUBMIT 兑换 自动化 Intel Map 兑换过程 可以通过浏览器的调试页面，自动将搜寻到的 passcode 提交，进行物品兑换。
表单提交 document.getElementById("redeem_reward_form").submit(); 不能正确提交表单失败的原因是这个表单的 input 元素名称就是 submit，需要重命名。
var field = document.</div><div><a class="read-more button" href=/2017/01/18/2017-01-18_ingress-passcode-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/>→</a></div></div><div class=pagination><div class=pagination__buttons><span class="button previous"><a href=/page/2/><span class=button__icon>←</span>
<span class=button__text>Newer posts</span></a></span>
<span class="button next"><a href=/page/4/><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>