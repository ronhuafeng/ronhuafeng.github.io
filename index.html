<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>不是追风少年</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我在生活中汲取力量">
<meta property="og:type" content="website">
<meta property="og:title" content="不是追风少年">
<meta property="og:url" content="http://blog.formalscience.com/index.html">
<meta property="og:site_name" content="不是追风少年">
<meta property="og:description" content="我在生活中汲取力量">
<meta property="article:author" content="Bef0rewind">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="不是追风少年" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon-animate.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">不是追风少年</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.formalscience.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2020-guidelines" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/01/2020-guidelines/" class="article-date">
  <time datetime="2020-01-01T00:00:00.000Z" itemprop="datePublished">2020-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%A7%84%E5%88%92/">规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/01/2020-guidelines/">2020 生活规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><p>适当精简，包括日常生活用品，生活中从事的事情，工作中要处理的事情，自己阅读、观影等时间话费，感情方面也是重要一环，把精力放在有价值的关系上。</p>
<ul>
<li>身体健康</li>
<li>读书、读论文</li>
<li>多游览各方</li>
<li>创作（文学、摄影）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2020/01/01/2020-guidelines/" data-id="ckpoawmh40025itp9fl2y8hen" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB/" rel="tag">生活</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%84%E5%88%92/" rel="tag">规划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-09-24-Rent-in-Edinburgh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/24/2019-09-24-Rent-in-Edinburgh/" class="article-date">
  <time datetime="2019-08-24T14:27:13.000Z" itemprop="datePublished">2019-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%85%E8%A1%8C/">旅行</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/24/2019-09-24-Rent-in-Edinburgh/">爱丁堡租房</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>生活就是一场旅行，这算是一个重大决定。到爱丁堡工作已经一周，时差基本倒过来了。<br>第一周住在酒店，最紧迫的事情就是租房，因为后续用来发工资的银行卡、办理警察局的手续都需要一个租房地址。</p>
<p>出国前了解过这边的租房市场，主要通过 Zoopla 或者 Rightmove 等软件。不过都是隔岸观火，还是要实地考察才靠谱。<br>这边看房不像国内有一个看房小哥，一下午能带你看十几套房子。<br>我在软件上看到想去瞧一下的房子，都是要打电话去预约、APP 内发消息等。<br>等收到电话回访或者邮件回复后，约定一个看房时间（viewing arrangement），然后去看房。<br>一般会有很多人一起看房，热门的房型可能会有十几人。不过中介机构也不会无限量地拉人看房，有时就告诉你没有看房名额了。<br>等看房满意后就可以邮件或者网站填写申请，如果房主（landlord）同意，那么就可以交定金成交了。</p>
<p>房租一般根据地理位置、装修等价格会有一些差别。<br>本来最初的目标是租一个一人间，比较难租到。后来和同事商量后，租了一个两人间。</p>
<p>听同事讲爱丁堡房产的租售比不错，也许可以考虑在这边投资一下房子。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2019/08/24/2019-09-24-Rent-in-Edinburgh/" data-id="ckpoawmh30023itp95iw462bm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Travel/" rel="tag">Travel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-02-17_To_Bangkok" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/17/2019-02-17_To_Bangkok/" class="article-date">
  <time datetime="2019-02-17T00:00:00.000Z" itemprop="datePublished">2019-02-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%85%E8%A1%8C/">旅行</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/17/2019-02-17_To_Bangkok/">To Bangkok</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#普通落地签证visa-on-arrival-voa">普通落地签证/Visa on Arrival (VOA)</a><ul>
<li><a href="#落地签需要的条件">落地签需要的条件</a></li>
<li><a href="#签证有效期">签证有效期</a></li>
</ul>
</li>
<li><a href="#电子落地签证e-visa-on-arrivale-voa">电子落地签证/E-Visa on Arrival(E-VOA)</a><ul>
<li><a href="#实际操作">实际操作</a></li>
</ul>
</li>
<li><a href="#换汇">换汇</a><ul>
<li><a href="#实际操作-1">实际操作</a></li>
</ul>
</li>
<li><a href="#实用信息">实用信息</a></li>
</ul>
<h2 id="普通落地签证-Visa-on-Arrival-VOA"><a href="#普通落地签证-Visa-on-Arrival-VOA" class="headerlink" title="普通落地签证/Visa on Arrival (VOA)"></a>普通落地签证/Visa on Arrival (VOA)</h2><p>中国公民适用普通落地签政策，相关政策链接：</p>
<blockquote>
<p><a href="http://www.thaiembassy.com/thailand/visa-on-arrival.php" target="_blank" rel="noopener">http://www.thaiembassy.com/thailand/visa-on-arrival.php</a></p>
</blockquote>
<ol>
<li>《申请表》(Application forVisa on Arrival)、1张白/蓝底4*6cm照片、15天内往返机票、有效期超过6个月的护照。(注：表格可下载并事先用英文填好;在泰如无联系人，可填写拟住酒店地址、电话)。</li>
<li>签证申请费每人1000铢。现场拍照另交费。申请落地签时，需备1万铢、每个家庭2万铢或等值外币以证明旅游期间有经济能力。泰移民官将抽查。</li>
</ol>
<h3 id="落地签需要的条件"><a href="#落地签需要的条件" class="headerlink" title="落地签需要的条件"></a>落地签需要的条件</h3><ul>
<li>持有泰国政府批准国家的护照者。</li>
<li>护照必须是真实的，不低于 30 天有效期。</li>
<li>泰国旅游的期限不超过 15 天。</li>
<li>有到达泰国时，不超过 15 天的回程机票。</li>
<li>报实际和能查询的泰国地址。</li>
<li>非佛历 2522 年的入境黑名单者</li>
<li>签证费仅收泰铢（现金）/不可退款</li>
<li>入境时个人必须随身携有外币不低于 10,000 泰铢， 家庭不低于 20,000 泰铢</li>
</ul>
<p>参考：<a href="https://ask.qyer.com/question/788823.html" target="_blank" rel="noopener">https://ask.qyer.com/question/788823.html</a></p>
<p>另外，2019/01/14 到 2020/04/30 落地签时免费的。</p>
<h3 id="签证有效期"><a href="#签证有效期" class="headerlink" title="签证有效期"></a>签证有效期</h3><p>落地签有效期15天(包括入境当天)，如为以旅游为目的则不可延期。离境时签证过期需向移民局缴纳罚款，1天500铢，最高不超2万铢。</p>
<h2 id="电子落地签证-E-Visa-on-Arrival-E-VOA"><a href="#电子落地签证-E-Visa-on-Arrival-E-VOA" class="headerlink" title="电子落地签证/E-Visa on Arrival(E-VOA)"></a>电子落地签证/E-Visa on Arrival(E-VOA)</h2><p>根据实际经验，落地泰国后如果走普通落地签的通道，队伍比较长，特别是航班密集落地的时候。<br>还有一种可以在网上预先申请的电子落地签，较为方便。</p>
<p>优点：</p>
<ol>
<li>仅需要护照信息</li>
<li>不需要提供实体照片</li>
</ol>
<p>费用：普通落地签费用 + 提供服务的公司的服务费用</p>
<p>参考：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/50974628" target="_blank" rel="noopener">不排队，1分钟快速入境！泰国电子落地签证（EVOA）申请攻略</a></li>
<li><a href="https://bbs.qyer.com/thread-3104742-1.html" target="_blank" rel="noopener">不要办e-visa落地签，没有任何意义- 泰国- 论坛- 穷游网</a></li>
</ol>
<p>有两家公司可以提供这项服务：</p>
<ol>
<li>VFS Global: <a href="http://www.evisathailand.com" target="_blank" rel="noopener">http://www.evisathailand.com</a><ul>
<li>普通服务：525 THB</li>
</ul>
</li>
<li>evisathailand: <a href="https://thailandevoa.vfsevisa.com" target="_blank" rel="noopener">https://thailandevoa.vfsevisa.com</a><ul>
<li>普通服务：600 THB</li>
<li>快速服务（24 小时出结果）：2500 THB</li>
</ul>
</li>
</ol>
<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><p>使用 <a href="https://thailandevoa.vfsevisa.com" target="_blank" rel="noopener">https://thailandevoa.vfsevisa.com</a> 申请，交了普通服务费 600 THB 。</p>
<h2 id="换汇"><a href="#换汇" class="headerlink" title="换汇"></a>换汇</h2><ol>
<li>机场 ATM 每次要收 150B 手续费</li>
<li>国内银行预约（<a href="https://ask.qyer.com/question/3452511.html）" target="_blank" rel="noopener">https://ask.qyer.com/question/3452511.html）</a><ul>
<li>国内一般只要提前一天预约就可以，不一定要本人换，其他人也可以帮你换，如果分行储备很充足，当天也可以换到，你试试不一定来不及吧</li>
<li>机场也有换，就是汇率不是很划算，如果担心那边没人可以再出发的机场换，你早点到机场，先换一点够用就行，剩下你过了关再换。</li>
<li>华夏银行卡 <a href="http://wenzhang.16fan.com/a/98638.html" target="_blank" rel="noopener">http://wenzhang.16fan.com/a/98638.html</a></li>
</ul>
</li>
<li>换汇处，之后去 super rich 换汇率最划算</li>
</ol>
<h3 id="实际操作-1"><a href="#实际操作-1" class="headerlink" title="实际操作"></a>实际操作</h3><p>就在机场换了一点，汇率不太好。<br>同伴从其他地方换了泰铢使用，我主要负责各种信用卡付款，所以最后使用现金也不是太多。</p>
<h2 id="实用信息"><a href="#实用信息" class="headerlink" title="实用信息"></a>实用信息</h2><ol>
<li>VFS Global 和 evisathailand 是两个不同的电子落地签代办公司。这两家公司在素万那普机场有各自独立的窗口，在普通的落地签证队伍旁边。我深夜到达的时候人很少，只有几个人在电子落地签队伍，入关很快。</li>
<li>VFS Global 最后打出来的纸上没有二维码，evisathailand 的有。</li>
<li>入关只需要那张纸、护照和入境卡三样东西。</li>
<li>Grab 很方便，到市区 300 多泰铢吧。</li>
<li>中国银行长城 Visa 白金信用卡汇率还不错。</li>
<li>不要尝试曼谷的中餐馆，贵而且不好吃。</li>
<li>大皇宫人很多，暹罗博物馆还不错，学生 50 泰铢（英文学生证就可以），其他外国人 200 泰铢。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2019/02/17/2019-02-17_To_Bangkok/" data-id="ckpoawmh1001zitp952nzgeu5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Travel/" rel="tag">Travel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-12-26-Go-to-Rust" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/26/2018-12-26-Go-to-Rust/" class="article-date">
  <time datetime="2018-12-26T00:00:00.000Z" itemprop="datePublished">2018-12-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">技术记录</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/tech-notes/">tech-notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/26/2018-12-26-Go-to-Rust/">Go to Rust （一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这几天看了 Rust 文档，把一些概念整理一下。</p>
<ul>
<li>通过 <code>cargo</code> 新建一个项目，然后去管理其生命流程，这种现代做法很方便。</li>
<li>对于 <code>statement</code> 和 <code>expression</code> 的使用方式和 scheme 有些类似，可以返回最后一个 <code>expression</code> 的值。</li>
<li>可能返回错误的地方使用 <code>Result</code> 类型，很类似 Haskell 的处理流程。</li>
<li>模式匹配的方式很像 Ocaml 。</li>
<li>ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。</li>
<li><code>Option</code> 类型就是 Haskell 的 <code>Maybe</code> 。</li>
<li>generics 的设计不知道有没有参考 C++ 的 template 概念。</li>
</ul>
<p>目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2018/12/26/2018-12-26-Go-to-Rust/" data-id="ckpoawmh0001xitp9303b0oup" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-12-13-pip-install-package-offline" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/13/2018-12-13-pip-install-package-offline/" class="article-date">
  <time datetime="2018-12-13T00:00:00.000Z" itemprop="datePublished">2018-12-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">技术记录</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/tech-notes/">tech-notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/13/2018-12-13-pip-install-package-offline/">pip 离线安装包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h2><p>在没有网络的设备上使用 pip 安装包。下面以 <code>sklearn</code> 包为例展示如何在没有网络的环境下安装包。</p>
<h2 id="2-下载包到本地缓存"><a href="#2-下载包到本地缓存" class="headerlink" title="2. 下载包到本地缓存"></a>2. 下载包到本地缓存</h2><p>首先进入一个目录，在这个例子里是 <code>/Users/bef0rewind/Downloads/pip-tmp</code> 目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip download sklearn</span><br></pre></td></tr></table></figure>

<p>我这里下载到了一个缓存目录 <code>/Users/bef0rewind/Downloads/pip-tmp</code>，随便选一个就好。<code>pip download</code> 只会下载对应的包，不会进行安装。</p>
<p>此时使用，<code>pip freeze</code> 可以看到已经安装的包，如果之前没有安装过 <code>sklearn</code>，显示的列表里是没有这个包的。</p>
<h2 id="3-断网安装"><a href="#3-断网安装" class="headerlink" title="3. 断网安装"></a>3. 断网安装</h2><p>为了展示没有网络的情况下如何安装，我断开网络进行了验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --no-index --find-links&#x3D;&#x2F;Users&#x2F;bef0rewind&#x2F;Downloads&#x2F;pip-tmp sklearn</span><br></pre></td></tr></table></figure>

<p>其中 <code>--find-links</code> 要 <code>pip</code> 从指定的目录里寻找安装包。</p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><p>如果要用 Python3，而系统默认的版本是 Python 2，则可以将 <code>pip</code> 命令换成 <code>pip3</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2018/12/13/2018-12-13-pip-install-package-offline/" data-id="ckpoawmgy001titp95wne1j5t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-12-06-还在下雨" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/2018-12-06-%E8%BF%98%E5%9C%A8%E4%B8%8B%E9%9B%A8/" class="article-date">
  <time datetime="2018-12-06T00:00:00.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9B%9E%E5%BF%86%E4%B8%AD%E8%80%81%E5%8E%BB/">回忆中老去</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/2018-12-06-%E8%BF%98%E5%9C%A8%E4%B8%8B%E9%9B%A8/">还在下雨</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>早上闹钟还没响，就收到学弟从美东发来的微信消息，高管在加拿大被扣留，感觉刚释放的贸易战缓和信号瞬间消失无影。接着看到同学发送的新闻，张首晟教授去世，又给学弟把这则消息转了过去。</p>
<p>到了公司也没获得更多信息。一天工作下来，解决了几个问题，心情是近来最平静的一天。雨一直下个不停，沿着玻璃幕墙下来，汇成一条条水线流下。</p>
<p>各类信息媒介上也是消息攒动，同样没获得更多有效信息。前段时间看到一个问题：为什么感觉今年逝去的名人特别多？我想，也许是他们的时代逝去了，也许是我们的时代逝去了。</p>
<p>小学、初中、高中的时候喜欢数学和诗歌。现在对一些人向往的“诗意的栖居”这种描述不怎么向往了。在这个世界，不可能所有人都能到达那种美好的彼岸。现实还是要战斗，在枪炮中让玫瑰绽放。</p>
<p>有观点说外面的世界再乱，只要自己的小环境能保持美好就够了。我也不知道要怎么选择，一是我不知道什么叫好的小环境，而是我可能也没能力隔绝外界的干扰，也就无所谓选择。</p>
<p>晚上从公司回来，雨还是在下，风吹在手上冻得不行。</p>
<p>寒冷 / 困顿 / 饥饿<br>树影 / 摇曳 / 零落<br>混乱 / 猜测 / 迷惑<br>启程 / 归来 / 此刻</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2018/12/06/2018-12-06-%E8%BF%98%E5%9C%A8%E4%B8%8B%E9%9B%A8/" data-id="ckpoawmgx001qitp93nudgpbg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018-11-30-escape-from-escape-analysis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/30/2018-11-30-escape-from-escape-analysis/" class="article-date">
  <time datetime="2018-11-30T00:00:00.000Z" itemprop="datePublished">2018-11-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">技术记录</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/tech-notes/">tech-notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/30/2018-11-30-escape-from-escape-analysis/">Escape from escape analysis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-逃逸分析背景"><a href="#1-逃逸分析背景" class="headerlink" title="1. 逃逸分析背景"></a>1. 逃逸分析背景</h2><p>Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。<br>特点是全局停顿时间比较少，在一些场景下是十微秒级别的。</p>
<p>垃圾回收算法针对的是堆（heap）中的内存。<br>为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。<br>这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。</p>
<p>而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。<br>如这篇文章《<a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html" target="_blank" rel="noopener">Golang escape analysis</a>》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。</p>
<p>对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。<br>这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。</p>
<h2 id="2-Go-版本"><a href="#2-Go-版本" class="headerlink" title="2. Go 版本"></a>2. Go 版本</h2><p>使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThinkPad-X1-Carbon:bin bef0rewind$ .&#x2F;go version</span><br><span class="line">go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin&#x2F;amd64</span><br></pre></td></tr></table></figure>

<h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: escape.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BigTempObject <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	field1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">causeEscape</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *BigTempObject:</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	obj := BigTempObject&#123;&#125;</span><br><span class="line">	addrObj := &amp;obj</span><br><span class="line"></span><br><span class="line">	causeEscape(addrObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>go run -gcflags=&quot;-m -m&quot; escape.go</code> 可以在运行时输出逃逸分析的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;escape.go:10: cannot inline causeEscape: unhandled op TYPESW</span><br><span class="line">.&#x2F;escape.go:19: cannot inline main: non-leaf function</span><br><span class="line">.&#x2F;escape.go:10: leaking param: i</span><br><span class="line">.&#x2F;escape.go:10:         from ... argument (arg to ...) at .&#x2F;escape.go:15</span><br><span class="line">.&#x2F;escape.go:10:         from *(... argument) (indirection) at .&#x2F;escape.go:15</span><br><span class="line">.&#x2F;escape.go:10:         from ... argument (passed to call[argument content escapes]) at .&#x2F;escape.go:15</span><br><span class="line">.&#x2F;escape.go:15: causeEscape ... argument does not escape</span><br><span class="line">.&#x2F;escape.go:23: addrObj escapes to heap</span><br><span class="line">.&#x2F;escape.go:23:         from addrObj (passed to call[argument escapes]) at .&#x2F;escape.go:23</span><br><span class="line">.&#x2F;escape.go:21: &amp;obj escapes to heap</span><br><span class="line">.&#x2F;escape.go:21:         from addrObj (assigned) at .&#x2F;escape.go:21</span><br><span class="line">.&#x2F;escape.go:21:         from addrObj (interface-converted) at .&#x2F;escape.go:23</span><br><span class="line">.&#x2F;escape.go:21:         from addrObj (passed to call[argument escapes]) at .&#x2F;escape.go:23</span><br><span class="line">.&#x2F;escape.go:20: moved to heap: obj</span><br><span class="line">(0x10904e0,0xc420080050)</span><br></pre></td></tr></table></figure>

<p><code>obj</code> 可以分配在栈上，因为在 <code>main</code> 函数返回时（栈退出），这个变量占用的空间就可以安全被用在其他地方了。<br>但是 “./escape.go:20: moved to heap: obj” 说明 <code>obj</code> 被分配在了堆上。</p>
<h2 id="4-小技巧"><a href="#4-小技巧" class="headerlink" title="4. 小技巧"></a>4. 小技巧</h2><p>如何改变这个分析结果，需要一点小技巧。</p>
<p>关键词是 <code>uintptr</code> 类型。<br>Go 语言中对 <code>uintptr</code> 是这样描述的：</p>
<blockquote>
<p>uintptr is an integer type that is large enough to hold the bit pattern of any pointer.</p>
</blockquote>
<p>比如在 64-bit Linux 系统上 <code>uintptr</code> 被定义成为了 <code>uint64</code>。<br>Go 中合法的类型转换为：<code>normal pointer</code> ⟷ <code>unsafe.Pointer</code> ⟷ <code>uintptr</code> 。<br>因此我们可以把上面的程序中的 <code>addrObj</code> 转换为 <code>uintptr</code>。<br>这样 Go 编译器不再认为 <code>addrObj</code> 同后面函数 <code>causeEscape</code> 使用的参数 <code>i</code> 存在引用关系，从而绕过 Escape Analysis Algorithm 。<br>为了防止垃圾回收过程中 <code>obj</code> 被回收，可以使用 <code>obj.field1 = 0</code> 来保持 <code>obj</code> 活跃。</p>
<p>修改后的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BigTempObject <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	field1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">causeEscape</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *BigTempObject:</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	obj := BigTempObject&#123;&#125;</span><br><span class="line">	addrObj := &amp;obj</span><br><span class="line">	intAddr := <span class="keyword">uintptr</span>(unsafe.Pointer(addrObj))</span><br><span class="line">	causeEscape((*BigTempObject)(unsafe.Pointer(intAddr)))</span><br><span class="line">	obj.field1 = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>go run -gcflags=&quot;-m -m&quot; escape.go</code> 运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;escape.go:13: cannot inline causeEscape: unhandled op TYPESW</span><br><span class="line">.&#x2F;escape.go:22: cannot inline main: non-leaf function</span><br><span class="line">.&#x2F;escape.go:13: leaking param: i</span><br><span class="line">.&#x2F;escape.go:13:         from ... argument (arg to ...) at .&#x2F;escape.go:18</span><br><span class="line">.&#x2F;escape.go:13:         from *(... argument) (indirection) at .&#x2F;escape.go:18</span><br><span class="line">.&#x2F;escape.go:13:         from ... argument (passed to call[argument content escapes]) at .&#x2F;escape.go:18</span><br><span class="line">.&#x2F;escape.go:18: causeEscape ... argument does not escape</span><br><span class="line">.&#x2F;escape.go:26: (*BigTempObject)(unsafe.Pointer(intAddr)) escapes to heap</span><br><span class="line">.&#x2F;escape.go:26:         from (*BigTempObject)(unsafe.Pointer(intAddr)) (passed to call[argument escapes]) at .&#x2F;escape.go:26</span><br><span class="line">.&#x2F;escape.go:24: main &amp;obj does not escape</span><br><span class="line">(0x10904e0,0xc42003bf70)</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>obj</code> 不再逃逸，主要是 <code>intAddr</code> 中断了逃逸分析算法构建的指针依赖关系（表示为一个有向图）。</p>
<h2 id="5-一点感想"><a href="#5-一点感想" class="headerlink" title="5. 一点感想"></a>5. 一点感想</h2><p>我们可以做到不代表一定去做，有风险也不代表禁区，采取什么样的行动是个人权衡后的选择。<br>什么原因导致了人们做了不同的选择，而人们不同的选择又导致了什么结果？<br>多样性是这个世界的现状，黑暗面与光明面同在。<br>May the force be with you.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/" data-id="ckpoawmgw001oitp9e1myfxgq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/programming-language/" rel="tag">programming language</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-11-21-Golang-Receiver-Type" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/2018-11-21-Golang-Receiver-Type/" class="article-date">
  <time datetime="2018-11-21T00:00:00.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">技术记录</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/tech-notes/">tech-notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/2018-11-21-Golang-Receiver-Type/">Golang Receiver Type 探索</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-参考"><a href="#1-参考" class="headerlink" title="1. 参考"></a>1. 参考</h2><p>在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。</p>
<ul>
<li><a href="https://golang.google.cn/ref/spec#Method_sets" target="_blank" rel="noopener">https://golang.google.cn/ref/spec#Method_sets</a></li>
<li><a href="https://golang.google.cn/ref/spec#Types" target="_blank" rel="noopener">https://golang.google.cn/ref/spec#Types</a></li>
<li><a href="https://golang.google.cn/ref/spec#Struct_types" target="_blank" rel="noopener">https://golang.google.cn/ref/spec#Struct_types</a></li>
<li><a href="https://golang.google.cn/ref/spec#Composite_literals" target="_blank" rel="noopener">https://golang.google.cn/ref/spec#Composite_literals</a></li>
</ul>
<p>核心的概念是 method sets：</p>
<blockquote>
<p>A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). Further rules apply to structs containing embedded fields, as described in the section on struct types. Any other type has an empty method set. In a method set, each method must have a unique non-blank method name.  </p>
<p>The method set of a type determines the interfaces that the type implements and the methods that can be called using a receiver of that type.</p>
</blockquote>
<p>下面的一些细节基本上都和这段描述相关。</p>
<h2 id="2-Duck-typing-与方法调用"><a href="#2-Duck-typing-与方法调用" class="headerlink" title="2. Duck typing 与方法调用"></a>2. Duck typing 与方法调用</h2><p>在很多面向对象的语言中，一个对象都可以“拥有”一些方法，使用例如 <code>obj.f(a, b, c)</code> 的形式进行调用。结合语言的类型系统，通过“扩展”、“继承”、“实现”等术语，我们可以将不同的类组织起来。在 Go 语言中采用的是 “duck typing”，没有显式的类型关系定义关键字。当一个类型实现了一个接口的全部方法时，那这个类型就被视为实现了这个接口。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Bark()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*A)</span> <span class="title">Bark</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> iA <span class="keyword">interface</span>&#123;&#125; = &amp;A&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := (iA).(Duck); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&amp;A&#123;&#125; is Duck"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&amp;A&#123;&#125; is not Duck"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> iB <span class="keyword">interface</span>&#123;&#125; = &amp;B&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := (iB).(Duck); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&amp;B&#123;&#125; is Duck"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&amp;B&#123;&#125; is not Duck"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;A&#123;&#125; is Duck</span><br><span class="line">&amp;B&#123;&#125; is not Duck</span><br></pre></td></tr></table></figure>

<p>我们可以用原始的类型去调用一个方法，也可以使用一个接口去调用方法。这里就涉及到方法调用者的问题：什么样的对象是一个合法的方法调用者？</p>
<p>至少 <code>A{}</code> 不是，因为我们实现 <code>Duck</code> 接口的时候，使用的是 <code>func (*A) Bark()</code> 进行的定义，而非 <code>func (A) Bark()</code>。这样就导致了只有 <code>A</code> 类型对象的指针类型才能作为方法调用者去调用 <code>Bark</code> 方法。</p>
<h2 id="3-成员函数的参数"><a href="#3-成员函数的参数" class="headerlink" title="3. 成员函数的参数"></a>3. 成员函数的参数</h2><p>在实现中，调用某个类型的成员方法，第一个参数其实是这个方法的实现对象自身，即如果是一个指针的方法，就是这个指针的值，如果是一个对象，就是这个对象的值。</p>
<p>下面使用 Go 1.8.3 展示，因为当前最新的 Go 编译器在打印 stack trace 的时候不再打印函数的参数（这个例子中）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> R1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	n <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *R1)</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"received"</span>, n)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"just a panic"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := &amp;R1&#123;&#125;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="built_in">println</span>(r)</span><br><span class="line">	r.f(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0xc420039f70</span><br><span class="line">received 1</span><br><span class="line">panic: just a panic</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.(*R1).f(0xc420039f70, 0x1)</span><br><span class="line">	&#x2F;Users&#x2F;bef0rewind&#x2F;Projects&#x2F;net example&#x2F;src&#x2F;main&#x2F;receiver_type.go:9 +0xa3</span><br><span class="line">main.main()</span><br><span class="line">	&#x2F;Users&#x2F;bef0rewind&#x2F;Projects&#x2F;net example&#x2F;src&#x2F;main&#x2F;receiver_type.go:16 +0x5a</span><br></pre></td></tr></table></figure>

<p>Stack trace 中函数 <code>f</code> 第一个值是指针 <code>r</code> 的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> R1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	n <span class="keyword">int</span></span><br><span class="line">	m <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *R1)</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"received"</span>, n)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"just a panic"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r R1)</span> <span class="title">g</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"received"</span>, n)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"just a panic"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := R1&#123;<span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="built_in">println</span>(r.n)</span><br><span class="line">	(r).g(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">received 1</span><br><span class="line">panic: just a panic</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.R1.g(0x7, 0x9, 0x1)</span><br><span class="line">	&#x2F;Users&#x2F;bef0rewind&#x2F;Projects&#x2F;net example&#x2F;src&#x2F;receiver_type&#x2F;main&#x2F;args.go:15 +0xa3</span><br><span class="line">main.main()</span><br><span class="line">	&#x2F;Users&#x2F;bef0rewind&#x2F;Projects&#x2F;net example&#x2F;src&#x2F;receiver_type&#x2F;main&#x2F;args.go:22 +0x58</span><br></pre></td></tr></table></figure>

<p>Stack trace 中函数 <code>g</code> 第一个值是 <code>r</code> 的值 <code>7</code> 和 <code>9</code>。</p>
<p>从这个实现方式中我们可以推断以下几点：</p>
<ul>
<li>Go 语言采用参数传值的方式进行函数调用，因此如果对象很大，使用的对象本身调用函数会带来大量的复制</li>
<li>不可能在函数调用中改变函数外的调用者，因为传到函数内部的只是调用者的副本</li>
</ul>
<h2 id="4-使用接口调用函数"><a href="#4-使用接口调用函数" class="headerlink" title="4. 使用接口调用函数"></a>4. 使用接口调用函数</h2><p>基于这样的成员函数实现方式，我们可以尝试另外一种调用方式：使用接口类型调用一个函数。<br>这里不是将一个对象转换成特定的接口然后去调用函数，而是使用接口类型本身去进行函数调用。<br>这种方式在 Go 1.9 中开始支持，在 Go 1.10 开始写入 Go 的 specs。这个例子使用的是 Go master 分支的版本，可能是 Go 1.11。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> M <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*M)</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"I;m M, with"</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IM <span class="keyword">interface</span> &#123;</span><br><span class="line">	f(n <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := &amp;M&#123;&#125;</span><br><span class="line">	IM.f(m, <span class="number">7</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I;m M, with 7</span><br></pre></td></tr></table></figure>

<p>此外还能使用匿名接口类型去调用函数，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> M <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*M)</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"I;m M, with"</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := &amp;M&#123;&#125;</span><br><span class="line">	<span class="keyword">interface</span>&#123;f(n <span class="keyword">int</span>)&#125;.f(m, <span class="number">7</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果与上面的一段采用 <code>IM</code> 接口定义的例子是一样的。</p>
<h2 id="5-注入依赖"><a href="#5-注入依赖" class="headerlink" title="5. 注入依赖"></a>5. 注入依赖</h2><p>有时候一个对象在实例化的时候，它的一些成员方法的行为可能还没有确定，需要依赖外界注入。此时我们可以在对象类型定义中内嵌一个接口，然后在后期传入一个接口的实例来确定其行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryOp <span class="keyword">interface</span> &#123;</span><br><span class="line">	Compute(a, b <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ComputeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y <span class="keyword">int</span></span><br><span class="line">	BinaryOp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *ComputeNode)</span> <span class="title">Result</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> node.BinaryOp.Compute(node.x, node.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Add <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Add)</span> <span class="title">Compute</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Multi <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Multi)</span> <span class="title">Compute</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	node := &amp;ComputeNode&#123;x:<span class="number">2</span>, y:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	node.BinaryOp = &amp;Add&#123;&#125;</span><br><span class="line">	<span class="built_in">println</span>(node.Result())</span><br><span class="line"></span><br><span class="line">	node.BinaryOp = &amp;Multi&#123;&#125;</span><br><span class="line">	<span class="built_in">println</span>(node.Result())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>注意一定要记得传入接口的实例，在这个例子中如果不给 <code>node</code> 传入一个 <code>BinaryOp</code> 接口实例，那 <code>node.BinaryOp</code> 是 <code>nil</code>，在调用 <code>Compute</code> 方法的时候就会发生异常。例如将上面的 <code>main</code> 函数稍作修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	node := &amp;ComputeNode&#123;x:<span class="number">2</span>, y:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//node.BinaryOp = &amp;Add&#123;&#125;</span></span><br><span class="line">	<span class="built_in">println</span>(node.Result())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code&#x3D;0x1 addr&#x3D;0x0 pc&#x3D;0x104d8d7]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.(*ComputeNode).Result(...)</span><br><span class="line">	&#x2F;Users&#x2F;bef0rewind&#x2F;Projects&#x2F;net example&#x2F;src&#x2F;receiver_type&#x2F;main&#x2F;injection.go:13</span><br><span class="line">main.main()</span><br><span class="line">	&#x2F;Users&#x2F;bef0rewind&#x2F;Projects&#x2F;net example&#x2F;src&#x2F;receiver_type&#x2F;main&#x2F;injection.go:32 +0x47</span><br></pre></td></tr></table></figure>


<h2 id="6-内部机制"><a href="#6-内部机制" class="headerlink" title="6. 内部机制"></a>6. 内部机制</h2><p>内部机制有一些细节。大体就是一个接口 <code>i</code> 包含两部分内容（指针），一个是接口代表的方法的集合，一个实现这个接口的具体对象；而一个对象 <code>obj</code>，它包含了自己的内存中的值，也能通过其类型获取到 <code>obj</code> 实现的方法集合。</p>
<p>将这两个概念记住，在实现一些模式的时候就会少很多心智负担。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>Go 语言的这套基于 “duck typing” 的机制好不好，争论有很多。不过我一向对这些争论没有特别的倾向，至少理解其机制之后按照其设计思路来用还可以正常使用，而且里面没有复杂的概念和例外情形。</p>
<p>也许我的理解有偏差，但现在还没有发现什么矛盾的地方。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2018/11/21/2018-11-21-Golang-Receiver-Type/" data-id="ckpoawmgu001kitp90pha06et" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/programming-language/" rel="tag">programming language</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-08-21_golang_exception_handling" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/21/2018-08-21_golang_exception_handling/" class="article-date">
  <time datetime="2018-08-21T00:00:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">技术记录</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/tech-notes/">tech-notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/2018-08-21_golang_exception_handling/">defer, panic and recover in Golang</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-什么是异常处理"><a href="#1-什么是异常处理" class="headerlink" title="1. 什么是异常处理"></a>1. 什么是异常处理</h2><p>程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。<br>一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 <code>try</code>/<code>catch</code>/<code>finally</code> 机制（<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、</a><br>Python 的 <code>try</code>/<code>raise</code>/<code>except</code>/<code>finally</code> 机制（<a href="https://docs.python.org/3/tutorial/errors.html）等。" target="_blank" rel="noopener">https://docs.python.org/3/tutorial/errors.html）等。</a></p>
<h2 id="2-Go-语言中的异常处理机制"><a href="#2-Go-语言中的异常处理机制" class="headerlink" title="2. Go 语言中的异常处理机制"></a>2. Go 语言中的异常处理机制</h2><p>Go 语言中使用的是 <code>defer</code>/<code>panic</code>/<code>recover</code> 机制来处理异常。Go 语言官方博客的《<a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="noopener">Defer, Panic, and Recover</a>》讲述了这个机制的具体应用方式。</p>
<p>还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：</p>
<ul>
<li>The Right Places To Call The recover Function：<a href="https://go101.org/article/panic-and-recover-more.html" target="_blank" rel="noopener">https://go101.org/article/panic-and-recover-more.html</a> ，几种使用 <code>recover</code> 恢复 Go 语言中 <code>panic</code> 的适用场景</li>
<li>7.异常处理：<a href="https://www.kancloud.cn/liupengjie/go/578555" target="_blank" rel="noopener">https://www.kancloud.cn/liupengjie/go/578555</a> ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节</li>
</ul>
<p>如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 <code>defer</code> + <code>recover</code>  处理一个 <code>panic</code>，<code>defer</code> 结构要在 <code>panic</code> 触发之前被定义而且 <code>recover</code> 要直接在在 <code>defer</code> 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。</p>
<h2 id="3-defer-语法糖的部分原理"><a href="#3-defer-语法糖的部分原理" class="headerlink" title="3. defer 语法糖的部分原理"></a>3. <code>defer</code> 语法糖的部分原理</h2><p>在讲述 <code>defer</code> 机制的文章中，都会提到一个函数中多个 <code>defer</code> 结构执行的顺序和定义顺序是相反的，即后定义的 <code>defer</code> 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">h</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> g(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">defer</span> h(<span class="string">"h"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>f</code> 输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>常见的函数调用流程为：</p>
<ul>
<li>将函数使用的参数压入栈</li>
<li>执行函数指令</li>
<li>函数执行结束返回到调用点</li>
</ul>
<p>如果 <code>defer</code> 相关的代码也是这么执行的话，那么为什么不是： <code>0</code> 入栈 - 执行 <code>g</code> - <code>g</code> 返回 - <code>&quot;h&quot;</code> 入栈 - 执行 <code>h</code> - <code>h</code> 返回 这个顺序呢？<br>按照这个顺序执行，调用 <code>f</code> 输出应该是 <code>0</code> 在 <code>h</code> 前面符合预期。是不是 Go 语言中执行 <code>defer</code> 时采用了特殊的处理流程？</p>
<p>是，也不是。</p>
<p>太阳底下无新鲜事，<code>defer</code> 不过是一个语法糖，用来对一个函数 <code>deferproc</code> 进行包装。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new deferred function fn with siz bytes of arguments.</span></span><br><span class="line"><span class="comment">// The compiler turns a defer statement into a call to this.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span></span><br></pre></td></tr></table></figure>

<p><code>deferproc</code> 创建一个延迟调用的函数，其参数为 <code>siz</code> （延迟调用的函数的参数占用的字节数量）和 <code>fn</code>（被延迟调用的函数本身）。<br>当 Go 程序的编译器遇到 <code>defer f()</code>，会将这条语句翻译为一条 <code>deferproc</code> 和一条 <code>deferreturn</code> 。<br>其中 <code>deferproc</code> 把被调用的函数及其参数挂载在 goroutine （Go 中的并发单元，协程）结构的一个链表上；<br><code>deferreturn</code> 从链表上取下一个挂载的被延迟执行的函数，执行它。</p>
<p>如何使用技巧绕过 <code>defer</code> 关键字，模拟类似效果？<br>可以使用 <code>linkname</code> 方法来把 Go 语言运行时的一些关键函数导出，从而进行某些不常见的操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eface <span class="keyword">struct</span> &#123;</span><br><span class="line">	_type <span class="keyword">uintptr</span></span><br><span class="line">	Data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EfaceOf</span><span class="params">(ep *<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Eface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (*Eface)(unsafe.Pointer(ep))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="keyword">uintptr</span></span><br><span class="line">	<span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname Deferproc runtime.deferproc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *Funcval)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname Deferreturn runtime.deferreturn</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deferreturn</span><span class="params">(arg0 <span class="keyword">uintptr</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"hacked defer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> fI <span class="keyword">interface</span>&#123;&#125; = f</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attach a defer struct to the current goroutine struct</span></span><br><span class="line">	Deferproc(<span class="number">0</span>, (*Funcval)(EfaceOf(&amp;fI).Data))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"original defer"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run a deferred function if there is one</span></span><br><span class="line">	Deferreturn(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">original defer</span><br><span class="line">hacked defer</span><br></pre></td></tr></table></figure>

<p>当然，如果是使用 <code>defer</code> 关键字，Go 语言的编译器会选择合适的位置插入 <code>deferreturn</code> 语句，而不是像上述代码中一样手动放在结束位置处。</p>
<h2 id="4-recover-生效位置的设计原因推测"><a href="#4-recover-生效位置的设计原因推测" class="headerlink" title="4. recover 生效位置的设计原因推测"></a>4. <code>recover</code> 生效位置的设计原因推测</h2><p>言归正传，<code>panic</code> 发生后，会根据函数调用顺序逐层上报，直到最后一层被抛出到系统导致崩溃或者被 <code>recover</code> 机制处理。<br>那么如果被 <code>recover</code> 处理，这个过程是怎么生效的？</p>
<p>很多教程中都提到 <code>recover</code> 一定要在 <code>defer</code> 声明的函数里面（既不是这个函数本身也不能是函数里面的其他函数里面）才能正确处理当前的 <code>panic</code> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1, not work</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">recover</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2, not work</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">recover</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 3, work</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">recover</span>()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>为什么呢？</p>
<p>先不考虑实现，先从理念上分析一下。</p>
<ol>
<li><code>defer</code> 直接作用于 <code>recover()</code>：无法根据 <code>recover()</code> 的返回值来进行不同类型的 <code>panic</code> 处理</li>
<li>在被 <code>defer</code> 作用的函数内部的函数 <code>g</code> 中使用 <code>recover()</code>：如果 <code>g</code> 是一个第三方库的函数，无法保证其中没有未知的 <code>recover</code> 意外处理了系统中的 <code>panic</code>。</li>
</ol>
<p>因此事实上也只能通过这样的约束来使这个异常处理机制看上去直观易处理一些。当然通过对 Go 编译器进行修改，还是有办法使得上面三种情况下 <code>recover</code> 都可以中断 <code>panic</code> 向上层传递过程的。</p>
<p>此外，由于被 <code>defer</code> 处理的函数被挂载在 goroutine 结构的一个链表上，因此当 <code>panic</code> 发生时，可以直接从这个链表上取下被延迟执行的函数一个个执行。<br>这也是 <code>recover</code> 要放在 <code>deferred function</code> 中的原因，因为这些函数是肯定可以执行到的。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>不能说 Go 中这个异常处理机制有多高明，基本上属于现代语言标配。了解更多背后的原理，在使用时可以更坚定一些。</p>
<p>此外，最近看到一本书《最好的告别》（<a href="https://book.douban.com/subject/26576861/）。" target="_blank" rel="noopener">https://book.douban.com/subject/26576861/）。</a></p>
<p><img src="https://images-na.ssl-images-amazon.com/images/I/41rwxKTGwXL._SX308_BO1,204,203,200_.jpg" alt="Being Mortal"></p>
<p>豆瓣上的介绍：</p>
<blockquote>
<p>当独立、自助的生活不能再维持时，我们该怎么办？在生命临近终点的时刻，我们该和医生谈些什么？应该如何优雅地跨越生命的终点？对于这些问题，大多数人缺少清晰的观念，而只是把命运交由医学、技术和陌生人来掌控。影响世界的医生阿图•葛文德结合其多年的外科医生经验与流畅的文笔，讲述了一个个伤感而发人深省的故事，对在21世纪变老意味着什么进行了清醒、深入的探索。</p>
</blockquote>
<p><code>defer</code> / <code>finally</code> 这些关键字让我们可以控制函数退出时的行为，但是我们自身呢？也许考虑这些问题可以让我们自身活得有意义一些。</p>
<p>推荐大家看一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2018/08/21/2018-08-21_golang_exception_handling/" data-id="ckpoawmgt001iitp9hs06bdl2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-commands" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/22/commands/" class="article-date">
  <time datetime="2018-07-22T00:00:00.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">技术记录</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/tech-notes/">tech-notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/commands/">Useful Commands</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Convert-images-to-a-video"><a href="#Convert-images-to-a-video" class="headerlink" title="Convert images to a video"></a>Convert images to a video</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -r 30 -start_number 3455 -i _IMG%d.jpg -s 960X600 -pix_fmt yuv420p 30fps-960.mov</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-r 30</code>: 30 frames per second</li>
<li><code>-s 960X600</code>: resolution</li>
<li><code>-pix_fmt yuv420p</code>: for OsX</li>
</ul>
<h2 id="youtube-dl-video-and-extract-audio-file"><a href="#youtube-dl-video-and-extract-audio-file" class="headerlink" title="youtube-dl video and extract audio file"></a>youtube-dl video and extract audio file</h2><p><code>youtube-dl --proxy socks5://127.0.0.1:1080 -x --audio-format mp3 youtube-url</code></p>
<h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><ul>
<li><code>WORKON_HOME</code>: which directory your environments are created in</li>
<li><code>/usr/local/bin/virtualenvwrapper.sh</code>: default location for its configuration file</li>
<li><code>mkvirtualenv test --python=python3</code>: make a virtual environment ‘test’ with python3</li>
<li><code>rmvirtualenv test</code>: remove a virtual environment ‘test’</li>
<li><code>workon test3</code> or <code>lsvirtualenv -b test3</code>: activate a virtual environment ‘test’</li>
<li><code>deactivate</code>: exit current environment</li>
<li>more details: search engine<ul>
<li>how to avoid globa packages</li>
<li>how to copy an environment</li>
</ul>
</li>
</ul>
<h2 id="node-amp-amp-npm"><a href="#node-amp-amp-npm" class="headerlink" title="node &amp;&amp; npm"></a>node &amp;&amp; npm</h2><p>npm complains: <code>Error: Cannot find module &#39;process-nextick-args&#39;</code></p>
<p>Uninstall node, <code>brew uninstall node</code>, then by <a href="https://stackoverflow.com/questions/11177954/how-do-i-completely-uninstall-node-js-and-reinstall-from-beginning-mac-os-x" target="_blank" rel="noopener">this stackoverflow post</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;node* &#x2F;usr&#x2F;local&#x2F;lib&#x2F;dtrace&#x2F;node.d ~&#x2F;.npm ~&#x2F;.node-gyp </span><br><span class="line">sudo rm -rf &#x2F;opt&#x2F;local&#x2F;bin&#x2F;node &#x2F;opt&#x2F;local&#x2F;include&#x2F;node &#x2F;opt&#x2F;local&#x2F;lib&#x2F;node_modules</span><br><span class="line">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;node.1 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;dtrace&#x2F;node.d</span><br></pre></td></tr></table></figure>

<p>Just delete something, then <code>brew install npm</code>.</p>
<h2 id="delve-dlv-tips"><a href="#delve-dlv-tips" class="headerlink" title="delve (dlv) tips"></a>delve (dlv) tips</h2><ul>
<li>funcs [regexp] : get function list</li>
<li>call : call a function (in a newer a go version, dlv should be installed in the newer go version too)</li>
</ul>
<h2 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p><code>ssserver -c /etc/shadowsocks/config.json</code></p>
<p><code>sslocal</code> and <code>ssserver</code> are all from <code>apt-get install shadowsocks</code>.</p>
<h2 id="WSL-2-amp-amp-VMware-switch"><a href="#WSL-2-amp-amp-VMware-switch" class="headerlink" title="WSL 2 &amp;&amp; VMware switch"></a>WSL 2 &amp;&amp; VMware switch</h2><p>After enabling WSL 2 on Windows 10 insider preview, VMware virtual machine is disabled.<br>This is because collision between Hyper-V and VMware.</p>
<p>Turn on VMware</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure>

<p>Turn on Hyper-V &amp;&amp; WSL 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure>

<p>reference: <a href="https://blog.minirplus.com/10268/" target="_blank" rel="noopener">https://blog.minirplus.com/10268/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.formalscience.com/2018/07/22/commands/" data-id="ckpoawmhg003bitp9cjljc1fo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9B%9E%E5%BF%86%E4%B8%AD%E8%80%81%E5%8E%BB/">回忆中老去</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9B%9E%E5%BF%86%E4%B8%AD%E8%80%81%E5%8E%BB/%E6%84%9F%E6%82%9F/">感悟</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%87%E5%AE%99%E5%B0%8F%E7%99%BE%E7%A7%91/">宇宙小百科</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B1%B1%E9%87%8E/">山野</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">技术记录</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/tech-notes/">tech-notes</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%85%E8%A1%8C/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A7%82%E7%82%B9/">观点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A7%84%E5%88%92/">规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%97%E6%AD%8C/">诗歌</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%97%E6%AD%8C%E7%9A%84%E6%B5%B7%E6%B4%8B/">诗歌的海洋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E8%A7%82%E5%BD%B1/">读书观影</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Functional-Programming/" rel="tag">Functional Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haskell/" rel="tag">Haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Travel/" rel="tag">Travel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/note/" rel="tag">note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-language/" rel="tag">programming language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80/" rel="tag">函数式语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB/" rel="tag">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%84%E5%88%92/" rel="tag">规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/Golang/" style="font-size: 20px;">Golang</a> <a href="/tags/Haskell/" style="font-size: 10px;">Haskell</a> <a href="/tags/Rust/" style="font-size: 10px;">Rust</a> <a href="/tags/Travel/" style="font-size: 15px;">Travel</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/note/" style="font-size: 15px;">note</a> <a href="/tags/programming-language/" style="font-size: 15px;">programming language</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">函数式语言</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 10px;">生活</a> <a href="/tags/%E8%A7%84%E5%88%92/" style="font-size: 10px;">规划</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">October 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">June 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">April 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/01/2020-guidelines/">2020 生活规划</a>
          </li>
        
          <li>
            <a href="/2019/08/24/2019-09-24-Rent-in-Edinburgh/">爱丁堡租房</a>
          </li>
        
          <li>
            <a href="/2019/02/17/2019-02-17_To_Bangkok/">To Bangkok</a>
          </li>
        
          <li>
            <a href="/2018/12/26/2018-12-26-Go-to-Rust/">Go to Rust （一）</a>
          </li>
        
          <li>
            <a href="/2018/12/13/2018-12-13-pip-install-package-offline/">pip 离线安装包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Bef0rewind<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>