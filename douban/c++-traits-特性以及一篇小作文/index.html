<!doctype html><html lang=zh-cn><head><title>2018-05-02_C++ Traits 特性以及一篇小作文 // 不是追风少年</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.104.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="bef0rewind"><meta name=description content><link rel=stylesheet href=https://blog.formalscience.com/css/main.min.7399fa7ec2205ae468fae43bdd5857841a2cd7eb35f0c8562b0e111b9d44c95f.css><meta name=twitter:card content="summary"><meta name=twitter:title content="2018-05-02_C++ Traits 特性以及一篇小作文"><meta name=twitter:description content="C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体type_relation的成员relation获取比较结果。当前代码输出：
type_relation<bool, int>: different type_relation<int, int>: different 这段代码并未实现预期功能，因为比较bool和int，以及int和int时，都输出&#34;different&#34;。下面继续完善这个 trait 实现。
第 11 行的类型参数种使用<T, T>（即两个相同的类型）进行模式匹配。这段代码输出：
type_relation<bool, int>: different type_relation<int, int>: equal 输出结果正确完成了类型比较的功能。"><meta property="og:title" content="2018-05-02_C++ Traits 特性以及一篇小作文"><meta property="og:description" content="C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体type_relation的成员relation获取比较结果。当前代码输出：
type_relation<bool, int>: different type_relation<int, int>: different 这段代码并未实现预期功能，因为比较bool和int，以及int和int时，都输出&#34;different&#34;。下面继续完善这个 trait 实现。
第 11 行的类型参数种使用<T, T>（即两个相同的类型）进行模式匹配。这段代码输出：
type_relation<bool, int>: different type_relation<int, int>: equal 输出结果正确完成了类型比较的功能。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.formalscience.com/douban/c++-traits-%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%AF%87%E5%B0%8F%E4%BD%9C%E6%96%87/"><meta property="article:section" content="douban"><meta property="article:published_time" content="2018-05-02T00:00:00+00:00"><meta property="article:modified_time" content="2018-05-02T00:00:00+00:00"></head><body><header class=app-header><a href=https://blog.formalscience.com/><img class=app-header-avatar src=/avatar.jpg alt=bef0rewind></a>
<span class=app-header-title>不是追风少年</span><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/categories/>Categories</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>当你在追着风，风也在推着你</p><div class=app-header-social><a href=https://github.com/ronhuafeng target=_blank rel="noreferrer noopener me"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>我的 GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>2018-05-02_C++ Traits 特性以及一篇小作文</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>May 2, 2018</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>1 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://blog.formalscience.com/tags/%E8%B1%86%E7%93%A3/>豆瓣</a></div></div></header><div class=post-content><p>C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。</p><p>C++ 之父 Bjarne Stroustrup 说：</p><blockquote><p>Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.</p></blockquote><p>嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。</p><p><img src=/douban/p50326659.jpg alt>这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体t<code>ype_relation的</code>成员rel<code>ation获取比</code>较结果。当前代码输出：</p><pre tabindex=0><code>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: different
</code></pre><p>这段代码并未实现预期功能，因为比较b<code>ool和</code>int<code>，以及</code>int和<code>int</code>时，都<code>输出"</code>differe<code>nt"。下面继续完善这</code>个 trait 实现。</p><p><img src=/douban/p50326664.jpg alt>第 11 行的类型参数种使用&lt;<code>T, T>（</code>即两个相同的类型）进行模式匹配。这段代码输出：</p><pre tabindex=0><code>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: equal
</code></pre><p>输出结果正确完成了类型比较的功能。</p><p>实现</p><p>trait 的实现基于 C++ 的模板引擎（template engine），能够在**编译时期（compile time）**将模板（基于最匹配的模式）展开。如果要在 Golang 或者 Java 种实现类似功能，可以使用反射或者 interface 之类的方法，而这些方法都是在运行时（runtime）进行判定，不可避免带来性能开销。</p><p>进阶</p><p>除了可以比较两个类型是否相等，还可以在类型参数上添加其他约束，例如：<code>*</code>、<code>[]</code>等。下面是一个稍微复杂一些的版本：</p><p><img src=/douban/p50326660.jpg alt>输出：</p><pre tabindex=0><code>type_relation&lt;bool, int&gt;: different
type_relation&lt;int, int&gt;: equal
type_relation&lt;int*, int&gt;: is pointer of
type_relation&lt;int[], int&gt;: is array of
type_relation&lt;int[4], int&gt;: is array (length 4) of
</code></pre><p>当然这个“进阶”仅仅是比上面的例子复杂了一些，trait 还有更多能力。 C++ 的模板引擎为 C++ 提供了强大的元编程（meta programming）能力，也使得现代的 C++ 代码看上去比较奇怪。 事实上模板引擎是图灵完备的，如果使用好的话，能够将 C++ 的易用性和优雅性提升到一个高度（从那些看不到模板实现细节的用户的视角）。</p><hr><p>感想</p><p>每次 C++ 标准更新的新闻我都看到了，从 C++0X、C++11、C++14 到 C++17，新出的特性一直在关注，可却从来没有真正编写一段程序去试试这些特性。这让我很伤感。</p><p>看到新的语言就想去尝试，OCaml、Clojure、Haskell …… 这些语言都很有特色，OCaml 让我体会到模式匹配的爽快，Clojure 让我体会到 S-表达式的自由和 Lisp 宏的强大，Haskell 让我体会到抽象的威力以及自己脑容量的有限。可是工作中用的最多的还是 Python、Java 和 C，当然还有 PHP （这个不能忘）。</p><p>想我和 C++ 的关系，最初的时候还是看的 Bjarne Stroustrup 的《The C++ Programming Language》入门。后来怎么就越走越远了呢？虽然现在工作中暂时依旧用不到，还是希望以此为契机，了解更多模板引擎可以做的事情。</p><p>追逐过的其他语言，各有各的契机，或许是缘分，或许是喜欢，或许是虚荣。现在都不敢说自己会 C++ 了。 如果当时能够更专注一些，自己目前的职业轨迹会不会有所区别？</p><p>想起最初自己理解 Haskell 里M<code>onad概</code>念的时候，一头雾水。后来懂了，就是懂了。为什么偏爱某一种语言呢？我也搞不清楚自己。</p><p>也许其他事情也是如此，回忆当初做的不同，结果是否能够更好？也许。记住过往，抗拒住回忆的诱惑，很难，但不得不做。喜欢的，就喜欢着吧。有些事情就是不行，正如有些事情莫名其妙地发生。</p><p>Just live with it.</p></div></article></main></body></html>