<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on 不是追风少年</title><link>https://blog.formalscience.com/tags/golang/</link><description>Recent content in Golang on 不是追风少年</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 26 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.formalscience.com/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go to Rust （一）</title><link>https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/</link><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/</guid><description>这几天看了 Rust 文档，把一些概念整理一下。
通过 cargo 新建一个项目，然后去管理其生命流程，这种现代做法很方便。 对于 statement 和 expression 的使用方式和 scheme 有些类似，可以返回最后一个 expression 的值。 可能返回错误的地方使用 Result 类型，很类似 Haskell 的处理流程。 模式匹配的方式很像 Ocaml 。 ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。 Option 类型就是 Haskell 的 Maybe 。 generics 的设计不知道有没有参考 C++ 的 template 概念。 目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。</description><content>&lt;p>这几天看了 Rust 文档，把一些概念整理一下。&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>cargo&lt;/code> 新建一个项目，然后去管理其生命流程，这种现代做法很方便。&lt;/li>
&lt;li>对于 &lt;code>statement&lt;/code> 和 &lt;code>expression&lt;/code> 的使用方式和 scheme 有些类似，可以返回最后一个 &lt;code>expression&lt;/code> 的值。&lt;/li>
&lt;li>可能返回错误的地方使用 &lt;code>Result&lt;/code> 类型，很类似 Haskell 的处理流程。&lt;/li>
&lt;li>模式匹配的方式很像 Ocaml 。&lt;/li>
&lt;li>ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。&lt;/li>
&lt;li>&lt;code>Option&lt;/code> 类型就是 Haskell 的 &lt;code>Maybe&lt;/code> 。&lt;/li>
&lt;li>generics 的设计不知道有没有参考 C++ 的 template 概念。&lt;/li>
&lt;/ul>
&lt;p>目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。&lt;/p></content></item><item><title>Escape from escape analysis</title><link>https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/</guid><description>1. 逃逸分析背景 Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。 特点是全局停顿时间比较少，在一些场景下是十微秒级别的。
垃圾回收算法针对的是堆（heap）中的内存。 为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。 这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。
而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。 如这篇文章《Golang escape analysis》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。
对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。 这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。
2. Go 版本 使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。
ThinkPad-X1-Carbon:bin bef0rewind$ ./go version go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64 3. 示例 // file: escape.go package main import &amp;#34;fmt&amp;#34; type BigTempObject struct { /// ... field1 int } func causeEscape(i interface{}) { switch i.</description><content>&lt;h2 id="1-逃逸分析背景">1. 逃逸分析背景&lt;/h2>
&lt;p>Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。
特点是全局停顿时间比较少，在一些场景下是十微秒级别的。&lt;/p>
&lt;p>垃圾回收算法针对的是堆（heap）中的内存。
为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。
这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。&lt;/p>
&lt;p>而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。
如这篇文章《&lt;a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">Golang escape analysis&lt;/a>》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。&lt;/p>
&lt;p>对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。
这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。&lt;/p>
&lt;h2 id="2-go-版本">2. Go 版本&lt;/h2>
&lt;p>使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。&lt;/p>
&lt;pre tabindex="0">&lt;code>ThinkPad-X1-Carbon:bin bef0rewind$ ./go version
go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64
&lt;/code>&lt;/pre>&lt;h2 id="3-示例">3. 示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// file: escape.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">field1&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>.(&lt;span style="color:#66d9ef">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">addrObj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">addrObj&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>go run -gcflags=&amp;quot;-m -m&amp;quot; escape.go&lt;/code> 可以在运行时输出逃逸分析的结果。&lt;/p>
&lt;pre tabindex="0">&lt;code>./escape.go:10: cannot inline causeEscape: unhandled op TYPESW
./escape.go:19: cannot inline main: non-leaf function
./escape.go:10: leaking param: i
./escape.go:10: from ... argument (arg to ...) at ./escape.go:15
./escape.go:10: from *(... argument) (indirection) at ./escape.go:15
./escape.go:10: from ... argument (passed to call[argument content escapes]) at ./escape.go:15
./escape.go:15: causeEscape ... argument does not escape
./escape.go:23: addrObj escapes to heap
./escape.go:23: from addrObj (passed to call[argument escapes]) at ./escape.go:23
./escape.go:21: &amp;amp;obj escapes to heap
./escape.go:21: from addrObj (assigned) at ./escape.go:21
./escape.go:21: from addrObj (interface-converted) at ./escape.go:23
./escape.go:21: from addrObj (passed to call[argument escapes]) at ./escape.go:23
./escape.go:20: moved to heap: obj
(0x10904e0,0xc420080050)
&lt;/code>&lt;/pre>&lt;p>&lt;code>obj&lt;/code> 可以分配在栈上，因为在 &lt;code>main&lt;/code> 函数返回时（栈退出），这个变量占用的空间就可以安全被用在其他地方了。
但是 “./escape.go:20: moved to heap: obj” 说明 &lt;code>obj&lt;/code> 被分配在了堆上。&lt;/p>
&lt;h2 id="4-小技巧">4. 小技巧&lt;/h2>
&lt;p>如何改变这个分析结果，需要一点小技巧。&lt;/p>
&lt;p>关键词是 &lt;code>uintptr&lt;/code> 类型。
Go 语言中对 &lt;code>uintptr&lt;/code> 是这样描述的：&lt;/p>
&lt;blockquote>
&lt;p>uintptr is an integer type that is large enough to hold the bit pattern of any pointer.&lt;/p>
&lt;/blockquote>
&lt;p>比如在 64-bit Linux 系统上 &lt;code>uintptr&lt;/code> 被定义成为了 &lt;code>uint64&lt;/code>。
Go 中合法的类型转换为：&lt;code>normal pointer&lt;/code> ⟷ &lt;code>unsafe.Pointer&lt;/code> ⟷ &lt;code>uintptr&lt;/code> 。
因此我们可以把上面的程序中的 &lt;code>addrObj&lt;/code> 转换为 &lt;code>uintptr&lt;/code>。
这样 Go 编译器不再认为 &lt;code>addrObj&lt;/code> 同后面函数 &lt;code>causeEscape&lt;/code> 使用的参数 &lt;code>i&lt;/code> 存在引用关系，从而绕过 Escape Analysis Algorithm 。
为了防止垃圾回收过程中 &lt;code>obj&lt;/code> 被回收，可以使用 &lt;code>obj.field1 = 0&lt;/code> 来保持 &lt;code>obj&lt;/code> 活跃。&lt;/p>
&lt;p>修改后的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">field1&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>.(&lt;span style="color:#66d9ef">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">addrObj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">intAddr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> uintptr(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">addrObj&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>((&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">intAddr&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span>.&lt;span style="color:#a6e22e">field1&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>go run -gcflags=&amp;quot;-m -m&amp;quot; escape.go&lt;/code> 运行结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>./escape.go:13: cannot inline causeEscape: unhandled op TYPESW
./escape.go:22: cannot inline main: non-leaf function
./escape.go:13: leaking param: i
./escape.go:13: from ... argument (arg to ...) at ./escape.go:18
./escape.go:13: from *(... argument) (indirection) at ./escape.go:18
./escape.go:13: from ... argument (passed to call[argument content escapes]) at ./escape.go:18
./escape.go:18: causeEscape ... argument does not escape
./escape.go:26: (*BigTempObject)(unsafe.Pointer(intAddr)) escapes to heap
./escape.go:26: from (*BigTempObject)(unsafe.Pointer(intAddr)) (passed to call[argument escapes]) at ./escape.go:26
./escape.go:24: main &amp;amp;obj does not escape
(0x10904e0,0xc42003bf70)
&lt;/code>&lt;/pre>&lt;p>可以看到 &lt;code>obj&lt;/code> 不再逃逸，主要是 &lt;code>intAddr&lt;/code> 中断了逃逸分析算法构建的指针依赖关系（表示为一个有向图）。&lt;/p>
&lt;h2 id="5-一点感想">5. 一点感想&lt;/h2>
&lt;p>我们可以做到不代表一定去做，有风险也不代表禁区，采取什么样的行动是个人权衡后的选择。&lt;br>
什么原因导致了人们做了不同的选择，而人们不同的选择又导致了什么结果？&lt;br>
多样性是这个世界的现状，黑暗面与光明面同在。
May the force be with you.&lt;/p></content></item><item><title>Golang Receiver Type 探索</title><link>https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/</link><pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/</guid><description>1. 参考 在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。
https://golang.google.cn/ref/spec#Method_sets https://golang.google.cn/ref/spec#Types https://golang.google.cn/ref/spec#Struct_types https://golang.google.cn/ref/spec#Composite_literals 核心的概念是 method sets：
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T).</description><content>&lt;h2 id="1-参考">1. 参考&lt;/h2>
&lt;p>在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Method_sets">https://golang.google.cn/ref/spec#Method_sets&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Types">https://golang.google.cn/ref/spec#Types&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Struct_types">https://golang.google.cn/ref/spec#Struct_types&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Composite_literals">https://golang.google.cn/ref/spec#Composite_literals&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>核心的概念是 method sets：&lt;/p>
&lt;blockquote>
&lt;p>A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). Further rules apply to structs containing embedded fields, as described in the section on struct types. Any other type has an empty method set. In a method set, each method must have a unique non-blank method name.&lt;/p>
&lt;p>The method set of a type determines the interfaces that the type implements and the methods that can be called using a receiver of that type.&lt;/p>
&lt;/blockquote>
&lt;p>下面的一些细节基本上都和这段描述相关。&lt;/p>
&lt;h2 id="2-duck-typing-与方法调用">2. Duck typing 与方法调用&lt;/h2>
&lt;p>在很多面向对象的语言中，一个对象都可以“拥有”一些方法，使用例如 &lt;code>obj.f(a, b, c)&lt;/code> 的形式进行调用。结合语言的类型系统，通过“扩展”、“继承”、“实现”等术语，我们可以将不同的类组织起来。在 Go 语言中采用的是 “duck typing”，没有显式的类型关系定义关键字。当一个类型实现了一个接口的全部方法时，那这个类型就被视为实现了这个接口。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Duck&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bark&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">A&lt;/span>) &lt;span style="color:#a6e22e">Bark&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">iA&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">A&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#a6e22e">iA&lt;/span>).(&lt;span style="color:#a6e22e">Duck&lt;/span>); &lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;A{} is Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;A{} is not Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">iB&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">B&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#a6e22e">iB&lt;/span>).(&lt;span style="color:#a6e22e">Duck&lt;/span>); &lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;B{} is Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;B{} is not Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>&amp;amp;A{} is Duck
&amp;amp;B{} is not Duck
&lt;/code>&lt;/pre>&lt;p>我们可以用原始的类型去调用一个方法，也可以使用一个接口去调用方法。这里就涉及到方法调用者的问题：什么样的对象是一个合法的方法调用者？&lt;/p>
&lt;p>至少 &lt;code>A{}&lt;/code> 不是，因为我们实现 &lt;code>Duck&lt;/code> 接口的时候，使用的是 &lt;code>func (*A) Bark()&lt;/code> 进行的定义，而非 &lt;code>func (A) Bark()&lt;/code>。这样就导致了只有 &lt;code>A&lt;/code> 类型对象的指针类型才能作为方法调用者去调用 &lt;code>Bark&lt;/code> 方法。&lt;/p>
&lt;h2 id="3-成员函数的参数">3. 成员函数的参数&lt;/h2>
&lt;p>在实现中，调用某个类型的成员方法，第一个参数其实是这个方法的实现对象自身，即如果是一个指针的方法，就是这个指针的值，如果是一个对象，就是这个对象的值。&lt;/p>
&lt;p>下面使用 Go 1.8.3 展示，因为当前最新的 Go 编译器在打印 stack trace 的时候不再打印函数的参数（这个例子中）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">r&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>0xc420039f70
received 1
panic: just a panic
goroutine 1 [running]:
main.(*R1).f(0xc420039f70, 0x1)
/Users/bef0rewind/Projects/net example/src/main/receiver_type.go:9 +0xa3
main.main()
/Users/bef0rewind/Projects/net example/src/main/receiver_type.go:16 +0x5a
&lt;/code>&lt;/pre>&lt;p>Stack trace 中函数 &lt;code>f&lt;/code> 第一个值是指针 &lt;code>r&lt;/code> 的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span>{&lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">r&lt;/span>).&lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>7
received 1
panic: just a panic
goroutine 1 [running]:
main.R1.g(0x7, 0x9, 0x1)
/Users/bef0rewind/Projects/net example/src/receiver_type/main/args.go:15 +0xa3
main.main()
/Users/bef0rewind/Projects/net example/src/receiver_type/main/args.go:22 +0x58
&lt;/code>&lt;/pre>&lt;p>Stack trace 中函数 &lt;code>g&lt;/code> 第一个值是 &lt;code>r&lt;/code> 的值 &lt;code>7&lt;/code> 和 &lt;code>9&lt;/code>。&lt;/p>
&lt;p>从这个实现方式中我们可以推断以下几点：&lt;/p>
&lt;ul>
&lt;li>Go 语言采用参数传值的方式进行函数调用，因此如果对象很大，使用的对象本身调用函数会带来大量的复制&lt;/li>
&lt;li>不可能在函数调用中改变函数外的调用者，因为传到函数内部的只是调用者的副本&lt;/li>
&lt;/ul>
&lt;h2 id="4-使用接口调用函数">4. 使用接口调用函数&lt;/h2>
&lt;p>基于这样的成员函数实现方式，我们可以尝试另外一种调用方式：使用接口类型调用一个函数。
这里不是将一个对象转换成特定的接口然后去调用函数，而是使用接口类型本身去进行函数调用。
这种方式在 Go 1.9 中开始支持，在 Go 1.10 开始写入 Go 的 specs。这个例子使用的是 Go master 分支的版本，可能是 Go 1.11。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">M&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;I;m M, with&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">IM&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">IM&lt;/span>.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>I;m M, with 7
&lt;/code>&lt;/pre>&lt;p>此外还能使用匿名接口类型去调用函数，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">M&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;I;m M, with&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">interface&lt;/span>{&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)}.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果与上面的一段采用 &lt;code>IM&lt;/code> 接口定义的例子是一样的。&lt;/p>
&lt;h2 id="5-注入依赖">5. 注入依赖&lt;/h2>
&lt;p>有时候一个对象在实例化的时候，它的一些成员方法的行为可能还没有确定，需要依赖外界注入。此时我们可以在对象类型定义中内嵌一个接口，然后在后期传入一个接口的实例来确定其行为。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BinaryOp&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ComputeNode&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">BinaryOp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>) &lt;span style="color:#a6e22e">Result&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span>.&lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">y&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Add&lt;/span>) &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Multi&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Multi&lt;/span>) &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>{&lt;span style="color:#a6e22e">x&lt;/span>:&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Add&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Multi&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>5
6
&lt;/code>&lt;/pre>&lt;p>注意一定要记得传入接口的实例，在这个例子中如果不给 &lt;code>node&lt;/code> 传入一个 &lt;code>BinaryOp&lt;/code> 接口实例，那 &lt;code>node.BinaryOp&lt;/code> 是 &lt;code>nil&lt;/code>，在调用 &lt;code>Compute&lt;/code> 方法的时候就会发生异常。例如将上面的 &lt;code>main&lt;/code> 函数稍作修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>{&lt;span style="color:#a6e22e">x&lt;/span>:&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//node.BinaryOp = &amp;amp;Add{}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x104d8d7]
goroutine 1 [running]:
main.(*ComputeNode).Result(...)
/Users/bef0rewind/Projects/net example/src/receiver_type/main/injection.go:13
main.main()
/Users/bef0rewind/Projects/net example/src/receiver_type/main/injection.go:32 +0x47
&lt;/code>&lt;/pre>&lt;h2 id="6-内部机制">6. 内部机制&lt;/h2>
&lt;p>内部机制有一些细节。大体就是一个接口 &lt;code>i&lt;/code> 包含两部分内容（指针），一个是接口代表的方法的集合，一个实现这个接口的具体对象；而一个对象 &lt;code>obj&lt;/code>，它包含了自己的内存中的值，也能通过其类型获取到 &lt;code>obj&lt;/code> 实现的方法集合。&lt;/p>
&lt;p>将这两个概念记住，在实现一些模式的时候就会少很多心智负担。&lt;/p>
&lt;h2 id="7-总结">7. 总结&lt;/h2>
&lt;p>Go 语言的这套基于 “duck typing” 的机制好不好，争论有很多。不过我一向对这些争论没有特别的倾向，至少理解其机制之后按照其设计思路来用还可以正常使用，而且里面没有复杂的概念和例外情形。&lt;/p>
&lt;p>也许我的理解有偏差，但现在还没有发现什么矛盾的地方。&lt;/p></content></item><item><title>defer, panic and recover in Golang</title><link>https://blog.formalscience.com/2018/08/21/2018-08-21_golang_exception_handling/</link><pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/08/21/2018-08-21_golang_exception_handling/</guid><description>1. 什么是异常处理 程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。 一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 try/catch/finally 机制（https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、 Python 的 try/raise/except/finally 机制（https://docs.python.org/3/tutorial/errors.html）等。
2. Go 语言中的异常处理机制 Go 语言中使用的是 defer/panic/recover 机制来处理异常。Go 语言官方博客的《Defer, Panic, and Recover》讲述了这个机制的具体应用方式。
还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：
The Right Places To Call The recover Function：https://go101.org/article/panic-and-recover-more.html ，几种使用 recover 恢复 Go 语言中 panic 的适用场景 7.异常处理：https://www.kancloud.cn/liupengjie/go/578555 ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节 如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 defer + recover 处理一个 panic，defer 结构要在 panic 触发之前被定义而且 recover 要直接在在 defer 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。
3. defer 语法糖的部分原理 在讲述 defer 机制的文章中，都会提到一个函数中多个 defer 结构执行的顺序和定义顺序是相反的，即后定义的 defer 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：
func g(n int) { println(n) } func h(str string) { println(str) } func f() { defer g(0) defer h(&amp;#34;h&amp;#34;) } 调用 f 输出为：</description><content>&lt;h2 id="1-什么是异常处理">1. 什么是异常处理&lt;/h2>
&lt;p>程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。
一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 &lt;code>try&lt;/code>/&lt;code>catch&lt;/code>/&lt;code>finally&lt;/code> 机制（https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、
Python 的 &lt;code>try&lt;/code>/&lt;code>raise&lt;/code>/&lt;code>except&lt;/code>/&lt;code>finally&lt;/code> 机制（https://docs.python.org/3/tutorial/errors.html）等。&lt;/p>
&lt;h2 id="2-go-语言中的异常处理机制">2. Go 语言中的异常处理机制&lt;/h2>
&lt;p>Go 语言中使用的是 &lt;code>defer&lt;/code>/&lt;code>panic&lt;/code>/&lt;code>recover&lt;/code> 机制来处理异常。Go 语言官方博客的《&lt;a href="https://blog.golang.org/defer-panic-and-recover">Defer, Panic, and Recover&lt;/a>》讲述了这个机制的具体应用方式。&lt;/p>
&lt;p>还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：&lt;/p>
&lt;ul>
&lt;li>The Right Places To Call The recover Function：https://go101.org/article/panic-and-recover-more.html ，几种使用 &lt;code>recover&lt;/code> 恢复 Go 语言中 &lt;code>panic&lt;/code> 的适用场景&lt;/li>
&lt;li>7.异常处理：https://www.kancloud.cn/liupengjie/go/578555 ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节&lt;/li>
&lt;/ul>
&lt;p>如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 &lt;code>defer&lt;/code> + &lt;code>recover&lt;/code> 处理一个 &lt;code>panic&lt;/code>，&lt;code>defer&lt;/code> 结构要在 &lt;code>panic&lt;/code> 触发之前被定义而且 &lt;code>recover&lt;/code> 要直接在在 &lt;code>defer&lt;/code> 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。&lt;/p>
&lt;h2 id="3-defer-语法糖的部分原理">3. &lt;code>defer&lt;/code> 语法糖的部分原理&lt;/h2>
&lt;p>在讲述 &lt;code>defer&lt;/code> 机制的文章中，都会提到一个函数中多个 &lt;code>defer&lt;/code> 结构执行的顺序和定义顺序是相反的，即后定义的 &lt;code>defer&lt;/code> 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(&lt;span style="color:#a6e22e">str&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">str&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;h&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用 &lt;code>f&lt;/code> 输出为：&lt;/p>
&lt;pre tabindex="0">&lt;code>h
0
&lt;/code>&lt;/pre>&lt;p>常见的函数调用流程为：&lt;/p>
&lt;ul>
&lt;li>将函数使用的参数压入栈&lt;/li>
&lt;li>执行函数指令&lt;/li>
&lt;li>函数执行结束返回到调用点&lt;/li>
&lt;/ul>
&lt;p>如果 &lt;code>defer&lt;/code> 相关的代码也是这么执行的话，那么为什么不是： &lt;code>0&lt;/code> 入栈 - 执行 &lt;code>g&lt;/code> - &lt;code>g&lt;/code> 返回 - &lt;code>&amp;quot;h&amp;quot;&lt;/code> 入栈 - 执行 &lt;code>h&lt;/code> - &lt;code>h&lt;/code> 返回 这个顺序呢？
按照这个顺序执行，调用 &lt;code>f&lt;/code> 输出应该是 &lt;code>0&lt;/code> 在 &lt;code>h&lt;/code> 前面符合预期。是不是 Go 语言中执行 &lt;code>defer&lt;/code> 时采用了特殊的处理流程？&lt;/p>
&lt;p>是，也不是。&lt;/p>
&lt;p>太阳底下无新鲜事，&lt;code>defer&lt;/code> 不过是一个语法糖，用来对一个函数 &lt;code>deferproc&lt;/code> 进行包装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Create a new deferred function fn with siz bytes of arguments.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// The compiler turns a defer statement into a call to this.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:nosplit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">deferproc&lt;/span>(&lt;span style="color:#a6e22e">siz&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>, &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">funcval&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>deferproc&lt;/code> 创建一个延迟调用的函数，其参数为 &lt;code>siz&lt;/code> （延迟调用的函数的参数占用的字节数量）和 &lt;code>fn&lt;/code>（被延迟调用的函数本身）。
当 Go 程序的编译器遇到 &lt;code>defer f()&lt;/code>，会将这条语句翻译为一条 &lt;code>deferproc&lt;/code> 和一条 &lt;code>deferreturn&lt;/code> 。
其中 &lt;code>deferproc&lt;/code> 把被调用的函数及其参数挂载在 goroutine （Go 中的并发单元，协程）结构的一个链表上；
&lt;code>deferreturn&lt;/code> 从链表上取下一个挂载的被延迟执行的函数，执行它。&lt;/p>
&lt;p>如何使用技巧绕过 &lt;code>defer&lt;/code> 关键字，模拟类似效果？
可以使用 &lt;code>linkname&lt;/code> 方法来把 Go 语言运行时的一些关键函数导出，从而进行某些不常见的操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#e6db74">&amp;#34;runtime&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Eface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">EfaceOf&lt;/span>(&lt;span style="color:#a6e22e">ep&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Eface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Eface&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">ep&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Funcval&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// variable-size, fn-specific data here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:linkname Deferproc runtime.deferproc
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Deferproc&lt;/span>(&lt;span style="color:#a6e22e">siz&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>, &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Funcval&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:linkname Deferreturn runtime.deferreturn
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Deferreturn&lt;/span>(&lt;span style="color:#a6e22e">arg0&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;hacked defer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fI&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#a6e22e">f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Attach a defer struct to the current goroutine struct
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Deferproc&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Funcval&lt;/span>)(&lt;span style="color:#a6e22e">EfaceOf&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">fI&lt;/span>).&lt;span style="color:#a6e22e">Data&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;original defer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Run a deferred function if there is one
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Deferreturn&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码会输出：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-output" data-lang="output">original defer
hacked defer
&lt;/code>&lt;/pre>&lt;p>当然，如果是使用 &lt;code>defer&lt;/code> 关键字，Go 语言的编译器会选择合适的位置插入 &lt;code>deferreturn&lt;/code> 语句，而不是像上述代码中一样手动放在结束位置处。&lt;/p>
&lt;h2 id="4-recover-生效位置的设计原因推测">4. &lt;code>recover&lt;/code> 生效位置的设计原因推测&lt;/h2>
&lt;p>言归正传，&lt;code>panic&lt;/code> 发生后，会根据函数调用顺序逐层上报，直到最后一层被抛出到系统导致崩溃或者被 &lt;code>recover&lt;/code> 机制处理。
那么如果被 &lt;code>recover&lt;/code> 处理，这个过程是怎么生效的？&lt;/p>
&lt;p>很多教程中都提到 &lt;code>recover&lt;/code> 一定要在 &lt;code>defer&lt;/code> 声明的函数里面（既不是这个函数本身也不能是函数里面的其他函数里面）才能正确处理当前的 &lt;code>panic&lt;/code> 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 1, not work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 2, not work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 3, work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么呢？&lt;/p>
&lt;p>先不考虑实现，先从理念上分析一下。&lt;/p>
&lt;ol>
&lt;li>&lt;code>defer&lt;/code> 直接作用于 &lt;code>recover()&lt;/code>：无法根据 &lt;code>recover()&lt;/code> 的返回值来进行不同类型的 &lt;code>panic&lt;/code> 处理&lt;/li>
&lt;li>在被 &lt;code>defer&lt;/code> 作用的函数内部的函数 &lt;code>g&lt;/code> 中使用 &lt;code>recover()&lt;/code>：如果 &lt;code>g&lt;/code> 是一个第三方库的函数，无法保证其中没有未知的 &lt;code>recover&lt;/code> 意外处理了系统中的 &lt;code>panic&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>因此事实上也只能通过这样的约束来使这个异常处理机制看上去直观易处理一些。当然通过对 Go 编译器进行修改，还是有办法使得上面三种情况下 &lt;code>recover&lt;/code> 都可以中断 &lt;code>panic&lt;/code> 向上层传递过程的。&lt;/p>
&lt;p>此外，由于被 &lt;code>defer&lt;/code> 处理的函数被挂载在 goroutine 结构的一个链表上，因此当 &lt;code>panic&lt;/code> 发生时，可以直接从这个链表上取下被延迟执行的函数一个个执行。
这也是 &lt;code>recover&lt;/code> 要放在 &lt;code>deferred function&lt;/code> 中的原因，因为这些函数是肯定可以执行到的。&lt;/p>
&lt;h2 id="5-总结">5. 总结&lt;/h2>
&lt;p>不能说 Go 中这个异常处理机制有多高明，基本上属于现代语言标配。了解更多背后的原理，在使用时可以更坚定一些。&lt;/p>
&lt;p>此外，最近看到一本书《最好的告别》（https://book.douban.com/subject/26576861/）。&lt;/p>
&lt;p>&lt;img src="https://images-na.ssl-images-amazon.com/images/I/41rwxKTGwXL._SX308_BO1,204,203,200_.jpg" alt="Being Mortal">&lt;/p>
&lt;p>豆瓣上的介绍：&lt;/p>
&lt;blockquote>
&lt;p>当独立、自助的生活不能再维持时，我们该怎么办？在生命临近终点的时刻，我们该和医生谈些什么？应该如何优雅地跨越生命的终点？对于这些问题，大多数人缺少清晰的观念，而只是把命运交由医学、技术和陌生人来掌控。影响世界的医生阿图•葛文德结合其多年的外科医生经验与流畅的文笔，讲述了一个个伤感而发人深省的故事，对在21世纪变老意味着什么进行了清醒、深入的探索。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>defer&lt;/code> / &lt;code>finally&lt;/code> 这些关键字让我们可以控制函数退出时的行为，但是我们自身呢？也许考虑这些问题可以让我们自身活得有意义一些。&lt;/p>
&lt;p>推荐大家看一下。&lt;/p></content></item><item><title>Golang 系统调用/Syscall</title><link>https://blog.formalscience.com/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</link><pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</guid><description>概述 很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：
func Read(fd int, p []byte) (n int, err error) func Write(fd int, p []byte) (n int, err error) 同时，Golang 也提供了对 Syscall 的直接调用支持：
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) RawSyscall 和 RawSyscall6 是对操作系统 Syscall 的直接调用；Syscall 和 Syscall6 会在调用操作系统 Syscall 前调用 runtime·entersyscall ，在操作系统 Syscall 返回后调用 runtime·exitsyscall 。</description><content>&lt;h1 id="概述">概述&lt;/h1>
&lt;p>很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Read&lt;/span>(&lt;span style="color:#a6e22e">fd&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#a6e22e">fd&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时，Golang 也提供了对 Syscall 的直接调用支持：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Syscall&lt;/span>(&lt;span style="color:#a6e22e">trap&lt;/span>, &lt;span style="color:#a6e22e">a1&lt;/span>, &lt;span style="color:#a6e22e">a2&lt;/span>, &lt;span style="color:#a6e22e">a3&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) (&lt;span style="color:#a6e22e">r1&lt;/span>, &lt;span style="color:#a6e22e">r2&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#a6e22e">Errno&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Syscall6&lt;/span>(&lt;span style="color:#a6e22e">trap&lt;/span>, &lt;span style="color:#a6e22e">a1&lt;/span>, &lt;span style="color:#a6e22e">a2&lt;/span>, &lt;span style="color:#a6e22e">a3&lt;/span>, &lt;span style="color:#a6e22e">a4&lt;/span>, &lt;span style="color:#a6e22e">a5&lt;/span>, &lt;span style="color:#a6e22e">a6&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) (&lt;span style="color:#a6e22e">r1&lt;/span>, &lt;span style="color:#a6e22e">r2&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#a6e22e">Errno&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">RawSyscall&lt;/span>(&lt;span style="color:#a6e22e">trap&lt;/span>, &lt;span style="color:#a6e22e">a1&lt;/span>, &lt;span style="color:#a6e22e">a2&lt;/span>, &lt;span style="color:#a6e22e">a3&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) (&lt;span style="color:#a6e22e">r1&lt;/span>, &lt;span style="color:#a6e22e">r2&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#a6e22e">Errno&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">RawSyscall6&lt;/span>(&lt;span style="color:#a6e22e">trap&lt;/span>, &lt;span style="color:#a6e22e">a1&lt;/span>, &lt;span style="color:#a6e22e">a2&lt;/span>, &lt;span style="color:#a6e22e">a3&lt;/span>, &lt;span style="color:#a6e22e">a4&lt;/span>, &lt;span style="color:#a6e22e">a5&lt;/span>, &lt;span style="color:#a6e22e">a6&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) (&lt;span style="color:#a6e22e">r1&lt;/span>, &lt;span style="color:#a6e22e">r2&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#a6e22e">Errno&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>RawSyscall&lt;/code> 和 &lt;code>RawSyscall6&lt;/code> 是对操作系统 Syscall 的直接调用；&lt;code>Syscall&lt;/code> 和 &lt;code>Syscall6&lt;/code> 会在调用操作系统 Syscall 前调用 &lt;code>runtime·entersyscall&lt;/code> ，在操作系统 Syscall 返回后调用 &lt;code>runtime·exitsyscall&lt;/code> 。&lt;/p>
&lt;p>这四个函数都是使用汇编语言实现，代码和具体的硬件体系结构和操作系统有关。&lt;code>RawSyscall&lt;/code> 和 &lt;code>RawSyscall6&lt;/code> 的行为和 C 语言中系统调用很类似，在这里不展开描述。而 &lt;code>Syscall&lt;/code> 和 &lt;code>Syscall6&lt;/code> 的行为（在进行真正的系统调用前后插入额外操作）与 Golang 的调度器关系紧密，在下面会进行要点描述。&lt;/p>
&lt;p>&lt;code>Syscall&lt;/code> 的关键在于 &lt;code>runtime·entersyscall&lt;/code> 和 &lt;code>runtime·exitsyscall&lt;/code> ，而 &lt;code>runtime·entersyscall&lt;/code> 还有一个行为有部分差异的版本 &lt;code>runtime·entersyscallblock&lt;/code> 。&lt;/p>
&lt;h1 id="runtimeentersyscall">&lt;code>runtime·entersyscall&lt;/code>&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">entersyscall&lt;/span>(&lt;span style="color:#a6e22e">dummy&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">reentersyscall&lt;/span>(&lt;span style="color:#a6e22e">getcallerpc&lt;/span>(), &lt;span style="color:#a6e22e">getcallersp&lt;/span>(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">dummy&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">reentersyscall&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">getg&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Disable preemption because during this function g is in Gsyscall status,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// but can have inconsistent g-&amp;gt;sched, do not let GC observe it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">locks&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Entersyscall must not call any function that might split/grow the stack.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// (See details in comment above.)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Catch calls that might, by replacing the stack guard with something that
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// will trip any stack check and leaving a flag to tell newstack to die.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stackguard0&lt;/span> = &lt;span style="color:#a6e22e">stackPreempt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">throwsplit&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Leave SP around for GC and traceback.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallsp&lt;/span> = &lt;span style="color:#a6e22e">sp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallpc&lt;/span> = &lt;span style="color:#a6e22e">pc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">casgstatus&lt;/span>(&lt;span style="color:#a6e22e">_g_&lt;/span>, &lt;span style="color:#a6e22e">_Grunning&lt;/span>, &lt;span style="color:#a6e22e">_Gsyscall&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallsp&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stack&lt;/span>.&lt;span style="color:#a6e22e">lo&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stack&lt;/span>.&lt;span style="color:#a6e22e">hi&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallsp&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;entersyscall inconsistent &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">hex&lt;/span>(&lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallsp&lt;/span>), &lt;span style="color:#e6db74">&amp;#34; [&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">hex&lt;/span>(&lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stack&lt;/span>.&lt;span style="color:#a6e22e">lo&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">hex&lt;/span>(&lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stack&lt;/span>.&lt;span style="color:#a6e22e">hi&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;]\n&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">throw&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;entersyscall&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">trace&lt;/span>.&lt;span style="color:#a6e22e">enabled&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#a6e22e">traceGoSysCall&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// systemstack itself clobbers g.sched.{pc,sp} and we might
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// need them later when the G is genuinely blocked in a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// syscall
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">atomic&lt;/span>.&lt;span style="color:#a6e22e">Load&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sched&lt;/span>.&lt;span style="color:#a6e22e">sysmonwait&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#a6e22e">entersyscall_sysmon&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>().&lt;span style="color:#a6e22e">runSafePointFn&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// runSafePointFn may stack split if run on this stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#a6e22e">runSafePointFn&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">syscalltick&lt;/span> = &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>().&lt;span style="color:#a6e22e">syscalltick&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">sysblocktraced&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">mcache&lt;/span> = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>().&lt;span style="color:#a6e22e">m&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">atomic&lt;/span>.&lt;span style="color:#a6e22e">Store&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>().&lt;span style="color:#a6e22e">status&lt;/span>, &lt;span style="color:#a6e22e">_Psyscall&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">sched&lt;/span>.&lt;span style="color:#a6e22e">gcwaiting&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#a6e22e">entersyscall_gcwait&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Goroutines must not split stacks in Gsyscall status (it would corrupt g-&amp;gt;sched).
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// We set _StackGuard to StackPreempt so that first split stack check calls morestack.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Morestack detects this case and throws.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stackguard0&lt;/span> = &lt;span style="color:#a6e22e">stackPreempt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">locks&lt;/span>&lt;span style="color:#f92672">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>runtime·entersyscall&lt;/code> 主要完成以下几件事：&lt;/p>
&lt;ol>
&lt;li>声明函数为 &lt;code>NOSPLIT&lt;/code> ，不触发栈扩展检查&lt;/li>
&lt;li>禁止抢占&lt;/li>
&lt;li>通过 &lt;code>dummy&lt;/code> 参数获得调用者的 &lt;code>SP&lt;/code> 和 &lt;code>PC&lt;/code> 的值，并保存到 goroutine 的 &lt;code>syscallsp&lt;/code> 和 &lt;code>syscallpc&lt;/code> 字段。同时记录 &lt;code>syscallstack&lt;/code> 和 &lt;code>syscallguard&lt;/code> ，使得垃圾回收器只对系统调用前的栈进行 &lt;strong>mark-sweep&lt;/strong> （cgo 机制也利用了 &lt;code>entersyscall&lt;/code> 来使得 cgo 中运行的代码不受垃圾回收机制管理）。&lt;/li>
&lt;li>将 goroutine 的状态切换到 Gsyscall 状态。&lt;/li>
&lt;li>唤醒后台线程 &lt;code>sysmon&lt;/code> （这个线程会监控执行 &lt;code>syscall&lt;/code> 的线程，如果超过某个时间阈值，就会将 M 与对应的 P 解除绑定）。&lt;/li>
&lt;li>置空 M 的 &lt;code>mcache&lt;/code> 、将 P 的 &lt;code>m&lt;/code> 字段，切换 P 的状态到 &lt;code>Psyscall&lt;/code>&lt;/li>
&lt;li>检查是否需要垃圾回收&lt;/li>
&lt;li>通过 &lt;code>g-&amp;gt;stackguard0 = StackPreempt&lt;/code> 使得出现 &lt;em>split stack&lt;/em> 时可以通过 &lt;code>morestack&lt;/code> 捕获并抛出错误&lt;/li>
&lt;li>恢复抢占&lt;/li>
&lt;/ol>
&lt;p>可以看到 &lt;code>reentersyscall&lt;/code> 多次调用 &lt;code>save&lt;/code> 保存 &lt;code>pc&lt;/code> 和 &lt;code>sp&lt;/code>。&lt;code>save&lt;/code> 更新 &lt;code>getg().sched&lt;/code> 中的 &lt;code>sp&lt;/code> 和 &lt;code>pc&lt;/code> ，使得调用 &lt;code>gogo&lt;/code> 的时候可以恢复 &lt;code>pc&lt;/code> 和 &lt;code>sp&lt;/code> 。&lt;code>reentersyscall&lt;/code> 中 &lt;code>save&lt;/code> 的目的都是为 goroutine 跳回这个 &lt;code>syscall&lt;/code> 调用者执行 &lt;code>syscall&lt;/code> 时刻的 &lt;code>pc&lt;/code> 和 &lt;code>sp&lt;/code>做准备。&lt;/p>
&lt;p>需要继续深入：&lt;/p>
&lt;ol>
&lt;li>&lt;code>StackPreempt&lt;/code>&lt;/li>
&lt;li>&lt;code>syscallstack&lt;/code> 和 &lt;code>syscallguard&lt;/code> 的具体作用时机&lt;/li>
&lt;/ol>
&lt;h1 id="runtimeentersyscallblock">&lt;code>runtime·entersyscallblock&lt;/code>&lt;/h1>
&lt;p>与 &lt;code>runtime·entersyscall&lt;/code> 区别在于这个函数认为当前执行的 &lt;code>syscall&lt;/code> 会运行较长时间，因此在函数中主动进行了 M 和 P 的解除绑定，无需等待 &lt;code>sysmon&lt;/code> 处理。解除 M 和 P 绑定的逻辑由 &lt;code>entersyscallblock_handoff&lt;/code> 实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">entersyscallblock_handoff&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">trace&lt;/span>.&lt;span style="color:#a6e22e">enabled&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">traceGoSysCall&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">traceGoSysBlock&lt;/span>(&lt;span style="color:#a6e22e">getg&lt;/span>().&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handoffp&lt;/span>(&lt;span style="color:#a6e22e">releasep&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="runtimeexitsyscall">&lt;code>runtime·exitsyscall&lt;/code>&lt;/h1>
&lt;p>主要实现了从 &lt;code>syscall&lt;/code> 状态中恢复的动作：&lt;/p>
&lt;ol>
&lt;li>尝试调用 &lt;code>exitsyscallfast&lt;/code> ，如果 M 与 P 没有完全解除绑定，那么该操作会将 M 和 P 重新绑定；否则获取一个空闲的 P 与当前 M 绑定。如果绑定成功，返回 &lt;code>True&lt;/code>，否则返回 &lt;code>False&lt;/code> 进行后续步骤处理。&lt;/li>
&lt;li>如果 &lt;code>exitsyscallfast&lt;/code> 返回 &lt;code>True&lt;/code> ，函数就直接返回；返回 &lt;code>False&lt;/code>，则进入 &lt;em>slow path&lt;/em> 将当前 goroutine 放到任务队列中等待调度，具体实现由 &lt;code>mcall(exitsyscall0)&lt;/code> 实现。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>exitsyscall0&lt;/code> 这个函数比较清晰，只是对其中 &lt;code>dropg()&lt;/code> 的目的还没想清楚。&lt;/p>
&lt;p>&lt;code>runtime·exitsyscall&lt;/code> 的函数说明中提到的 &lt;code>// Write barriers are not allowed because our P may have been stolen.&lt;/code> 也没有搞清楚，知道和 GC 有一定关系。&lt;/p>
&lt;h1 id="引用">引用&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://studygolang.com/articles/7005">https://studygolang.com/articles/7005&lt;/a>&lt;/li>
&lt;/ol></content></item><item><title>Golang 中学到的新东西</title><link>https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</link><pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</guid><description>数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&amp;amp;s[0]) var ptr unsafe.Pointer s := ((*[1&amp;lt;&amp;lt;10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(&amp;amp;s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;amp;o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) map 实现 整个页面的内容对我来说都是新的：https://tiancaiamao.</description><content>&lt;h1 id="数据类型">数据类型&lt;/h1>
&lt;h2 id="string-类型">&lt;code>string&lt;/code> 类型&lt;/h2>
&lt;p>&lt;code>string&lt;/code> 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。&lt;/p>
&lt;h2 id="slice-leftrightarrow-unsafepointer">&lt;code>slice&lt;/code> $\leftrightarrow$ &lt;code>unsafe.Pointer&lt;/code>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#ae81ff">200&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> ((&lt;span style="color:#f92672">*&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>]&lt;span style="color:#66d9ef">byte&lt;/span>)(&lt;span style="color:#a6e22e">ptr&lt;/span>))[:&lt;span style="color:#ae81ff">200&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">s1&lt;/span> = &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">len&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cap&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{&lt;span style="color:#a6e22e">ptr&lt;/span>, &lt;span style="color:#a6e22e">length&lt;/span>, &lt;span style="color:#a6e22e">length&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>[]&lt;span style="color:#66d9ef">byte&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">s1&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">o&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sliceHeader&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">SliceHeader&lt;/span>)((&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">o&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sliceHeader&lt;/span>.&lt;span style="color:#a6e22e">Cap&lt;/span> = &lt;span style="color:#a6e22e">length&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sliceHeader&lt;/span>.&lt;span style="color:#a6e22e">Len&lt;/span> = &lt;span style="color:#a6e22e">length&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sliceHeader&lt;/span>.&lt;span style="color:#a6e22e">Data&lt;/span> = uintptr(&lt;span style="color:#a6e22e">ptr&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="map-实现">&lt;code>map&lt;/code> 实现&lt;/h1>
&lt;p>整个页面的内容对我来说都是新的：https://tiancaiamao.gitbooks.io/go-internals/content/zh/02.3.html
不过这个页面描述的内容和最新的 Golang source 有一定差别。&lt;/p>
&lt;p>读 &lt;code>HashMap&lt;/code> 的实现，里面的一些核心关键词：&lt;code>bucket&lt;/code>、&lt;code>overflow&lt;/code> 让我理解起来有些困难。查询 &lt;code>HashMap&lt;/code> 相关的一些资料后有了进一步了解。&lt;/p>
&lt;ol>
&lt;li>&lt;code>bucket&lt;/code> 一般使用某种 &lt;code>array&lt;/code> 管理，从 &lt;code>key&lt;/code> 经过 &lt;code>hash-function&lt;/code> 映射的 &lt;code>hash-value&lt;/code>（可能截取一部分，也可以视作 sub-hash，我自己编的）作为 &lt;code>index&lt;/code> 直接得到。一个 &lt;code>bucket&lt;/code> 中可能包含多个不同的 &lt;code>hash-value&lt;/code> ，它们截取那一部分得到的 &lt;code>index&lt;/code> 相同。因此 &lt;code>bucket&lt;/code> 会用一个数据结构管理这些冲突的值，可能是 &lt;code>linked-list&lt;/code> 或者 &lt;code>tree-map&lt;/code> 之类的。这些内部的数据结构中的 &lt;code>node&lt;/code> 存储着真正对应 &lt;code>map&lt;/code> 的 &lt;code>key\value&lt;/code> 对(pair)。&lt;/li>
&lt;li>如果 &lt;code>bucket&lt;/code> 太满了，比如元素的数量超过 &lt;code>bucket&lt;/code> 数量一定倍数（&lt;code>load factor&lt;/code>），则会进行扩容，所有元素都被 &lt;code>rehashed&lt;/code> 到一个新的值。&lt;/li>
&lt;li>采用这种方式实现 &lt;code>HashMap&lt;/code>，&lt;code>bucket&lt;/code> 可以有两种选择：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>Direct chaining&lt;/strong> 只存一个指向冲突元素集合的 &lt;code>header&lt;/code>&lt;/li>
&lt;li>&lt;strong>Seperate Chaining&lt;/strong> 在 &lt;code>bucket&lt;/code> 存一部分（一个）元素集合（Golang &lt;code>HashMap&lt;/code> 实现里放了 8 个），和一个指向剩下冲突元素集合的 &lt;code>header&lt;/code>&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>上面 &lt;code>header&lt;/code> 指向的元素集合叫 &lt;code>overflow list&lt;/code> 或者 &lt;code>overflow some-other-data-structure&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>有了这些背景后，看代码应该会比较清晰了。&lt;/p>
&lt;p>目前 Golang 中的 &lt;code>bucket&lt;/code> 是为 &lt;code>insert&lt;/code> 操作优化的，找到第一个空余位置就可以插入，但是删除的时候要把所有相同 &lt;code>key&lt;/code> 的元素都删掉，要遍历 &lt;code>bucket&lt;/code> 的 &lt;code>overflow&lt;/code> 集合。&lt;/p>
&lt;p>如果 key 或者 value 小于 128 字节，那么它们是直接在 &lt;code>bucket&lt;/code> 存储值，否则存指向数据的指针。&lt;/p>
&lt;h1 id="nil-语义">&lt;code>nil&lt;/code> 语义&lt;/h1>
&lt;p>按照 Golang 规范，任何类型在未初始化时都对应一个零值：&lt;/p>
&lt;ul>
&lt;li>&lt;code>bool&lt;/code> $\rightarrow$ &lt;code>true&lt;/code>&lt;/li>
&lt;li>&lt;code>integer&lt;/code> $\rightarrow$ &lt;code>0&lt;/code>&lt;/li>
&lt;li>&lt;code>string&lt;/code> $\rightarrow$ &lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/li>
&lt;li>&lt;code>pointer&lt;/code>/&lt;code>function&lt;/code>/&lt;code>interface&lt;/code>/&lt;code>slice&lt;/code>/&lt;code>channel&lt;/code>/&lt;code>map&lt;/code> $\rightarrow$ &lt;code>nil&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="关于-interface">关于 &lt;code>interface{}&lt;/code>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#75715e">// v == nil
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} &lt;span style="color:#75715e">// i == nil
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#75715e">// i != nil
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="关于-channel">关于 &lt;code>channel&lt;/code>&lt;/h2>
&lt;p>一些操作规则：&lt;/p>
&lt;ul>
&lt;li>读写一个 &lt;code>nil&lt;/code> 的 &lt;code>channel&lt;/code> 会立即阻塞&lt;/li>
&lt;li>读一个关闭的 &lt;code>channel&lt;/code> 会立刻返回一个 &lt;code>channel&lt;/code> 元素类型的零值，即 &lt;code>chan int&lt;/code> 会返回 &lt;code>0&lt;/code>&lt;/li>
&lt;li>写一个关闭的 &lt;code>channel&lt;/code> 会导致 &lt;code>panic&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="函数调用">函数调用&lt;/h1>
&lt;h2 id="汇编">汇编&lt;/h2>
&lt;p>可以看一下这个 Golang 的官方介绍页面：https://golang.org/doc/asm&lt;/p>
&lt;p>&lt;strong>add.go&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>) &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>add_amd64.s&lt;/strong> 或使用其他平台后缀，和 &lt;strong>add.go&lt;/strong> 在同一个目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">TEXT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">·&lt;/span>Add&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(SB),&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(FP),BX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> b&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>(FP),BP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ADDQ&lt;/span> BP,BX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BX,res&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">RET&lt;/span> ,
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="golang-调用-c">Golang 调用 C&lt;/h2>
&lt;p>&lt;strong>add.c&lt;/strong> ，和 &lt;strong>add.go&lt;/strong> 在同一个目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">·&lt;/span>Add(uint64 a, uint64 b, uint64 ret) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FLUSH(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ret);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译这个包：&lt;code>go install add&lt;/code>&lt;/p>
&lt;p>C 文件中需要包含 &lt;code>runtime.h&lt;/code> 头文件。因为 Golang 使用特殊寄存器存放像全局 &lt;code>struct G&lt;/code> 和 &lt;code>struct M&lt;/code> ，包含这个文件可以让所有链接到 Go 的 C 文件感知这一点，避免编译器使用这些特定的寄存器做其他用途。&lt;/p>
&lt;p>上面示例中返回值为空，使用 &lt;code>ret&lt;/code> 作为返回值，&lt;code>FLUSH&lt;/code> 在 &lt;code>pkg/runtime/runtime.h&lt;/code> 中定义为 &lt;code>USED()&lt;/code> ，防止编译器优化掉对某个变量的赋值操作（因为看不到这个变量在后面其他地方使用了）。&lt;/p>
&lt;h2 id="函数调用时的内存布局">函数调用时的内存布局&lt;/h2>
&lt;p>Golang 中使用的 C 编译器是 plan9 的 C 编译器，与 gcc 有一定差异。
这个页面中有部分基础介绍：
&lt;a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.1.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.1.html&lt;/a>&lt;/p>
&lt;p>如果返回多个值，&lt;code>func f(a, b int) (d, e int)&lt;/code> 内存布局如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>slot for e
slot for d
b
a
&amp;lt;- SP
&lt;/code>&lt;/pre>&lt;p>调用后为&lt;/p>
&lt;pre tabindex="0">&lt;code>slot for e
slot for d
b
a &amp;lt;- FP
PC &amp;lt;- SP
f&amp;#39;s stack
&lt;/code>&lt;/pre>&lt;p>plan9 的 C 汇编器对被调用函数的参数值的修改是会返回到调用函数中的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BX,d&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BX,e&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="go-关键字">&lt;code>go&lt;/code> 关键字&lt;/h1>
&lt;p>&lt;code>f(1, 2, 3)&lt;/code> 的汇编:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> f(SB)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>go f(1, 2, 3)&lt;/code> 的汇编：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PUSHQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>f(SB)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PUSHQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> runtime.newproc(SB)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">POPQ&lt;/span> AX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">POPQ&lt;/span> AX
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>12&lt;/code> 是参数占用的大小，&lt;code>runtime.newproc&lt;/code> 函数接受的参数为：参数大小、新的 goroutine 要运行的函数、函数的参数。&lt;code>runtime.newproc&lt;/code> 会新建一个栈空间，将栈参数的 12 个字节复制到新的栈空间，并让栈指针指向参数。可以看做 &lt;code>runtime.newproc(size, f, args)&lt;/code> 。&lt;/p>
&lt;h1 id="defer-关键字">&lt;code>defer&lt;/code> 关键字&lt;/h1>
&lt;p>&lt;code>return x&lt;/code> 不是原子语句，函数执行顺序为：&lt;/p>
&lt;ol>
&lt;li>给返回值赋值&lt;/li>
&lt;li>&lt;code>defer&lt;/code> 调用&lt;/li>
&lt;li>&lt;code>return&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>&lt;code>defer&lt;/code> 实现对应 &lt;code>runtime.deferproc&lt;/code>，其出现的地方插入指令 &lt;code>call runtime.deferproc&lt;/code> ，函数返回之前的地方，插入 &lt;code>call runtime.deferreturn&lt;/code> 。 goroutine 的控制结构中有一张表记录 &lt;code>defer&lt;/code>，表以栈行为运作。&lt;/p>
&lt;h1 id="continuous-stack">Continuous Stack&lt;/h1>
&lt;p>我也基本理解了思路，具体细节可以看：https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html&lt;/p>
&lt;p>最后的 &lt;code>runtime.lessstack&lt;/code> 有些没看懂。&lt;/p>
&lt;h1 id="闭包">闭包&lt;/h1>
&lt;p>闭包中引用的变量不能在栈上分配，否则闭包函数返回的时候，栈上变量的地址就失效了。&lt;/p>
&lt;h2 id="逃逸分析escape-analyze">逃逸分析（escape analyze）&lt;/h2>
&lt;p>Golang 有个特性，可以自动识别哪些变量在栈上分配，哪些在堆上分配。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Cursor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">Cursor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">X&lt;/span> = &lt;span style="color:#ae81ff">500&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">noinline&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>type.&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.Cursor&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(SB),(SP) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">取变量&lt;/span>c的类型&lt;span style="color:#960050;background-color:#1e0010">，也就是&lt;/span>Cursor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> ,runtime.new(SB) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">调用&lt;/span>new函数&lt;span style="color:#960050;background-color:#1e0010">，相当于&lt;/span>new(Cursor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>(SP),AX &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">取&lt;/span>c.X的地址放到AX寄存器
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">500&lt;/span>,(AX) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">将&lt;/span>AX&lt;span style="color:#960050;background-color:#1e0010">存放的内存地址的值赋为&lt;/span>&lt;span style="color:#ae81ff">500&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> AX,&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.~r0&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ADDQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>,SP
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在编译的过程中可以通过指令输出哪些变量逃逸了：&lt;code>go build --gcflags=-m main.go&lt;/code>&lt;/p>
&lt;h2 id="闭包结构体">闭包结构体&lt;/h2>
&lt;p>闭包将函数和它引用的环境表示为一个结构体：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Closure&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">F&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>()()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>整体思路是返回闭包的时候，返回一个结构体，包含闭包返回函数的地址和引用的环境中的变量地址。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">func&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>type.int&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(SB),(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> ,runtime.new(SB) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">是不是很熟悉，这一段就是&lt;/span>i &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span> new(int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>type.struct &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span> F uintptr&lt;span style="color:#75715e">; A0 *int }+0(SB),(SP) // 这个结构体就是闭包的类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> ,runtime.new(SB) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">接下来相当于&lt;/span> new(Closure)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>(SP),AX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">NOP&lt;/span> ,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.func&lt;span style="color:#960050;background-color:#1e0010">·&lt;/span>&lt;span style="color:#ae81ff">001&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(SB),BP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BP,(AX) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">函数地址赋值给&lt;/span>Closure的F部分
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">NOP&lt;/span> ,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.&lt;span style="color:#f92672">&amp;amp;&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>(SP),BP &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">将堆中&lt;/span>new的变量i的地址赋值给Closure的值部分
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BP,&lt;span style="color:#ae81ff">8&lt;/span>(AX)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> AX,&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.~r1&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ADDQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>,SP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">RET&lt;/span> ,
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="引用">引用&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://tiancaiamao.gitbooks.io/go-internals">https://tiancaiamao.gitbooks.io/go-internals&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/07_Hashing_Chaining.pdf">http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/07_Hashing_Chaining.pdf&lt;/a>&lt;/li>
&lt;/ol></content></item></channel></rss>