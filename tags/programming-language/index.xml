<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming language on 不是追风少年</title><link>https://blog.formalscience.com/tags/programming-language/</link><description>Recent content in programming language on 不是追风少年</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 30 Nov 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.formalscience.com/tags/programming-language/index.xml" rel="self" type="application/rss+xml"/><item><title>Escape from escape analysis</title><link>https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/</guid><description>1. 逃逸分析背景 Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。 特点是全局停顿时间比较少，在一些场景下是十微秒级别的。
垃圾回收算法针对的是堆（heap）中的内存。 为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。 这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。
而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。 如这篇文章《Golang escape analysis》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。
对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。 这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。
2. Go 版本 使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。
ThinkPad-X1-Carbon:bin bef0rewind$ ./go version go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64 3. 示例 // file: escape.go package main import &amp;#34;fmt&amp;#34; type BigTempObject struct { /// ... field1 int } func causeEscape(i interface{}) { switch i.</description></item><item><title>Golang Receiver Type 探索</title><link>https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/</link><pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/</guid><description>1. 参考 在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。
https://golang.google.cn/ref/spec#Method_sets https://golang.google.cn/ref/spec#Types https://golang.google.cn/ref/spec#Struct_types https://golang.google.cn/ref/spec#Composite_literals 核心的概念是 method sets：
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T).</description></item></channel></rss>