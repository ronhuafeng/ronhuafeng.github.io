<!doctype html><html lang=en><head><title>programming language :: 不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/tags/programming-language/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="programming language"><meta property="og:description" content><meta property="og:url" content="https://blog.formalscience.com/tags/programming-language/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/tags/programming-language/index.xml rel=alternate type=application/rss+xml title=不是追风少年></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/>Escape from escape analysis</a></h1><div class=post-meta><span class=post-date>2018-11-30</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>golang</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/programming-language/>programming language</a>&nbsp;</span><div class=post-content><ol><li>逃逸分析背景 Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。 特点是全局停顿时间比较少，在一些场景下是十微秒级别的。
垃圾回收算法针对的是堆（heap）中的内存。 为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。 这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。
而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。 如这篇文章《Golang escape analysis》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。
对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。 这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。</li><li>Go 版本 使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。
ThinkPad-X1-Carbon:bin bef0rewind$ ./go version go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64 3. 示例 // file: escape.go package main import "fmt" type BigTempObject struct { /// &mldr; field1 int } func causeEscape(i interface{}) { switch i.</li></ol></div><div><a class="read-more button" href=/2018/11/30/2018-11-30-escape-from-escape-analysis/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/>Golang Receiver Type 探索</a></h1><div class=post-meta><span class=post-date>2018-11-21</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>golang</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/programming-language/>programming language</a>&nbsp;</span><div class=post-content><ol><li>参考 在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。
<a href=https://golang.google.cn/ref/spec#Method_sets>https://golang.google.cn/ref/spec#Method_sets</a> <a href=https://golang.google.cn/ref/spec#Types>https://golang.google.cn/ref/spec#Types</a> <a href=https://golang.google.cn/ref/spec#Struct_types>https://golang.google.cn/ref/spec#Struct_types</a> <a href=https://golang.google.cn/ref/spec#Composite_literals>https://golang.google.cn/ref/spec#Composite_literals</a> 核心的概念是 method sets：
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T).</li></ol></div><div><a class="read-more button" href=/2018/11/21/2018-11-21-golang-receiver-type/>→</a></div></div><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>