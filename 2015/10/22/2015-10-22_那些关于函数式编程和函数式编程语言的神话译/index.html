<!doctype html><html lang=en><head><title>那些关于函数式编程和函数式编程语言的神话（译） :: 不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这是翻译自 Quora 一个问题 “What are some myths about functional programming and functional programming languages?” 的一个高票答案，我也不记得当初决定翻译它时的心情，不过历经多次组会，最终完工了。
下面是我能想到的，更具体的一些细节会在后面给出：
“函数式编程”是定义明确的概念 函数式编程仅仅是命令式编程的特殊形式 函数式编程本来就很难 函数式编程本来就是复杂的 函数式编程不宜编写图形用户界面 Haskell 仅仅是函数式的 你需要大量的数学知识来进行函数式编程 函数式程序员必须非常聪明而且擅长计算机科学 “函数式编程” 是一个（明确的）概念 它不是。它是计算机科学中定义最糟糕的术语之一 —— 甚至不如“面向对象”，但比“声明式编程”好一点点。弄清楚一种语言是否是“函数式的”是一个人类学（anthropology）上的练习而非计算机科学。
没有任何一种“函数式编程”的技术定义不会引发众人抱怨。有些定义过于宽泛 —— 如果你想要的是 lambda 表达式，那么一切从 C ++ 到 Java 到 Python 的语言突然都变得“函数式”了，只有 C 和汇编不是！如果你要一个数学上的定义，那么只有 Coq、Agda 和它们的朋友们是函数式的，因为就算是 Haskell 都允许部分函数和非终止性。还有异常。哦，上帝，异常！
就我个人来讲，称每一种带有“脉冲”的语言（即任何具有 lambda 表达式的语言，lambda 的符号为 λ，像一个脉冲）为“函数式的”并没什么用。当我说“函数式的”，我通常是指像 Haskell 或至少是 ML 的语言，而不是像 Java、Python、 JavaScript，或者甚至是 Common Lisp 的语言。Scheme 和 Clojure 有点是函数式的，但我不会对它们谈论过多，即便我的确有大量关于前者（Scheme）的经验。
好吧，实话说，我的意思只是“Haskell”，除非我明确提出不是。是啊，这是为了你们的语言学上的定义。（脑补出这个翻译）如果你花更少的时间用命令式语言和更多的时间阅读我的思维，你就会明白3。
当然，有些人倾向于给“函数式编程”一个更杂糅的定义！
函数式编程仅仅是少了某些东西的命令式编程 这也许是最有害的神话，因为它广泛流传，特别具有误导性，通常未被明确说出。人们随意假设进行函数式编程就像一个穿着紧身衣的“正常”编程。并不是！一点也不。相反，函数式编程为编程提供了一个新的基础。你使用不同的方式表达事情。通常是全然不同的。事实上，大多数时间，在你使用命令式方法完成的事情和使用函数式方法完成的事情之间，不存在一个一一映射。
在 Haskell 上这点最明显，因为它是唯一把函数式特性放在第一位的语言 。这实际上让 Haskell 比混合语言明显更有表达能力 —— 从确定性的并行到重写规则（即矢量融合）到 软件事务性内存（STM，Software Transactional Memory）到惰性（计算）到它大量的库，这一切都是因为 Haskell 的函数式核心才成为可能。同时，这也使得 Haskell 与其他语言如此不同。这是一种完全不同的思考方式，一个新的基础 —— 不是同样香肠的不同型号，就如许多其他的语言一样（还有 BMWs5）。"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/2015/10/22/2015-10-22_%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="那些关于函数式编程和函数式编程语言的神话（译）"><meta property="og:description" content="这是翻译自 Quora 一个问题 “What are some myths about functional programming and functional programming languages?” 的一个高票答案，我也不记得当初决定翻译它时的心情，不过历经多次组会，最终完工了。
下面是我能想到的，更具体的一些细节会在后面给出：
“函数式编程”是定义明确的概念 函数式编程仅仅是命令式编程的特殊形式 函数式编程本来就很难 函数式编程本来就是复杂的 函数式编程不宜编写图形用户界面 Haskell 仅仅是函数式的 你需要大量的数学知识来进行函数式编程 函数式程序员必须非常聪明而且擅长计算机科学 “函数式编程” 是一个（明确的）概念 它不是。它是计算机科学中定义最糟糕的术语之一 —— 甚至不如“面向对象”，但比“声明式编程”好一点点。弄清楚一种语言是否是“函数式的”是一个人类学（anthropology）上的练习而非计算机科学。
没有任何一种“函数式编程”的技术定义不会引发众人抱怨。有些定义过于宽泛 —— 如果你想要的是 lambda 表达式，那么一切从 C ++ 到 Java 到 Python 的语言突然都变得“函数式”了，只有 C 和汇编不是！如果你要一个数学上的定义，那么只有 Coq、Agda 和它们的朋友们是函数式的，因为就算是 Haskell 都允许部分函数和非终止性。还有异常。哦，上帝，异常！
就我个人来讲，称每一种带有“脉冲”的语言（即任何具有 lambda 表达式的语言，lambda 的符号为 λ，像一个脉冲）为“函数式的”并没什么用。当我说“函数式的”，我通常是指像 Haskell 或至少是 ML 的语言，而不是像 Java、Python、 JavaScript，或者甚至是 Common Lisp 的语言。Scheme 和 Clojure 有点是函数式的，但我不会对它们谈论过多，即便我的确有大量关于前者（Scheme）的经验。
好吧，实话说，我的意思只是“Haskell”，除非我明确提出不是。是啊，这是为了你们的语言学上的定义。（脑补出这个翻译）如果你花更少的时间用命令式语言和更多的时间阅读我的思维，你就会明白3。
当然，有些人倾向于给“函数式编程”一个更杂糅的定义！
函数式编程仅仅是少了某些东西的命令式编程 这也许是最有害的神话，因为它广泛流传，特别具有误导性，通常未被明确说出。人们随意假设进行函数式编程就像一个穿着紧身衣的“正常”编程。并不是！一点也不。相反，函数式编程为编程提供了一个新的基础。你使用不同的方式表达事情。通常是全然不同的。事实上，大多数时间，在你使用命令式方法完成的事情和使用函数式方法完成的事情之间，不存在一个一一映射。
在 Haskell 上这点最明显，因为它是唯一把函数式特性放在第一位的语言 。这实际上让 Haskell 比混合语言明显更有表达能力 —— 从确定性的并行到重写规则（即矢量融合）到 软件事务性内存（STM，Software Transactional Memory）到惰性（计算）到它大量的库，这一切都是因为 Haskell 的函数式核心才成为可能。同时，这也使得 Haskell 与其他语言如此不同。这是一种完全不同的思考方式，一个新的基础 —— 不是同样香肠的不同型号，就如许多其他的语言一样（还有 BMWs5）。"><meta property="og:url" content="https://blog.formalscience.com/2015/10/22/2015-10-22_%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="技术记录"><meta property="article:published_time" content="2015-10-22 00:00:00 +0000 UTC"></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://blog.formalscience.com/2015/10/22/2015-10-22_%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/>那些关于函数式编程和函数式编程语言的神话（译）</a></h1><div class=post-meta><span class=post-date>2015-10-22</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/functional-programming/>Functional Programming</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/haskell/>Haskell</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80/>函数式语言</a>&nbsp;</span><div class=post-content><div><p>这是翻译自 Quora 一个问题<a href=https://www.quora.com/What-are-some-myths-about-functional-programming-and-functional-programming-languages> “What are some myths about functional programming and functional programming languages?” </a>的一个高票答案，我也不记得当初决定翻译它时的心情，不过历经多次组会，最终完工了。</p><hr><p>下面是我能想到的，更具体的一些细节会在后面给出：</p><ul><li>“函数式编程”是定义明确的概念</li><li>函数式编程仅仅是命令式编程的特殊形式</li><li>函数式编程本来就很难</li><li>函数式编程本来就是复杂的</li><li>函数式编程不宜编写图形用户界面</li><li>Haskell 仅仅是函数式的</li><li>你需要大量的数学知识来进行函数式编程</li><li>函数式程序员必须非常聪明而且擅长计算机科学</li></ul><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程---是一个明确的概念函数式编程-是一个明确的概念><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B---%E6%98%AF%E4%B8%80%E4%B8%AA%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A6%82%E5%BF%B5></a>“函数式编程” 是一个（明确的）概念<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程---是一个明确的概念函数式编程-是一个明确的概念 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>它不是。它是计算机科学中定义最糟糕的术语之一 —— 甚至不如“面向对象”，但比“声明式编程”好一点点。弄清楚一种语言是否是“函数式的”是一个<strong>人类学</strong>（anthropology）上的练习而非计算机科学。</p><p><strong>没有任何一种</strong>“函数式编程”的技术定义不会引发众人抱怨。有些定义过于宽泛 —— 如果你想要的是 lambda 表达式，那么一切从 C ++ 到 Java 到 Python 的语言突然都变得“函数式”了，只有 C 和汇编不是！如果你要一个数学上的定义，那么只有 Coq、Agda 和它们的朋友们是函数式的，因为就算是 Haskell 都允许部分函数和非终止性。还有异常。哦，上帝，异常！</p><p>就我个人来讲，称每一种带有“脉冲”的语言（即任何具有 lambda 表达式的语言，lambda 的符号为 λ，像一个脉冲）为“函数式的”并没什么用。当我说“函数式的”，我通常是指像 Haskell 或至少是 ML 的语言，而不是像 Java、Python、 JavaScript，或者甚至是 Common Lisp 的语言。Scheme 和 Clojure 有点是函数式的，但我不会对它们谈论过多，即便我的确有大量关于前者（Scheme）的经验。</p><p>好吧，实话说，我的意思只是“Haskell”，除非我明确提出不是。是啊，这是为了你们的语言学上的定义。（脑补出这个翻译）如果你花更少的时间用命令式语言和更多的时间阅读我的思维，你就会明白3。</p><p>当然，有些人倾向于给“函数式编程”一个更杂糅的定义！</p><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程仅仅是少了某些东西的命令式编程函数式编程仅仅是少了某些东西的命令式编程><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%BB%85%E4%BB%85%E6%98%AF%E5%B0%91%E4%BA%86%E6%9F%90%E4%BA%9B%E4%B8%9C%E8%A5%BF%E7%9A%84%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B></a>函数式编程仅仅是少了某些东西的命令式编程<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程仅仅是少了某些东西的命令式编程函数式编程仅仅是少了某些东西的命令式编程 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>这也许是最有害的神话，因为它广泛流传，特别具有误导性，通常未被明确说出。人们随意假设进行函数式编程就像一个穿着紧身衣的“正常”编程。并不是！一点也不。相反，函数式编程为编程提供了一个<strong>新的基础</strong>。你使用不同的方式表达事情。通常是全然不同的。事实上，大多数时间，在你使用命令式方法完成的事情和使用函数式方法完成的事情之间，不存在一个一一映射。</p><p>在 Haskell 上这点最明显，因为它是唯一把函数式特性放在第一位的语言 。这实际上让 Haskell 比混合语言明显更有表达能力 —— 从<a href="https://www.quora.com/Haskell/What-are-the-novel-ideas-and-profound-insights-in-the-design-of-the-Haskell-programming-language/answer/Tikhon-Jelvis?srid=p9P3&share=1">确定性的并行</a>到重写规则（即矢量融合）到 软件事务性内存（STM，Software Transactional Memory）到惰性（计算）到它大量的库，这一切都是因为 Haskell 的函数式核心才成为可能。同时，这也使得 Haskell 与其他语言如此不同。这是一种完全不同的思考方式，一个新的基础 —— 不是同样香肠的不同型号，就如许多其他的语言一样（还有 BMWs5）。</p><p>这使我想起一个小的主题神话： Haskell 和不纯的函数式语言之间的差异仅仅是是（纯净）程度上的，而非类别上的 。这绝对不真实。根据我的经验，Haskell 的纯（函数式）和惰性（计算）与 OCaml 或 Scala 等类似语言，存在与生俱来的实践和哲学上的重大差异。多范型语言的倡导者喜欢声称函数式和命令式都支持才最好，但并不是；在许多方面来看，Haskell 比混合语言表达能力更强。</p><p>例如，Haskell 中可以很容易地将计算具体化（reify）为数据，这可以得到更加模块化的代码。这可以很容易地将一个计算的定义与其求值解耦和。列表通常以数据结构的形式替代循环；树可以表示复杂的递归函数。反过来，这使得任意类型上的 <code>fold</code> 和 <code>unfold</code> 操作在 Haskell 中比在其他语言中更强有力。</p><p>在类如 Scala 的语言中尝试模拟 Haskell 风格的函数式编程并不容易。Edward Kmett —— 一个领先的开源 Haskell 开发者 —— 甚至走得更远，他重写了一个新的 JVM 语言来克服这些限制；可以看一下他的关于<a href=http://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu>“为何 Scala 不够”</a> 的这一点上细致详细的论述。</p><p>寓意：<strong>不纯粹（的函数式特性）并没得到完全性的胜利；它不仅在安全性上做出了巨大牺牲，同时在表达能力上也是。</strong> 当然，不纯粹性也使得一些代码的实现更容易，但其中的大部分都被 Haskell 中的特性覆盖了，例如状态线程（ST，state threads）或者 IO。</p><p>所有这一切，也忽略了一些其他功能，哈斯克尔我提到这取决于纯度或懒惰像载体的融合，重写规则或确定性的并行性。</p><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程原本就难函数式编程原本就难><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%8E%9F%E6%9C%AC%E5%B0%B1%E9%9A%BE></a>函数式编程原本就难<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程原本就难函数式编程原本就难 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>函数式编程与大多数人习惯的编程方式差别很大。很多人发现学习函数式编程很难，因为这就像<strong>完全重新学习如何编程</strong>。回忆一下你学习第一门语言时的感受，那么可以想象你将重新体验一遍。当然了，这看上去会很难！</p><p>从 Java 迁移到 C# 很简单。从 Java 到 Python 需要一点智力上的迁移，但是基本上还是那回事。甚至从 C 到 Java 也不太糟 —— 从概念的角度考虑，Java 是在和 C 同样的基础上增加的概念，两者都有变量、控制结构和表达式。从你最初学习的语言到当今流行的新命令式语言，这个过程是渐进的。</p><p>函数式编程并不是这样，这就像从你脚下抽走地毯一样。最基础的想法都被完全替换掉了。不再有语句（statement），不再有循环（loop），不再有变量。见鬼，不再有程序执行 —— 对于一段函数式程序，你不是运行它，而是对它求值。事实上，对于一门类如 Haskell 的语言，求值的顺序是在你的抽象层次之下的，并不影响你的程序的所作所为 —— 执行的顺序控制了作用（effect）何时发生，其同表达式怎样被求值是完全分离的。这意味着你书写程序的顺序很大程度上不再重要，而这对于命令式程序员来说很奇怪，因为命令式的思考方式要求你时刻将程序的执行顺序记在脑中。</p><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程本质就是复杂的函数式编程本质就是复杂的><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E5%A4%8D%E6%9D%82%E7%9A%84></a>函数式编程本质就是复杂的<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程本质就是复杂的函数式编程本质就是复杂的 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>同时，“复杂”也是“困难”的代名词。Rich Hickey 的“简单导致容易（Simple Made Easy）”2的演讲精彩地阐述了“复杂”和“困难”的关系。前者（简单还是复杂）是系统的一个属性，粗略地说，就是它有多大。后者是人的一个属性 —— 一件事情有多难很大程度上依赖于其经验和接受的教育。</p><p>有些人切身感觉函数式语言很难。但这并不意味着它是复杂的！事实上，你可以把一门类如 Haskell 语言的核心求值规则和类型规则塞到一张纸上。当然，你必须使用非常精确的数学符号才行，但这也仅在规则比较少时行得通。对 ML 语言也是如此。诚然，任何在现实世界中使用的语言，包括 Haskell，都会迅速滋长额外的复杂度。但至少，函数式语言依旧可以基于 λ 演算，保持一个最小的、简单的以及良好定义的内核 —— 这是命令式语言不能声称的特性。</p><p>一个重要的概念是实现的简单和语义的简洁的差别。函数式语言意在后者：它们以更复杂的运行时环境或编译器为代价，来追求更加一致的行为。命令式语言（以 Google 的 Go 语言作为一个极端例子）通常采用相反的方针：比起语义的简洁，更加注重实现上的简单。它们选择了不一致和未定义的行为，来换取一种简单的实现，此外还期待一种更加简单的与硬件的映射。</p><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程适合编写图形用户界面gui函数式编程适合编写图形用户界面gui><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%80%82%E5%90%88%E7%BC%96%E5%86%99%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2gui></a>函数式编程适合编写图形用户界面（GUI）<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程适合编写图形用户界面gui函数式编程适合编写图形用户界面gui class=hanchor arialabel=Anchor>&#8983;</a></h2><p>函数式编程用来编写 GUI 再合适不过了！我们只是采用不同的方式而已。我们有一个编写 GUI 代码的全新6范式：函数反应式编程（FRP）。FRP 使 GUI 代码更简单，更加模块化，更具声明式特性。</p><p>GUI 代码是对时间的建模。使用命令式语言，时间是使用可改变的状态和回掉函数被隐式建模的。其中时间确凿无疑地是一个二等公民。这使得我们不能直接谈论时间，不可避免陷入回掉函数错综复杂的泥潭，纠缠在严重耦合的全局状态之中。当然如果你很小心，这可能只会变成半全局状态。你甚至不能拿一个变量，然后声称“当 x 大于 7 时，让这个变量变红；否则使它变蓝”。相反，你需要相当多的“仪式”以及外部结构来把 x 封装在一个模型之中（或者其他什么东西之中），还要带上事件监听器（event listeners）和常用的访问器（accessors）。</p><p>而使用 FRP，时间是你可以精确表示出来的东西。这就是我所说的让时间成为“一等公民”：你可以编写代码，直接引用变量值在时间上的行为。</p><p>查看<a href=https://www.quora.com/What-is-Functional-Reactive-Programming>什么是函数反应式编程？</a>以及我的生命游戏中的例子 <a href=http://jelv.is/frp/>FPR | jelv.is</a> （带有完整的代码<a href=https://github.com/TikhonJelvis/Reactive-Life>Reactive-Life</a>）。</p><p>FRP 不仅仅让我们可以编写漂亮的反应式 GUI 代码：它对于音乐以及甚至是机器人学中的应用也很好！ 对于所有的这些应用来说，比起使用回掉函数和状态，这绝对是前进性的一步！</p><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmdhaskell-仅仅是一门函数式语言haskell-仅仅是一门函数式语言><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#haskell-%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E9%97%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80></a>Haskell 仅仅是一门函数式语言<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmdhaskell-仅仅是一门函数式语言haskell-仅仅是一门函数式语言 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>不，Haskell 是一门完全的多范式语言.它很容易就能支持命令式编程 —— 人们戏称它为“最好的命令式语言”或者“完美的 Algol”1 —— 以及逻辑式编程。它甚至能够支持面向对象编程（OOP），当然没有人给出足够的关注。Haskell 代码甚至可以<a href=http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html>看起来像 C 语言</a>，当然要付出一点努力！</p><p>唯一的区别是，不同于其他任何一门多范式语言，Haskell 是函数式为先的。其他的语言给你一个命令式的基础，然后在此之上叠加函数式的功能。Haskell 给你一个函数式的基础，然后在此之上叠加命令式或者逻辑式的功能。</p><p>由于这是 Haskell 异于其他语言之处，同样也是非 Haskell 人员（non-Haskellers）纠缠之处。这也引发了初学者针对函数式语言提出的一堆无意义的讨论，例如“Haskell 为什么不允许值的改变（mutation）”。</p><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd你需要大量的数学知识才能使用函数式编程你需要大量的数学知识才能使用函数式编程><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E4%BD%A0%E9%9C%80%E8%A6%81%E5%A4%A7%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E6%89%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B></a>你需要大量的数学知识才能使用函数式编程<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd你需要大量的数学知识才能使用函数式编程你需要大量的数学知识才能使用函数式编程 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>实际上不需要。当然了，函数式语言是在数学基础上设计的 —— 同时命令式语言是在计算机体系结构基础上设计的。然而，你使用 C 语言时并不需要知道关于 ALU （Arithmetic Logic Unit，计算逻辑单元）的寄存器知识。</p><p>我在对除了基本的微积分外一无所知的情况下接触函数式编程的。此外，我从来没有特别擅长过数学。而这对我没有造成一点障碍。我很好地学习了实践意义上的 monads（单子）、applicatives 以及 functors（函子），在我理解任何相关理论之前。</p><p>实际上我是通过 Haskell 来学习相关的数学知识的。但是你也不必这样做（指学习数学知识），如果你真心讨厌数学的话。学习 Haskell 中例如函子和单子的抽象，就像你学习的 Java bean，Lua 的协程或 Scheme 的宏一样。事实上，函子（Functor）的思想是我最初学到的 关于计算机科学的内容之一 —— 它仅仅是你可以将一个函数映射在其上的任何类型。</p><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式程序员必须非常聪明而且擅长计算机科学函数式程序员必须非常聪明而且擅长计算机科学><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E9%9D%9E%E5%B8%B8%E8%81%AA%E6%98%8E%E8%80%8C%E4%B8%94%E6%93%85%E9%95%BF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6></a>函数式程序员必须非常聪明而且擅长计算机科学<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式程序员必须非常聪明而且擅长计算机科学函数式程序员必须非常聪明而且擅长计算机科学 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>无需多言，我是一个函数式程序员 :) 。</p><p>函数式编程不是黑暗、邪恶的魔法。（好吧，也许 <strong>Coq</strong> 是：P）。在许多方面，函数式编程实际上有助于你弥补并不强力的智商。Haskell 的类型系统极大地限制了你能写出的各种类型的错误功能，这使得你仅仅无脑利用类型系统就可以在困难的问题面前披荆斩棘。</p><p>我发现 Haskell 是进行编程喝酒7活动时最好的语言。所有愚蠢的错误 —— 以及一些不愚蠢的错误 —— 都可以被编译器捕捉到。所以我可以摆弄我的代码直到类型检查通过。然后，程序（通常）就可以正常工作了。通常到比其应有的（通过类型检查就能正常工作正常工作）的频率高得多。Haskell 给你提供诸多工具使你克服你自己的不靠谱。</p><p>函数式编程对初学者也是出奇地容易上手。例如，在 Jane Street 公司，他们为所有新进的交易员教授 OCaml 语言。我承认 Jane Steet 公司的交易员是特别聪明的一群人，但是他们中许多人绝不是程序员更不是计算机科学家。然而他们在短暂的 OCaml 集中培训后变得卓有效率，其中一些交易员花费了大量时间写函数式代码。</p><p>另一个很好的例子是 IMVU 公司。我的一个朋友在他们的团队，帮助相当数量的普通程序员迁移到 Haskell 上。对于 web 开发，同样地，人们能在短时间内变得有效率。冒着听起来傲慢自大的风险，像 IMVU 的公司中员工的平均智商水平比不上世界上顶级交易公司的员工。</p><p>也就是说，我的经验是 Haskell 社区中的人_确实_不成比例地聪明以及擅长计算机科学。并不是 Haskell 要求你如此，而是这个社区具有相当的自我选择特性。聪明的人似乎更可能主动选择 Haskell。实际上就像不久之前的 <a href=http://paulgraham.com/pypar.html>The Python Paradox</a>，揭示了 Python 是如何被广泛接受为最易学的语言！</p><hr><h2 id=httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd脚注4脚注sup4sup><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E8%84%9A%E6%B3%A84></a>脚注4：<a href=#httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd脚注4脚注sup4sup class=hanchor arialabel=Anchor>&#8983;</a></h2><p>1这是一个很好的例子 <a href=http://www.catb.org/jargon/html/H/ha-ha-only-serious.html><em>ha ha only serious</em></a> —— 有些最初看上去只是一个笑话，但实际上有深层的含义。Haskell 是一个很好的命令式语言，因为它拥有作为一等公民的“命令式动作”（“imperative actions”）；你不必将语句封装在 lambda 中来将它们传来传去！这也使得将表示性的命令式控制结构，从这样的表示：</p><pre><code>when

to

callCC
</code></pre><p>变成了库。</p><p>此外，<a href=http://www.catb.org/jargon/html/>Jargon File</a>是令人难以置信的，如果你对计算机科学发展历程和“黑客”文化真正感兴趣，这将会是绝佳的资源。</p><p>2这是一段美妙的谈话。我爱他定义的概念框架，即便我不同意他的一些结论。静态类型 —— 尤其是基于 Hindley-Milner 且不带 subtyping 的 —— 实际上不复杂。其实在某些方面，它们比动态类型系统的 Clojure 使用简单！（译者注：竟然黑 Clojure！）</p><p>这里是一个谈话的链接：<a href=http://www.infoq.com/presentations/Simple-Made-Easy-QCon-London-2012>Simple Make Easy</a></p><p>3我坚持认为，这是成为有趣程序员简单而有趣的一个方式。</p><p>4还记得我提到在函数式编程中顺序并不重要？是的，这完全是我不能以一种合适方式记住脚注顺序的借口。毕竟，我内心深处还是一个函数式程序员！</p><p>5两类完全不同的模型（前面的是 5 系列，后面的是 7 系列），大多数编程语言都大体如此。</p><p><a href=https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/BMW-5-7.jpg><img src=https://github.com/ronhuafeng/ronhuafeng.github.io/raw/master/BMW-5-7.jpg alt=BMW-5-7></a></p><p>6实际上，就像函数式编程一样，FRP（函数反应式语言）已经存在一段时间了，至少从 1997 年开始。但它仅仅临近时日才开始抓住人们的目光。</p><p>7我喝酒时用过大量不同的语言，所以我可以做出公平比较。在旧金山的疯狂的世界中，我们通过解决 <a href=http://projecteuler.net/>Project Euler</a> 上的问题以及喝酒来寻乐子。多么美妙的生活啊！</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>