<!doctype html><html lang=en><head><title>技术记录 :: 不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="技术记录"><meta property="og:description" content><meta property="og:url" content="https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/index.xml rel=alternate type=application/rss+xml title=不是追风少年></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/>Golang 系统调用/Syscall</a></h1><div class=post-meta><span class=post-date>2018-01-15</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>Golang</a>&nbsp;</span><div class=post-content>概述 很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：
func Read(fd int, p []byte) (n int, err error) func Write(fd int, p []byte) (n int, err error) 同时，Golang 也提供了对 Syscall 的直接调用支持：
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) RawSyscall 和 RawSyscall6 是对操作系统 Syscall 的直接调用；Syscall 和 Syscall6 会在调用操作系统 Syscall 前调用 runtime·entersyscall ，在操作系统 Syscall 返回后调用 runtime·exitsyscall 。</div><div><a class="read-more button" href=/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/>Golang 中学到的新东西</a></h1><div class=post-meta><span class=post-date>2018-01-14</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>Golang</a>&nbsp;</span><div class=post-content>数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&s[0]) var ptr unsafe.Pointer s := ((*[1&lt;&lt;10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := <em>(</em>[]byte)(unsafe.Pointer(&s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) map 实现 整个页面的内容对我来说都是新的：https://tiancaiamao.</div><div><a class="read-more button" href=/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/13/2018-01-13_%E4%BD%BF%E7%94%A8-nvidia-%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/>使用 Nvidia 显卡加速机器学习算法的一些资料</a></h1><div class=post-meta><span class=post-date>2018-01-13</span></div><div class=post-content>Nnidia 显卡可以用来加速机器学习算法（特别是深度学习），但安装驱动过程中总会碰到这样或者那样的问题。 一个难点是安装库的时候没有下载链接，比如 Nvidia 的 Cuda/cuDNN 主页经常会出现这样的提示：
NVIDIA Developer Site is under going maintenance. The site will be back by shortly. We apologize for any inconvenience. 虽然不能按照官方路径进行下载，但经过搜索总能找到一些入口。下面是我收集的一些链接：
cuDNN 下载页面：https://developer.nvidia.com/rdp/cudnn-download 这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 cuDNN v5.1 到 cuDNN 7.0.5 的版本 CUDA 下载页面：https://developer.nvidia.com/cuda-toolkit-archive 这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 CUDA Toolkit 1.0 到 CUDA Toolkit 9.0 的版本，最新的 CUDA Toolkit 9.1 的链接仍然指向正在维护的提示页面 Ubuntu 16.04 CUDA Toolkit 9.1 下载链接：http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_9.1.85-1_amd64.deb 此外可以在这个页面找到其他 Linux 发行版的安装包：http://developer.download.nvidia.com/compute/cuda/repos/ Windows 10 版本的 CUDA Toolkit 9.1 我成功下载过一次，但是和当前的 TensorFlow 1.</div><div><a class="read-more button" href=/2018/01/13/2018-01-13_%E4%BD%BF%E7%94%A8-nvidia-%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/12/2018-01-12_%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE_protocol_labs/>一些有趣的项目 Protocol Labs</a></h1><div class=post-meta><span class=post-date>2018-01-12</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/note/>note</a>&nbsp;</span><div class=post-content>最初在 3Blue1Brown 发布的一个介绍区块链原理的视频中看到了这个组织的连接。发现比较有意思，给大家分享一下~
项目的使命：
We believe the internet has become humanity’s most important technology. We build protocols, systems, and tools to improve how it works. Today, we are focused on how we store, locate, and move information.
我们相信互联网已成为人类最重要的技术。我们构建提升互联网工作能力的协议、系统和工具。当前我们集中在如何存储、定位和移动信息的工作上。
这段文字翻译得有点机器翻译风格。
项目地址：https://protocol.ai/projects/ ，目前上面有 5 个项目：
Filecoin 加密货币，Miners 通过向网络提供存储空间来获取 Filecoin ，使用者通过消耗 Filecoin 来在去中心化的网络中存储加密后的文件。 IPFS (InterPlanetary File System) 一种新型协议，用来使网络去中心化。IPFS 通过内容寻址和数字签名来创建完全去中心化和分布式的应用。IPFS 使得网络更快、更安全以及更加开放。 这是一段 YouTube 上的介绍视频：https://www.youtube.com/watch?v=8CMxDNuuAiQ ，介绍了 IPFS 的一些基本使用方法。根据我的理解，这是通过 content-address（immutable hash） 访问的分布式加密文件系统，可以通过命令行、网页界面等多种方式进行访问，有点类似 Samba，不过是分布式的。Siraj Raval 制作的一个视频：https://www.youtube.com/watch?v=BA2rHlbB5i0 ，也对 IPFS 进行了介绍，主要对 Why 的部分进行阐述。 带宽，多个客户端对中心节点访问 延迟 弹性 Resiliency，中心节点失效（网络断开或者数据删除）后无法进行数据访问 中心化 Centralization，主流网站掌控所有数据，用户无从得知数据的使用方式，此外会受到政府或者其他势力的干扰。 使用的技术：Chord、DHT、bit swap(bittorrent mechanism)、MerkleDAG Libp2p 一个模块化的网络栈，把一系列传输协议和 peer-to-peer 协议整合在一起，方便开发者构建大型、健壮的 p2p 网络 IPLD 去中心化网络（content-addressable web）的数据模型，它通过加密哈希值的方式连接了所有数据，使得数据的遍历和彼此链接更加容易。网站的示意图中连接了 bitcoin、以太坊、IPFS、Git Repo 等。 Multiformats 这个项目是面向未来验证系统（future-proof systems）的协议集合， 自描述的格式可以让你的系统可以互操作和具有可升级性。</div><div><a class="read-more button" href=/2018/01/12/2018-01-12_%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE_protocol_labs/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2017/01/18/2017-01-18_ingress-passcode-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/>Ingress_Passcode_自动提交</a></h1><div class=post-meta><span class=post-date>2017-01-18</span></div><div class=post-content>什么是 Passcode？ 根据 Ingress 中文游戏指南 的讲解，Passcode 是 Ingress 提供的一种奖励。
使用 Investigation Board 来了解 Ingress 的最新剧情并寻求对 Niantic Project, NIA, XM, Shapers 以及各阵营不同问题的答案。 可以使用隐藏在这些报告之中的 Passcode 来兑换道具（Resonator，XMP 等），XM 或者 AP。
另外，一些官方活动会向到场者赠送包含 Passcode 的卡片，特定的官方周边也会赠送此类卡片。卡片上的 Passcode 一般能够兑换活动徽章。
注：在很多社交网站上可以找到有效的 Passcode
在 iOS 平台的 Ingress 客户端上 Passcode 兑换功能不可用，因此只能使用 Intel Map 来兑换。
在 Intel Map 上兑换 在右上方点击 Passcode 输入你的 passcode，然后点击 SUBMIT 兑换 自动化 Intel Map 兑换过程 可以通过浏览器的调试页面，自动将搜寻到的 passcode 提交，进行物品兑换。
表单提交 document.getElementById("redeem_reward_form").submit(); 不能正确提交表单失败的原因是这个表单的 input 元素名称就是 submit，需要重命名。
var field = document.</div><div><a class="read-more button" href=/2017/01/18/2017-01-18_ingress-passcode-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2017/01/16/2017-01-16_%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA_java_agent/>如何构建一个 Java Agent</a></h1><div class=post-meta><span class=post-date>2017-01-16</span></div><div class=post-content>First. Implement a static premain (as an analogy to main) method, like this:
import java.lang.instrument.Instrumentation; class Example { public static void premain(String args, Instrumentation inst) { &mldr; } } Second. Create a manifest file (say, manifest.txt) marking this class for pre-main execution. Its contents are:
Premain-Class: Example
Third. Compile the class and package this class into a JAR archive:
javac Example.java jar cmf manifest.txt yourAwesomeAgent.jar *.class
Fourth. Execute your JVM whith -javaagent parameter, like this:</div><div><a class="read-more button" href=/2017/01/16/2017-01-16_%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA_java_agent/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2016/09/16/2016-09-16_windows_%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6/>Windows 推荐软件</a></h1><div class=post-meta><span class=post-date>2016-09-16</span></div><div class=post-content>在知乎上看了一些推荐
Total Commander Listary AutoHotKey Internet Download Manager paint.net pot player Tickeys 7-zip Beyond Compare PowerTab (Powershell auto complete) Fiddler ZoomIt Postman - Chrome 里的 HTTP/REST 客户端，Web 服务专用神器 Pixie - 简单，可爱，便携的取色器 快捷键
Windows+Tab调出虚拟桌面 Alt+Tab 切换不同的窗口 Windows+Ctrl+D 创建新的虚拟桌面 Windows+Ｃtrl+F4 关闭当前虚拟桌面 Ctrl＋Windows＋左右箭头　虚拟桌面切换</div><div><a class="read-more button" href=/2016/09/16/2016-09-16_windows_%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2016/02/03/2016-02-03_%E4%B8%BA%E4%BB%80%E4%B9%88_haskell_%E4%B8%AD_%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B_%E4%B8%8D%E6%98%AF_show_%E7%B1%BB%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B/>为什么 Haskell 中 函数类型 不是 “Show” 类型类的实例</a></h1><div class=post-meta><span class=post-date>2016-02-03</span></div><div class=post-content>问题 为什么函数类型不是 show 类型类的实例以显示参数和值的类型？
为什么我不能在 GHCi 或者 Hugs 中输入 \x -&amp;gt; x + x ，在结果中看到同样的表达式形式作为输出。
为什么存在一个 Show 实例，却只打印函数的类型？
Prelude&amp;gt; :m + Text.Show.Functions Prelude Text.Show.Functions&amp;gt; show Char.ord "&amp;lt;function&amp;gt;" <code>&amp;lt;/pre&amp;gt; 如何让 lambdabot 有如下显示： &amp;lt;pre&amp;gt;</code>dons &amp;gt; ord lambdabot&amp;gt; &amp;lt;Char -&amp;gt; Int&amp;gt; <code>&amp;lt;/pre&amp;gt; # 答案 ## 实践中的答案 Haskell 编译器并不保持表达式原本的形式，而是将它们转成机器代码或者其他的底层表示。 函数 </code>\x -&amp;gt; x - x + x :: Int -&amp;gt; Int<code>也许被优化成</code>\x -&amp;gt; x :: Int -&amp;gt; Int<code>。没有那个地方l存储了变量名</code>x` 。 你也许会想，Haskell 是一门脚本语言，在运行时环境中维护着表达式的内容。情况并非如此，[Lambda 表达式](https://wiki.</div><div><a class="read-more button" href=/2016/02/03/2016-02-03_%E4%B8%BA%E4%BB%80%E4%B9%88_haskell_%E4%B8%AD_%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B_%E4%B8%8D%E6%98%AF_show_%E7%B1%BB%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2016/02/03/2016-02-03_%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%88%A4%E5%8D%B7%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/>函数式语言课程期末考试判卷中遇到的一个问题</a></h1><div class=post-meta><span class=post-date>2016-02-03</span></div><div class=post-content>在使用半自动化 Judge 系统对同学的答题进行评测的时候，遇到了一个奇怪的问题，总是会提示: Test_1: output.txt: openFile: resource busy (file is locked)
起初以为是 haskell 惰性求值导致的 IO 问题，因为搜索引擎也把猜测引导向这个原因，但是始终解决不了。
后来改变了思路，“现在看来好像是模块引入带来的 main 函数重名问题”，这是后面的猜疑。
继而发现将函数改名字也解决不了问题，实际也不是，就是 IO 的问题。因为如果先移除 output.txt， 那么使用 ghc 执行就不会出现之前的错误提示，不过在 ghci 中执行总是不会出错。
使用如下代码测试一下：
dir = "/home/user-name/Downloads/auto_check/work/2015final/ref/tests/words" main :: IO () main = do print "hehe" solution = runTest (map (\f -&amp;gt; combine dir f) ["input1-1.txt", "input1-2.txt", "input1-3.txt"]) (combine dir "output1.txt") <code>&amp;lt;/pre&amp;gt; 执行得到如下结果： &amp;lt;pre&amp;gt;</code>➜ test ghci Test_1.hs GHCi, version 7.8.4: <a href=http://www.haskell.org/ghc/>http://www.haskell.org/ghc/</a> :? for help Loading package ghc-prim .</div><div><a class="read-more button" href=/2016/02/03/2016-02-03_%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%88%A4%E5%8D%B7%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2016/01/09/2016-01-09_%E9%97%9C%E6%96%BC_llvm_pass_%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/>關於 LLVM Pass 的一些基本操作</a></h1><div class=post-meta><span class=post-date>2016-01-09</span></div><div class=post-content>關於 LLVM Pass 的一些基本操作 記錄一下關於 LLVM Pass 的一些操作，主要是一些配置工作。雖然目前的工作流程不是很優雅，但是可以自定義 LLVM Pass 的處理過程，通過進一步學習可以作出更有意思的東西。
本文的 GitHub 地址： <a href=https://github.com/ronhuafeng/HandleLLVMPassBasic>https://github.com/ronhuafeng/HandleLLVMPassBasic</a> ，有這篇文章和一些粗糙的源代碼。
網絡上已經有一下教程了，我也參考了這些教程。
使用 clang 加載 LLVM 的 Pass LLVM - Run Own Pass automatically with clang stack overflow 上的回答，試圖使用 clang 加載 LLVM 的 Pass。 Polly 库加載 LLVM Pass 的方法也是一个解决思路，我參考了這裏面的很多：Load Polly into clang and automatically run it at -O3 具体的加載過程參考了 Adrian Sampson 博客 Run an LLVM Pass Automatically with Clang 中提到的操作。 工作流程 準備工作 將系統中自帶的 llvm 和 clang 都卸載掉，保證 llvm 和 clang 版本的一致性（非常重要），即保證使用的 clang 和 編譯出的 Pass 的動態鏈接庫文件 .</div><div><a class="read-more button" href=/2016/01/09/2016-01-09_%E9%97%9C%E6%96%BC_llvm_pass_%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/>→</a></div></div><div class=pagination><div class=pagination__buttons><span class="button previous"><a href=/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/><span class=button__icon>←</span>
<span class=button__text>Newer posts</span></a></span>
<span class="button next"><a href=/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/page/3/><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>