<!doctype html><html lang=en><head><title>技术记录 :: 不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="技术记录"><meta property="og:description" content><meta property="og:url" content="https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/index.xml rel=alternate type=application/rss+xml title=不是追风少年></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2015/12/11/2015-12-11_thinkpad_t430_windowsubuntu_dual_boot/>Thinkpad T430 Windows&Ubuntu Dual Boot</a></h1><div class=post-meta><span class=post-date>2015-12-11</span></div><div class=post-content>在 Thinkpad T430 带有原装操作系统（其实是原声的 EFI 分区）的情形下，UEFI 模式下安装 Ubuntu 并成功启动进入 Ubuntu 系统。主要难度是原装电脑启动时会首先加载一个 “LenovoBT.efi” 的文件，然后 Lenovo 直接会去找 Windows 系统相关的 efi 文件，然后忽略其他的系统。T440s 预装win8.1 GPT+EFI ubuntu 双系统 图文过程中提到这样的启动处理：
加载 /EFI/Boot/LenovoBT.EFI /EFI/Boot/bootx64.efi，加载windows的boot loader /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi，启动windows 因此这个文档记录了如何把这个流程给截断，使得 Ubuntu 的启动引导文件可以被看到。
首先说明没有起作用的教程：
Windows 10 Pro + Ubuntu 14.04.3 LTS 雙系統安裝 中提到最后在 Windows 的命令行中使用如下命令 bcdedit /set {bootmgr} path \EFI\ubuntu\grubx64.efi 并没有生效 百度贴吧一个教程 - T440s 预装win8.1 GPT+EFI ubuntu 双系统 图文过程 中提到使用 Ubuntu 的引导文件 “grubx64.efi” 替换 “EFI/Boot” 里面的 “bootx64.efi”，没有效果，可能是 “LenovoBT.efi” 没有走前文提到的处理流程。 有效的教程 Windows 8 removes Grub as default boot manager：</div><div><a class="read-more button" href=/2015/12/11/2015-12-11_thinkpad_t430_windowsubuntu_dual_boot/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2015/10/22/2015-10-22_%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/>那些关于函数式编程和函数式编程语言的神话（译）</a></h1><div class=post-meta><span class=post-date>2015-10-22</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/functional-programming/>Functional Programming</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/haskell/>Haskell</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80/>函数式语言</a>&nbsp;</span><div class=post-content>这是翻译自 Quora 一个问题 “What are some myths about functional programming and functional programming languages?” 的一个高票答案，我也不记得当初决定翻译它时的心情，不过历经多次组会，最终完工了。
下面是我能想到的，更具体的一些细节会在后面给出：
“函数式编程”是定义明确的概念 函数式编程仅仅是命令式编程的特殊形式 函数式编程本来就很难 函数式编程本来就是复杂的 函数式编程不宜编写图形用户界面 Haskell 仅仅是函数式的 你需要大量的数学知识来进行函数式编程 函数式程序员必须非常聪明而且擅长计算机科学 “函数式编程” 是一个（明确的）概念 它不是。它是计算机科学中定义最糟糕的术语之一 —— 甚至不如“面向对象”，但比“声明式编程”好一点点。弄清楚一种语言是否是“函数式的”是一个人类学（anthropology）上的练习而非计算机科学。
没有任何一种“函数式编程”的技术定义不会引发众人抱怨。有些定义过于宽泛 —— 如果你想要的是 lambda 表达式，那么一切从 C ++ 到 Java 到 Python 的语言突然都变得“函数式”了，只有 C 和汇编不是！如果你要一个数学上的定义，那么只有 Coq、Agda 和它们的朋友们是函数式的，因为就算是 Haskell 都允许部分函数和非终止性。还有异常。哦，上帝，异常！
就我个人来讲，称每一种带有“脉冲”的语言（即任何具有 lambda 表达式的语言，lambda 的符号为 λ，像一个脉冲）为“函数式的”并没什么用。当我说“函数式的”，我通常是指像 Haskell 或至少是 ML 的语言，而不是像 Java、Python、 JavaScript，或者甚至是 Common Lisp 的语言。Scheme 和 Clojure 有点是函数式的，但我不会对它们谈论过多，即便我的确有大量关于前者（Scheme）的经验。
好吧，实话说，我的意思只是“Haskell”，除非我明确提出不是。是啊，这是为了你们的语言学上的定义。（脑补出这个翻译）如果你花更少的时间用命令式语言和更多的时间阅读我的思维，你就会明白3。
当然，有些人倾向于给“函数式编程”一个更杂糅的定义！
函数式编程仅仅是少了某些东西的命令式编程 这也许是最有害的神话，因为它广泛流传，特别具有误导性，通常未被明确说出。人们随意假设进行函数式编程就像一个穿着紧身衣的“正常”编程。并不是！一点也不。相反，函数式编程为编程提供了一个新的基础。你使用不同的方式表达事情。通常是全然不同的。事实上，大多数时间，在你使用命令式方法完成的事情和使用函数式方法完成的事情之间，不存在一个一一映射。
在 Haskell 上这点最明显，因为它是唯一把函数式特性放在第一位的语言 。这实际上让 Haskell 比混合语言明显更有表达能力 —— 从确定性的并行到重写规则（即矢量融合）到 软件事务性内存（STM，Software Transactional Memory）到惰性（计算）到它大量的库，这一切都是因为 Haskell 的函数式核心才成为可能。同时，这也使得 Haskell 与其他语言如此不同。这是一种完全不同的思考方式，一个新的基础 —— 不是同样香肠的不同型号，就如许多其他的语言一样（还有 BMWs5）。</div><div><a class="read-more button" href=/2015/10/22/2015-10-22_%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2013/09/02/2013-09-02_%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8clojure%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/>为什么用Clojure，以及一点感悟</a></h1><div class=post-meta><span class=post-date>2013-09-02</span></div><div class=post-content>1.Java互操作
Clojure和Java互操作还是比较简单的，网上有很多案例。
首先讲下Java中调用Clojure。
一种方式是用过clojure.lang中的一些方法引入一个命名空间中的函数和变量，然后使用，这种方法就要注意ClassPath和ClassLoader的问题，这在Eclipse的RCP开发中还是比较烦的。另外要注意如果有Clojure源码文件被编译成Class文件了，调用这些文件的Clojure.jar和编译出这些文件的Clojure.jar版本一定要一致。
另外一种方式就是使用 “:aot :all“ 命令把所有Clojure源码编译成JVM的Class文件，然后调用genclass方法产生的类和函数。这个可以比较方便地把接口暴露出来。这篇文章针对genclass的各种用法讲得很好。
在Clojure中调用Java就很简单了，随便一搜就是一大堆，官方文档也有很多例子。
2.编程模式
Clojure本身就是JVM上的一个Lisp方言，所以编程模式主要就是函数式。当然我对函数式这个术语理解也不是很透彻，目前理解的函数式语言的特点就是：函数是第一公民、尽量保持无状态操作、有利于并行化操作、具有较强的作为meta language的能力（可以用来构建DSL）。这个可以看一下SCIP（计算机程序的构造和解释）这本书。
3.初衷
我本来想用Scala的好嘛！其实，当时主要想做BIP（这个还是高端大气上档次的）这个形式化语言的一个解释器，然后依靠那个不靠谱的方案和一个还不存在的同步形式化语言解释器进行对接，构建一个仿真环境。
其实同为JVM上寄生的函数式语言，明显Scala做这个工作更有优势一点：基于OCaml（这个的前身ML我之前用过）、有方便的类型模式匹配机制（这个机制在写解释器时应该比较有用）。Clojure我也调研过，但是当时是没有这个想法用它的。但是呢，但是呢，亚马逊给我推送了一封邮件，里面就有《Clojure编程》这本书，然后我还顺着广告点过去买了。于是在我刚开始做这个工作的时候，Clojure就被选中了。
都是缘分啊！
4.困难
困难一部分来自对Clojure一些库不了解，对一些常见的实现习惯不了解，后来实践中逐渐搜索学习，也就掌握了。
另外一些来自于和实验室主项目集成的时候，Eclipse RCP项目的ClassLoader比较诡异，我之前也没怎么了解过，碰到了各种”ClassNotFound“的错误，后来经过查找还是解决了。这个是我的一个Evernote笔记。
5.编辑环境的的配置和各种尝试
我先后试过Emacs和Intellij IDEA。
Emacs我还是很喜欢的，特别是里面的ParEdit插件，用来进行Lisp中大量的括号相关的操作简直无敌了，就是要先学习一下快捷键，效率会提升很多。但是有一个缺点（我能说Emacs的缺点么？），配置起来麻烦。虽然各种插件我都装上了，用起来也不错，但是过程中遇到的各种陷阱还是很多的，网上的教程也不总是和预想中的一样有效。我还是一直坚持使用Emacs的。后来实验室的另一个工作要在Windows上进行，在Windows下我一直无法用Emacs启动Clojure的REPL，因此转向了神器——Intellij IDEA。
神器只要下个LaClojure的插件和Leiningen插件就好了。各种只能提示啦，测试啦都可以很方便使用，我还把keymap改成了Emacs式的，算是一个念想。不过神器下面没有ParEdit插件，没法那么方便地处理括号，有些不开心。
6.总结
在学校的一个优势呢，就是可以尝试新的东西（虽然想让我赶快完成项目的老板不这样想）。以前我也学习Lisp，ML等函数式语言，但是一直没有实际动手做个东西。这次虽然使用Clojure做这个解释器有些冲动的成分在里面，整体而言还是很满意的。最后解释器效率可能有些问题（我写的程序有问题，和语言无关），但是程序工作起来还比较正确（至少那些单元测试都还能通过），修改起来也比较容易（还需要一些重构）。我对于Java和Clojure的了解也都稍微深刻了那么一点（是在命名空间这方面）。
下次要不要试试其他的语言呢？
7.项目
主要是做了一个BIP的解释器，还没有做完，只是完成了核心的语义解释的一部分。前段的语法解析器没有做，不过这个有现成的。
8.经验
实践出真知！
这首歌我最近一直在单曲循环。</div><div><a class="read-more button" href=/2013/09/02/2013-09-02_%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8clojure%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2013/05/28/2013-05-28_%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/>建模语言</a></h1><div class=post-meta><span class=post-date>2013-05-28</span></div><div class=post-content>今天晚上和师兄师弟们一起吃饭。去食堂的路上，一直到食堂为止都特别伤心。自己研究生生活都已经过了快两年，对自己的研究方向依然不能向别人解释清楚。特迷茫，特无助。下面是我的一些理解，不是很全面（不是我全部所想的，未必全部是对的）。
1.何谓建模？
建模就是对一个表示的抽象表示，使得抽象过的表示在一定假设下可以回答原始表示能够回答的问题。例如：
把程序抽象成一个流程图，这个流程图可以回答给定输入产生什么输出的问题； 把程序抽象成一个函数依赖图，可以回答关于函数之间调用关系的问题； 把一个地表的自由落体抽象成成真空中的自由落体，（忽略掉空气阻力和允许一定误差情况下）回答自由落体从指定高度到达地面的时间问题 2.建模语言 语言是一种表现形式，就如眼神一样，直达人的灵魂深处。好吧，我文（che）艺（dan）了。写程序需要（编程）语言，刻画物理现象需要（数学）语言，把听到的曲调记录下来也需要（乐谱使用的）语言。建立这些事物的抽象表示（建模过程）也需要一种语言，称为建模语言，例如：UML、Petri Net、自动机（Automata）、正则表达式、上下文无关文法等。
3.建模语言分类
正如编程语言、数学语言有能力强弱、是否易用、山头派系之分，建模语言也是如此。这里主要针对程序建模语言进行说明。
图灵机是一种基础的建模语言，有许多建模语言都用图灵机作为基础来解释自身语义，或者来比较自己的能力。有一些语言表达能力等价于图灵机，有一些语言表达能力则非常有限。能力强弱并不对应语言的好坏。
其中一些语言的等价性可以用来出一些题目，例如把一个正则表达式转化为一个DFA（确定有限自动机）。
这些语言又可以按照是否有形式化的表示分为：形式化语言（Formal Languages）和非形式化语言（Informal Languages）。形式化语言的形式化表示一般使用数学中的集合和映射表示；非形式化语言一般都会有对应的非形式化的执行语义（即用自然语言说明语言中各种操作的含义，例如普通的C语言）。
按照使用范围会有针对嵌入式系统的建模语言（VHDL）、针对需求的建模语言（UML）、针对算法的建模语言（程序流程图）等等。
还有其他按照各种方法的各种分类，例如同步建模语言、异步建模语言、全局异步局部同步建模语言。我知道的并不全面，每次和大牛交流都感觉到自己的无知。
4.建模语言领域研究什么
如何在增加语言表达能力和易用性同时不影响语言其他方面的性质（语法的简洁性等）。例如图灵机中是没有整形变量的表示的，我们能看到的只有0/1的纸带。因此汇编、C等加入了各种数据结构，但是其需要解释的语义就更复杂了。相比之下Lisp的语法语义就比较简洁。
如何针对特定领域对语言进行封装优化。近些年比较火热的领域特定语言（DSL）目的就是如此。
如何能够支持模型的性质检测。可以参考模型检测领域（Model Checking）的相关知识。
如何能够用建模的模型生成一些代码，即用建模语言作为一种编程语言。这样要求建模语言要有和生成代码使用语言的比较优势（较少的代码量、简洁清晰的语义、更简单的并行并发描述等）。这种使用方式有一个相关概念：模型驱动的开发。
下面的 #5 内容会和 #4 没有那么正交，请海涵。
5.建模语言领域能够贡献的工作
写一种全新的建模语言。嗯，这个一般都是持续N（>10）年的工作。
在一种建模语言基础上添加/封装一些操作符，从而对一些被建模对象的行为提供直接支持（例如支持建模buffered signal transmission）。DSL。
把两种建模语言整合起来。比较难，需要用更低级的语言解释两者语义，以及其他一大堆问题需要处理。
对指定的建模语言生成另一种语言的代码。例如：C to Verilog，Esterel to C等。
给建模语言建立的模型写simulator，即解释建模语言的执行语义。
给建模语言写图形化的编辑器，例如Visual Studio中的GUI绘制工具。
等等一系列，一系列。
6.我在做啥
最近在做对增加了时间表示的BIP模型和增加了时间表示的Esterel模型二者混合模型的执行语义解释。现在正处于用Clojure写没有时间表示的BIP模型执行语义解释的地步。
最近在做把BIP模型生成的代码转化成C语言代码，然后在ARM板卡上执行的流程探索。这条路已经基本走通，我能说今天中午什么事都没有做，然后之前bug的程序就能够在ARM板卡上运行了么。这真是上天不负有（gou）心（shi）人（yun）啊。</div><div><a class="read-more button" href=/2013/05/28/2013-05-28_%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2013/03/27/2013-03-27_archlinux_install_notes/>Archlinux Install Notes</a></h1><div class=post-meta><span class=post-date>2013-03-27</span></div><div class=post-content>分区格式化 cfdisk mkfs.ext /dev/sda* mkswap /dev/sdaX swapon /dev/sdaX
挂载当前分区 检查当前磁盘的标识符和布局 lsblk /dev/sda mount /dev/sda1 /mnt mkdir /mnt/home 如果是home独立分区 mount /dev/sda2 /mnt/home
编辑 /etc/pacman.d/mirrorlist 更新 pacman -Syy
使用pacstrap脚本安装基本系统
pacstrap /mnt base base-devel 如果 pacman 报告安装时遇到错误的签名(error: failed to commit transaction (invalid or corrupted package))，请运行如下命令：
pacman-key –init && pacman-key –populate archlinux base 来自 [core] 软件源的最小基本系统。 base-devel 来自 [core] 的附加工具例如make和 automake。大部分新手都应该安装它，后续扩展系统会用到它，安装AUR中软件包时，base-devel也是必须的
生成 fstab
用下面命令生成 fstab。如果想使用 UUIDs，使用 -U 选项；如果想使用标签，用 -L 选项，完成后最好检查一下生成的/etc/fstab。 Note: 后面如果出现问题，请不要再次运行genfstab，如果需要，手动编辑/etc/fstab。
genfstab -U -p /mnt | sed ’s/rw,relatime,data=ordered/defaults,relatime/’ >> /mnt/etc/fstab nano /mnt/etc/fstab Chroot 到新系统</div><div><a class="read-more button" href=/2013/03/27/2013-03-27_archlinux_install_notes/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2012/11/13/2012-11-13_python%E4%BD%BF%E7%94%A8smtplib%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/>Python使用smtplib发送邮件</a></h1><div class=post-meta><span class=post-date>2012-11-13</span></div><div class=post-content>from smtplib import SMTP
#这些库是邮件格式使用的 from email.mime.text import MIMEText from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart
smtp = SMTP()
smtp.connect(‘smtp.163.com’)
#这句话是必不可少的 smtp.helo()
#选择认证方式 smtp.esmtp_features[‘auth’] = ‘LOGIN’ smtp.login(’####@163.com’, ‘password’)
message = MIMEMultipart() message.attach(MIMEText(‘content’)) message[“Subject”] = ‘subject’
smtp.sendmail(’####@163.com’, [‘mail_to@163.com’], message.as_string())
差不多邮件这样就可以发送出去了</div><div><a class="read-more button" href=/2012/11/13/2012-11-13_python%E4%BD%BF%E7%94%A8smtplib%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2012/11/12/2012-11-12_%E5%9F%BA%E4%BA%8Eopenshift%E6%90%AD%E5%BB%BAmediawiki/>基于OpenShift搭建MediaWiki</a></h1><div class=post-meta><span class=post-date>2012-11-12</span></div><div class=post-content>1.按照OpenShift建立用用的过程新建一个PHP 5.3应用，可以通过网页方式创建（推荐）；本地完成一些初始化工作（参考官方教程）
2.按照应用页面给出的git地址，把代码库clone到本地，然后把MediaWiki代码push到Master库中。（git使用方法）
3.在应用页面点击那个“Add a Cartridge”，然后加上一个MySql数据库（应该是这样，我在命令行中添加的）和一个phpMyAdmin；把获得的数据库root用户名和密码记下来； 但是如何重新访问这些Cartridge，我还不知道啊，也许从命令行可以过去。
4.进入phpMyAdmin进行管理，左上方有MediaWiki连接数据库要使用的数据库地址（这个地方寻找地址卡了好久，直到安装了phpMyAdmin才得到的sql连接地址，应该还有其他方法的）
5.进入应用URL进行MediaWiki的初始化工作，剩下的就很简单了</div><div><a class="read-more button" href=/2012/11/12/2012-11-12_%E5%9F%BA%E4%BA%8Eopenshift%E6%90%AD%E5%BB%BAmediawiki/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2012/08/19/2012-08-19_spin%E5%B7%A5%E5%85%B7%E7%9A%84eclipse%E9%9B%86%E6%88%90/>Spin工具的Eclipse集成</a></h1><div class=post-meta><span class=post-date>2012-08-19</span></div><div class=post-content>Spin是Promela建模语言的解释器和验证工具。它本身有一个图形化的工具iSpin，不过这个图形化实在有些简陋。下面介绍一个Eclipse的插件，这样我们可以使用Eclipse的编辑环境来使用Spin。
首先，在Eclipse的install new software中添加 <a href=http://matrix.uni-mb.si/fileadmin/datoteke/znanost/orodja/ep4s/update-site/>http://matrix.uni-mb.si/fileadmin/datoteke/znanost/orodja/ep4s/update-site/</a> 把Group items by category选项去掉，否则看不到可安装的插件；安装此插件。
然后，在菜单栏中选择Spin项，进入Spin Configuration，
Spin工具可以从其官网下载。
C Complier里的gcc可以用cygwin安装，记得选择直接的版本，不要选择gcc.exe，否则可能出现不能验证通过的错误。
基本上这样就算安装完成了，如果你有什么问题，可以给我留言。</div><div><a class="read-more button" href=/2012/08/19/2012-08-19_spin%E5%B7%A5%E5%85%B7%E7%9A%84eclipse%E9%9B%86%E6%88%90/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2012/06/28/2012-06-28_%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E4%BA%BA%E4%BA%BA%E7%BD%91%E7%9A%84%E8%AE%BF%E9%97%AE%E9%87%8F/>如何增加人人网的访问量</a></h1><div class=post-meta><span class=post-date>2012-06-28</span></div><div class=post-content>主要是利用人们的好奇心吸引回访。
用爬虫去爬去一定数量的好友列表，获得一定数量的id文件。 用自己的帐号认证，然后从id文件中取得一个id，然后访问他的页面。 当访问的页面到达一定规模的时候，在这么多人里肯定有些人很好奇想要看看你是谁，然后就点回你的页面。 访问量和好友申请就飕飕涨了。</div><div><a class="read-more button" href=/2012/06/28/2012-06-28_%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E4%BA%BA%E4%BA%BA%E7%BD%91%E7%9A%84%E8%AE%BF%E9%97%AE%E9%87%8F/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2012/06/17/2012-06-17_eclipse%E5%AF%BC%E5%85%A5github%E5%BA%93/>Eclipse导入Github库</a></h1><div class=post-meta><span class=post-date>2012-06-17</span></div><div class=post-content>导入要点
使用HTTPS的方式会容易一些，SSH的方式会有一些认证问题（这个极有可能是伪命题，因为第2条的原因） 先通过命令行把库拖下来，最好不要放在eclipse的workplace中 然后新建一个项目，在Team|Share|…|Git一路选下去就好 （这个日志需要重新更改）</div><div><a class="read-more button" href=/2012/06/17/2012-06-17_eclipse%E5%AF%BC%E5%85%A5github%E5%BA%93/>→</a></div></div><div class=pagination><div class=pagination__buttons><span class="button previous"><a href=/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/page/2/><span class=button__icon>←</span>
<span class=button__text>Newer posts</span></a></span>
<span class="button next"><a href=/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/page/4/><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>