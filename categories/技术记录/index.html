<!doctype html><html lang=en><head><title>技术记录 :: 不是追风少年</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/><link rel=stylesheet href=https://blog.formalscience.com/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://blog.formalscience.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://blog.formalscience.com/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="技术记录"><meta property="og:description" content><meta property="og:url" content="https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/"><meta property="og:site_name" content="不是追风少年"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/index.xml rel=alternate type=application/rss+xml title=不是追风少年></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.formalscience.com/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/>Go to Rust （一）</a></h1><div class=post-meta><span class=post-date>2018-12-26</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>Golang</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/rust/>Rust</a>&nbsp;</span><div class=post-content>这几天看了 Rust 文档，把一些概念整理一下。
通过 cargo 新建一个项目，然后去管理其生命流程，这种现代做法很方便。 对于 statement 和 expression 的使用方式和 scheme 有些类似，可以返回最后一个 expression 的值。 可能返回错误的地方使用 Result 类型，很类似 Haskell 的处理流程。 模式匹配的方式很像 Ocaml 。 ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。 Option 类型就是 Haskell 的 Maybe 。 generics 的设计不知道有没有参考 C++ 的 template 概念。 目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。</div><div><a class="read-more button" href=/2018/12/26/2018-12-26-go-to-rust/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/12/13/2018-12-13-pip-install-package-offline/>pip 离线安装包</a></h1><div class=post-meta><span class=post-date>2018-12-13</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/python/>python</a>&nbsp;</span><div class=post-content><ol><li>使用场景 在没有网络的设备上使用 pip 安装包。下面以 sklearn 包为例展示如何在没有网络的环境下安装包。</li><li>下载包到本地缓存 首先进入一个目录，在这个例子里是 /Users/bef0rewind/Downloads/pip-tmp 目录。
pip download sklearn 我这里下载到了一个缓存目录 /Users/bef0rewind/Downloads/pip-tmp，随便选一个就好。pip download 只会下载对应的包，不会进行安装。
此时使用，pip freeze 可以看到已经安装的包，如果之前没有安装过 sklearn，显示的列表里是没有这个包的。</li><li>断网安装 为了展示没有网络的情况下如何安装，我断开网络进行了验证。
pip install &ndash;no-index &ndash;find-links=/Users/bef0rewind/Downloads/pip-tmp sklearn 其中 &ndash;find-links 要 pip 从指定的目录里寻找安装包。</li><li>其他 如果要用 Python3，而系统默认的版本是 Python 2，则可以将 pip 命令换成 pip3。</li></ol></div><div><a class="read-more button" href=/2018/12/13/2018-12-13-pip-install-package-offline/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/>Escape from escape analysis</a></h1><div class=post-meta><span class=post-date>2018-11-30</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>golang</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/programming-language/>programming language</a>&nbsp;</span><div class=post-content><ol><li>逃逸分析背景 Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。 特点是全局停顿时间比较少，在一些场景下是十微秒级别的。
垃圾回收算法针对的是堆（heap）中的内存。 为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。 这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。
而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。 如这篇文章《Golang escape analysis》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。
对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。 这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。</li><li>Go 版本 使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。
ThinkPad-X1-Carbon:bin bef0rewind$ ./go version go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64 3. 示例 // file: escape.go package main import "fmt" type BigTempObject struct { /// &mldr; field1 int } func causeEscape(i interface{}) { switch i.</li></ol></div><div><a class="read-more button" href=/2018/11/30/2018-11-30-escape-from-escape-analysis/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/>Golang Receiver Type 探索</a></h1><div class=post-meta><span class=post-date>2018-11-21</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>golang</a>&nbsp;
#<a href=https://blog.formalscience.com/tags/programming-language/>programming language</a>&nbsp;</span><div class=post-content><ol><li>参考 在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。
<a href=https://golang.google.cn/ref/spec#Method_sets>https://golang.google.cn/ref/spec#Method_sets</a> <a href=https://golang.google.cn/ref/spec#Types>https://golang.google.cn/ref/spec#Types</a> <a href=https://golang.google.cn/ref/spec#Struct_types>https://golang.google.cn/ref/spec#Struct_types</a> <a href=https://golang.google.cn/ref/spec#Composite_literals>https://golang.google.cn/ref/spec#Composite_literals</a> 核心的概念是 method sets：
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T).</li></ol></div><div><a class="read-more button" href=/2018/11/21/2018-11-21-golang-receiver-type/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/08/21/2018-08-21_golang_exception_handling/>defer, panic and recover in Golang</a></h1><div class=post-meta><span class=post-date>2018-08-21</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/golang/>golang</a>&nbsp;</span><div class=post-content><ol><li>什么是异常处理 程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。 一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 try/catch/finally 机制（https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、 Python 的 try/raise/except/finally 机制（https://docs.python.org/3/tutorial/errors.html）等。</li><li>Go 语言中的异常处理机制 Go 语言中使用的是 defer/panic/recover 机制来处理异常。Go 语言官方博客的《Defer, Panic, and Recover》讲述了这个机制的具体应用方式。
还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：
The Right Places To Call The recover Function：https://go101.org/article/panic-and-recover-more.html ，几种使用 recover 恢复 Go 语言中 panic 的适用场景 7.异常处理：https://www.kancloud.cn/liupengjie/go/578555 ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节 如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 defer + recover 处理一个 panic，defer 结构要在 panic 触发之前被定义而且 recover 要直接在在 defer 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。</li><li>defer 语法糖的部分原理 在讲述 defer 机制的文章中，都会提到一个函数中多个 defer 结构执行的顺序和定义顺序是相反的，即后定义的 defer 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：
func g(n int) { println(n) } func h(str string) { println(str) } func f() { defer g(0) defer h("h") } 调用 f 输出为：</li></ol></div><div><a class="read-more button" href=/2018/08/21/2018-08-21_golang_exception_handling/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/07/22/2018-07-22_commands/>Useful Commands</a></h1><div class=post-meta><span class=post-date>2018-07-22</span></div><div class=post-content>Convert images to a video ffmpeg -r 30 -start_number 3455 -i _IMG%d.jpg -s 960X600 -pix_fmt yuv420p 30fps-960.mov -r 30: 30 frames per second -s 960X600: resolution -pix_fmt yuv420p: for OsX youtube-dl video and extract audio file youtube-dl &ndash;proxy socks5://127.0.0.1:1080 -x &ndash;audio-format mp3 youtube-url
virtualenvwrapper WORKON_HOME: which directory your environments are created in /usr/local/bin/virtualenvwrapper.sh: default location for its configuration file mkvirtualenv test &ndash;python=python3: make a virtual environment ’test’ with python3 rmvirtualenv test: remove a virtual environment ’test&rsquo; workon test3 or lsvirtualenv -b test3: activate a virtual environment ’test&rsquo; deactivate: exit current environment more details: search engine how to avoid globa packages how to copy an environment node && npm npm complains: Error: Cannot find module &lsquo;process-nextick-args&rsquo;</div><div><a class="read-more button" href=/2018/07/22/2018-07-22_commands/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/06/23/2018-06-23_update_vps_ubuntu_version/>Upgrade DigitalOcean&rsquo;s Ubuntu 17.04 to LTS version in 2018-06</a></h1><div class=post-meta><span class=post-date>2018-06-23</span></div><div class=post-content>What happened? I found my proxy for accessing some websites stopped working today, so I had to change my VPS’s IP address. After some trials, everything seemed OK and I started watching a skiing video made by NorthFace on Youtube.
Emmmm, I noticed 12 packages needed to be updated. Well, I typed sudo apt-get update and got messages like this (I didn’t save the error messages then):
404 Not Found [IP: 91.</div><div><a class="read-more button" href=/2018/06/23/2018-06-23_update_vps_ubuntu_version/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/>理解 C++ Traits</a></h1><div class=post-meta><span class=post-date>2018-05-12</span></div><div class=post-content>C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 type_relation 的成员 relation 获取比较结果。当前代码输出：
type_relation&lt;bool, int>: different type_relation&lt;int, int>: different 这段代码并未实现预期功能，因为比较 bool 和 int，以及 int 和 int 时，都输出 "different" 。下面继续完善这个 trait 实现。</div><div><a class="read-more button" href=/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/21/2018-01-21_how-does-monero-work-%E7%AC%94%E8%AE%B0/>‘How Does Monero Work?&rsquo; 笔记</a></h1><div class=post-meta><span class=post-date>2018-01-21</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/note/>note</a>&nbsp;</span><div class=post-content>Monero 门罗币的一个介绍视频
我刚买到 1070Ti 显卡时曾经想要挖过这个币，后来放弃了，觉得没有意义。不过了解这个技术的一些原理还是有价值的。
Siraj Raval 的免责声明： 
Monero 是一种不可追踪的加密货币，网络上很多非法买卖东西的人会使用它。他介绍这个技术的原因是：你应当对你的数据有控制权，而很多数据是交易数据（transactional data）。目前很多公司可以从中免费挖掘信息，用来预测你的购买行为，以便向你展示广告。理想情况下他们应当为你的数据付费，而他们付费的唯一可能是你控制着数据，而唯一控制数据的方式为数据是匿名的。为了查阅你的交易历史，</div><div><a class="read-more button" href=/2018/01/21/2018-01-21_how-does-monero-work-%E7%AC%94%E8%AE%B0/>→</a></div></div><div class="post on-list"><h1 class=post-title><a href=https://blog.formalscience.com/2018/01/17/2018-01-17_%E4%B8%A4%E4%B8%AA%E7%8E%BB%E7%92%83%E7%90%83%E7%BD%91%E4%B8%8A%E6%B5%81%E4%BC%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/>两个玻璃球（网上流传的面试题）</a></h1><div class=post-meta><span class=post-date>2018-01-17</span></div><span class=post-tags>#<a href=https://blog.formalscience.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/>面试题</a>&nbsp;</span><div class=post-content>据说这是 Google 的一个面试题：
有一栋 100 层高的大楼，有两个完全相同的玻璃球。假设从某一层开始丢下玻璃球会摔碎，利用手中的两个玻璃球确定是第几层。最少扔几次玻璃球可以确定这个临界楼层（玻璃球在这一层以及更高的楼层扔下会摔碎）？
就如孔子说过的那句名言 “I Never Said All That Shit” 一样，这个题目出自哪里我也没有去考证。下面把我的思路整理一下。
如果只有一个玻璃球，能做的就是从 1 层开始尝试扔下玻璃球，然后尝试 2 层、3 层 ……，直到某一层扔下玻璃球后摔碎。而现在有两个玻璃球，我们可以用一个玻璃球从 1 层、11 层、21 层 …… 扔下去，确定一个较小的破碎范围，然后使用第二个玻璃球确定具体的楼层。
假如总共 N 层，我们从第 X 层扔下第一个玻璃球，有两种可能性：玻璃球摔碎或者没碎。如果玻璃球摔碎，说明临界楼层在 1~X 中；如果没摔碎，则临界楼层在 X+1~N 中。
如果临界楼层在 1~N 中是均匀分布的，那么 $N > 2$ 时确定临界楼层需要扔玻璃球的最少次数可以由以下公式表示：
$$ f(N)= \min_{X \in [1, N]} {1 + f(N-X)\frac{N-X}{N} + g(X)\frac{X}{N}} $$
$f(N)$ 为使用两个玻璃球确定区间长度为 N 时的临界楼层所用次数，$g(X)$ 为使用一个玻璃球确定区间长度为 N 时的临界楼层所用次数。这个公式的三部分分别对应：
一次扔玻璃球的尝试 玻璃球未摔碎概率$\times$此时继续尝试需要的次数 $f(N-X)$（两个玻璃球） 玻璃球摔碎概率$\times$此时继续尝试需要的次数 $g(X)$（一个玻璃球）。 显然有 $f(1)=0$，$g(N)=N-1$。可以用动态规划求解 $N=100$ 时需要的最少次数。</div><div><a class="read-more button" href=/2018/01/17/2018-01-17_%E4%B8%A4%E4%B8%AA%E7%8E%BB%E7%92%83%E7%90%83%E7%BD%91%E4%B8%8A%E6%B5%81%E4%BC%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/>→</a></div></div><div class=pagination><div class=pagination__buttons><span class="button next"><a href=/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/page/2/><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://blog.formalscience.com/assets/main.js></script>
<script src=https://blog.formalscience.com/assets/prism.js></script></div></body></html>