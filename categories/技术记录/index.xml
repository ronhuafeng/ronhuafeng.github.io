<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术记录 on 不是追风少年</title><link>https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/</link><description>Recent content in 技术记录 on 不是追风少年</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 26 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/index.xml" rel="self" type="application/rss+xml"/><item><title>Go to Rust （一）</title><link>https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/</link><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/</guid><description>这几天看了 Rust 文档，把一些概念整理一下。
通过 cargo 新建一个项目，然后去管理其生命流程，这种现代做法很方便。 对于 statement 和 expression 的使用方式和 scheme 有些类似，可以返回最后一个 expression 的值。 可能返回错误的地方使用 Result 类型，很类似 Haskell 的处理流程。 模式匹配的方式很像 Ocaml 。 ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。 Option 类型就是 Haskell 的 Maybe 。 generics 的设计不知道有没有参考 C++ 的 template 概念。 目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。</description><content>&lt;p>这几天看了 Rust 文档，把一些概念整理一下。&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>cargo&lt;/code> 新建一个项目，然后去管理其生命流程，这种现代做法很方便。&lt;/li>
&lt;li>对于 &lt;code>statement&lt;/code> 和 &lt;code>expression&lt;/code> 的使用方式和 scheme 有些类似，可以返回最后一个 &lt;code>expression&lt;/code> 的值。&lt;/li>
&lt;li>可能返回错误的地方使用 &lt;code>Result&lt;/code> 类型，很类似 Haskell 的处理流程。&lt;/li>
&lt;li>模式匹配的方式很像 Ocaml 。&lt;/li>
&lt;li>ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。&lt;/li>
&lt;li>&lt;code>Option&lt;/code> 类型就是 Haskell 的 &lt;code>Maybe&lt;/code> 。&lt;/li>
&lt;li>generics 的设计不知道有没有参考 C++ 的 template 概念。&lt;/li>
&lt;/ul>
&lt;p>目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。&lt;/p></content></item><item><title>pip 离线安装包</title><link>https://blog.formalscience.com/2018/12/13/2018-12-13-pip-install-package-offline/</link><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/12/13/2018-12-13-pip-install-package-offline/</guid><description>1. 使用场景 在没有网络的设备上使用 pip 安装包。下面以 sklearn 包为例展示如何在没有网络的环境下安装包。
2. 下载包到本地缓存 首先进入一个目录，在这个例子里是 /Users/bef0rewind/Downloads/pip-tmp 目录。
pip download sklearn 我这里下载到了一个缓存目录 /Users/bef0rewind/Downloads/pip-tmp，随便选一个就好。pip download 只会下载对应的包，不会进行安装。
此时使用，pip freeze 可以看到已经安装的包，如果之前没有安装过 sklearn，显示的列表里是没有这个包的。
3. 断网安装 为了展示没有网络的情况下如何安装，我断开网络进行了验证。
pip install --no-index --find-links=/Users/bef0rewind/Downloads/pip-tmp sklearn 其中 --find-links 要 pip 从指定的目录里寻找安装包。
4. 其他 如果要用 Python3，而系统默认的版本是 Python 2，则可以将 pip 命令换成 pip3。</description><content>&lt;h2 id="1-使用场景">1. 使用场景&lt;/h2>
&lt;p>在没有网络的设备上使用 pip 安装包。下面以 &lt;code>sklearn&lt;/code> 包为例展示如何在没有网络的环境下安装包。&lt;/p>
&lt;h2 id="2-下载包到本地缓存">2. 下载包到本地缓存&lt;/h2>
&lt;p>首先进入一个目录，在这个例子里是 &lt;code>/Users/bef0rewind/Downloads/pip-tmp&lt;/code> 目录。&lt;/p>
&lt;pre tabindex="0">&lt;code>pip download sklearn
&lt;/code>&lt;/pre>&lt;p>我这里下载到了一个缓存目录 &lt;code>/Users/bef0rewind/Downloads/pip-tmp&lt;/code>，随便选一个就好。&lt;code>pip download&lt;/code> 只会下载对应的包，不会进行安装。&lt;/p>
&lt;p>此时使用，&lt;code>pip freeze&lt;/code> 可以看到已经安装的包，如果之前没有安装过 &lt;code>sklearn&lt;/code>，显示的列表里是没有这个包的。&lt;/p>
&lt;h2 id="3-断网安装">3. 断网安装&lt;/h2>
&lt;p>为了展示没有网络的情况下如何安装，我断开网络进行了验证。&lt;/p>
&lt;pre tabindex="0">&lt;code>pip install --no-index --find-links=/Users/bef0rewind/Downloads/pip-tmp sklearn
&lt;/code>&lt;/pre>&lt;p>其中 &lt;code>--find-links&lt;/code> 要 &lt;code>pip&lt;/code> 从指定的目录里寻找安装包。&lt;/p>
&lt;h2 id="4-其他">4. 其他&lt;/h2>
&lt;p>如果要用 Python3，而系统默认的版本是 Python 2，则可以将 &lt;code>pip&lt;/code> 命令换成 &lt;code>pip3&lt;/code>。&lt;/p></content></item><item><title>Escape from escape analysis</title><link>https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/</guid><description>1. 逃逸分析背景 Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。 特点是全局停顿时间比较少，在一些场景下是十微秒级别的。
垃圾回收算法针对的是堆（heap）中的内存。 为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。 这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。
而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。 如这篇文章《Golang escape analysis》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。
对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。 这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。
2. Go 版本 使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。
ThinkPad-X1-Carbon:bin bef0rewind$ ./go version go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64 3. 示例 // file: escape.go package main import &amp;#34;fmt&amp;#34; type BigTempObject struct { /// ... field1 int } func causeEscape(i interface{}) { switch i.</description><content>&lt;h2 id="1-逃逸分析背景">1. 逃逸分析背景&lt;/h2>
&lt;p>Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。
特点是全局停顿时间比较少，在一些场景下是十微秒级别的。&lt;/p>
&lt;p>垃圾回收算法针对的是堆（heap）中的内存。
为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。
这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。&lt;/p>
&lt;p>而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。
如这篇文章《&lt;a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">Golang escape analysis&lt;/a>》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。&lt;/p>
&lt;p>对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。
这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。&lt;/p>
&lt;h2 id="2-go-版本">2. Go 版本&lt;/h2>
&lt;p>使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。&lt;/p>
&lt;pre tabindex="0">&lt;code>ThinkPad-X1-Carbon:bin bef0rewind$ ./go version
go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64
&lt;/code>&lt;/pre>&lt;h2 id="3-示例">3. 示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// file: escape.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">field1&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>.(&lt;span style="color:#66d9ef">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">addrObj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">addrObj&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>go run -gcflags=&amp;quot;-m -m&amp;quot; escape.go&lt;/code> 可以在运行时输出逃逸分析的结果。&lt;/p>
&lt;pre tabindex="0">&lt;code>./escape.go:10: cannot inline causeEscape: unhandled op TYPESW
./escape.go:19: cannot inline main: non-leaf function
./escape.go:10: leaking param: i
./escape.go:10: from ... argument (arg to ...) at ./escape.go:15
./escape.go:10: from *(... argument) (indirection) at ./escape.go:15
./escape.go:10: from ... argument (passed to call[argument content escapes]) at ./escape.go:15
./escape.go:15: causeEscape ... argument does not escape
./escape.go:23: addrObj escapes to heap
./escape.go:23: from addrObj (passed to call[argument escapes]) at ./escape.go:23
./escape.go:21: &amp;amp;obj escapes to heap
./escape.go:21: from addrObj (assigned) at ./escape.go:21
./escape.go:21: from addrObj (interface-converted) at ./escape.go:23
./escape.go:21: from addrObj (passed to call[argument escapes]) at ./escape.go:23
./escape.go:20: moved to heap: obj
(0x10904e0,0xc420080050)
&lt;/code>&lt;/pre>&lt;p>&lt;code>obj&lt;/code> 可以分配在栈上，因为在 &lt;code>main&lt;/code> 函数返回时（栈退出），这个变量占用的空间就可以安全被用在其他地方了。
但是 “./escape.go:20: moved to heap: obj” 说明 &lt;code>obj&lt;/code> 被分配在了堆上。&lt;/p>
&lt;h2 id="4-小技巧">4. 小技巧&lt;/h2>
&lt;p>如何改变这个分析结果，需要一点小技巧。&lt;/p>
&lt;p>关键词是 &lt;code>uintptr&lt;/code> 类型。
Go 语言中对 &lt;code>uintptr&lt;/code> 是这样描述的：&lt;/p>
&lt;blockquote>
&lt;p>uintptr is an integer type that is large enough to hold the bit pattern of any pointer.&lt;/p>
&lt;/blockquote>
&lt;p>比如在 64-bit Linux 系统上 &lt;code>uintptr&lt;/code> 被定义成为了 &lt;code>uint64&lt;/code>。
Go 中合法的类型转换为：&lt;code>normal pointer&lt;/code> ⟷ &lt;code>unsafe.Pointer&lt;/code> ⟷ &lt;code>uintptr&lt;/code> 。
因此我们可以把上面的程序中的 &lt;code>addrObj&lt;/code> 转换为 &lt;code>uintptr&lt;/code>。
这样 Go 编译器不再认为 &lt;code>addrObj&lt;/code> 同后面函数 &lt;code>causeEscape&lt;/code> 使用的参数 &lt;code>i&lt;/code> 存在引用关系，从而绕过 Escape Analysis Algorithm 。
为了防止垃圾回收过程中 &lt;code>obj&lt;/code> 被回收，可以使用 &lt;code>obj.field1 = 0&lt;/code> 来保持 &lt;code>obj&lt;/code> 活跃。&lt;/p>
&lt;p>修改后的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">field1&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>.(&lt;span style="color:#66d9ef">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">addrObj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">intAddr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> uintptr(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">addrObj&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>((&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">intAddr&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span>.&lt;span style="color:#a6e22e">field1&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>go run -gcflags=&amp;quot;-m -m&amp;quot; escape.go&lt;/code> 运行结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>./escape.go:13: cannot inline causeEscape: unhandled op TYPESW
./escape.go:22: cannot inline main: non-leaf function
./escape.go:13: leaking param: i
./escape.go:13: from ... argument (arg to ...) at ./escape.go:18
./escape.go:13: from *(... argument) (indirection) at ./escape.go:18
./escape.go:13: from ... argument (passed to call[argument content escapes]) at ./escape.go:18
./escape.go:18: causeEscape ... argument does not escape
./escape.go:26: (*BigTempObject)(unsafe.Pointer(intAddr)) escapes to heap
./escape.go:26: from (*BigTempObject)(unsafe.Pointer(intAddr)) (passed to call[argument escapes]) at ./escape.go:26
./escape.go:24: main &amp;amp;obj does not escape
(0x10904e0,0xc42003bf70)
&lt;/code>&lt;/pre>&lt;p>可以看到 &lt;code>obj&lt;/code> 不再逃逸，主要是 &lt;code>intAddr&lt;/code> 中断了逃逸分析算法构建的指针依赖关系（表示为一个有向图）。&lt;/p>
&lt;h2 id="5-一点感想">5. 一点感想&lt;/h2>
&lt;p>我们可以做到不代表一定去做，有风险也不代表禁区，采取什么样的行动是个人权衡后的选择。&lt;br>
什么原因导致了人们做了不同的选择，而人们不同的选择又导致了什么结果？&lt;br>
多样性是这个世界的现状，黑暗面与光明面同在。
May the force be with you.&lt;/p></content></item><item><title>Golang Receiver Type 探索</title><link>https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/</link><pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/</guid><description>1. 参考 在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。
https://golang.google.cn/ref/spec#Method_sets https://golang.google.cn/ref/spec#Types https://golang.google.cn/ref/spec#Struct_types https://golang.google.cn/ref/spec#Composite_literals 核心的概念是 method sets：
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T).</description><content>&lt;h2 id="1-参考">1. 参考&lt;/h2>
&lt;p>在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Method_sets">https://golang.google.cn/ref/spec#Method_sets&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Types">https://golang.google.cn/ref/spec#Types&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Struct_types">https://golang.google.cn/ref/spec#Struct_types&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Composite_literals">https://golang.google.cn/ref/spec#Composite_literals&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>核心的概念是 method sets：&lt;/p>
&lt;blockquote>
&lt;p>A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). Further rules apply to structs containing embedded fields, as described in the section on struct types. Any other type has an empty method set. In a method set, each method must have a unique non-blank method name.&lt;/p>
&lt;p>The method set of a type determines the interfaces that the type implements and the methods that can be called using a receiver of that type.&lt;/p>
&lt;/blockquote>
&lt;p>下面的一些细节基本上都和这段描述相关。&lt;/p>
&lt;h2 id="2-duck-typing-与方法调用">2. Duck typing 与方法调用&lt;/h2>
&lt;p>在很多面向对象的语言中，一个对象都可以“拥有”一些方法，使用例如 &lt;code>obj.f(a, b, c)&lt;/code> 的形式进行调用。结合语言的类型系统，通过“扩展”、“继承”、“实现”等术语，我们可以将不同的类组织起来。在 Go 语言中采用的是 “duck typing”，没有显式的类型关系定义关键字。当一个类型实现了一个接口的全部方法时，那这个类型就被视为实现了这个接口。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Duck&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bark&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">A&lt;/span>) &lt;span style="color:#a6e22e">Bark&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">iA&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">A&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#a6e22e">iA&lt;/span>).(&lt;span style="color:#a6e22e">Duck&lt;/span>); &lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;A{} is Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;A{} is not Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">iB&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">B&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#a6e22e">iB&lt;/span>).(&lt;span style="color:#a6e22e">Duck&lt;/span>); &lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;B{} is Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;B{} is not Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>&amp;amp;A{} is Duck
&amp;amp;B{} is not Duck
&lt;/code>&lt;/pre>&lt;p>我们可以用原始的类型去调用一个方法，也可以使用一个接口去调用方法。这里就涉及到方法调用者的问题：什么样的对象是一个合法的方法调用者？&lt;/p>
&lt;p>至少 &lt;code>A{}&lt;/code> 不是，因为我们实现 &lt;code>Duck&lt;/code> 接口的时候，使用的是 &lt;code>func (*A) Bark()&lt;/code> 进行的定义，而非 &lt;code>func (A) Bark()&lt;/code>。这样就导致了只有 &lt;code>A&lt;/code> 类型对象的指针类型才能作为方法调用者去调用 &lt;code>Bark&lt;/code> 方法。&lt;/p>
&lt;h2 id="3-成员函数的参数">3. 成员函数的参数&lt;/h2>
&lt;p>在实现中，调用某个类型的成员方法，第一个参数其实是这个方法的实现对象自身，即如果是一个指针的方法，就是这个指针的值，如果是一个对象，就是这个对象的值。&lt;/p>
&lt;p>下面使用 Go 1.8.3 展示，因为当前最新的 Go 编译器在打印 stack trace 的时候不再打印函数的参数（这个例子中）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">r&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>0xc420039f70
received 1
panic: just a panic
goroutine 1 [running]:
main.(*R1).f(0xc420039f70, 0x1)
/Users/bef0rewind/Projects/net example/src/main/receiver_type.go:9 +0xa3
main.main()
/Users/bef0rewind/Projects/net example/src/main/receiver_type.go:16 +0x5a
&lt;/code>&lt;/pre>&lt;p>Stack trace 中函数 &lt;code>f&lt;/code> 第一个值是指针 &lt;code>r&lt;/code> 的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span>{&lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">r&lt;/span>).&lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>7
received 1
panic: just a panic
goroutine 1 [running]:
main.R1.g(0x7, 0x9, 0x1)
/Users/bef0rewind/Projects/net example/src/receiver_type/main/args.go:15 +0xa3
main.main()
/Users/bef0rewind/Projects/net example/src/receiver_type/main/args.go:22 +0x58
&lt;/code>&lt;/pre>&lt;p>Stack trace 中函数 &lt;code>g&lt;/code> 第一个值是 &lt;code>r&lt;/code> 的值 &lt;code>7&lt;/code> 和 &lt;code>9&lt;/code>。&lt;/p>
&lt;p>从这个实现方式中我们可以推断以下几点：&lt;/p>
&lt;ul>
&lt;li>Go 语言采用参数传值的方式进行函数调用，因此如果对象很大，使用的对象本身调用函数会带来大量的复制&lt;/li>
&lt;li>不可能在函数调用中改变函数外的调用者，因为传到函数内部的只是调用者的副本&lt;/li>
&lt;/ul>
&lt;h2 id="4-使用接口调用函数">4. 使用接口调用函数&lt;/h2>
&lt;p>基于这样的成员函数实现方式，我们可以尝试另外一种调用方式：使用接口类型调用一个函数。
这里不是将一个对象转换成特定的接口然后去调用函数，而是使用接口类型本身去进行函数调用。
这种方式在 Go 1.9 中开始支持，在 Go 1.10 开始写入 Go 的 specs。这个例子使用的是 Go master 分支的版本，可能是 Go 1.11。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">M&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;I;m M, with&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">IM&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">IM&lt;/span>.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>I;m M, with 7
&lt;/code>&lt;/pre>&lt;p>此外还能使用匿名接口类型去调用函数，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">M&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;I;m M, with&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">interface&lt;/span>{&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)}.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果与上面的一段采用 &lt;code>IM&lt;/code> 接口定义的例子是一样的。&lt;/p>
&lt;h2 id="5-注入依赖">5. 注入依赖&lt;/h2>
&lt;p>有时候一个对象在实例化的时候，它的一些成员方法的行为可能还没有确定，需要依赖外界注入。此时我们可以在对象类型定义中内嵌一个接口，然后在后期传入一个接口的实例来确定其行为。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BinaryOp&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ComputeNode&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">BinaryOp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>) &lt;span style="color:#a6e22e">Result&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span>.&lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">y&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Add&lt;/span>) &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Multi&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Multi&lt;/span>) &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>{&lt;span style="color:#a6e22e">x&lt;/span>:&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Add&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Multi&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>5
6
&lt;/code>&lt;/pre>&lt;p>注意一定要记得传入接口的实例，在这个例子中如果不给 &lt;code>node&lt;/code> 传入一个 &lt;code>BinaryOp&lt;/code> 接口实例，那 &lt;code>node.BinaryOp&lt;/code> 是 &lt;code>nil&lt;/code>，在调用 &lt;code>Compute&lt;/code> 方法的时候就会发生异常。例如将上面的 &lt;code>main&lt;/code> 函数稍作修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>{&lt;span style="color:#a6e22e">x&lt;/span>:&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//node.BinaryOp = &amp;amp;Add{}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x104d8d7]
goroutine 1 [running]:
main.(*ComputeNode).Result(...)
/Users/bef0rewind/Projects/net example/src/receiver_type/main/injection.go:13
main.main()
/Users/bef0rewind/Projects/net example/src/receiver_type/main/injection.go:32 +0x47
&lt;/code>&lt;/pre>&lt;h2 id="6-内部机制">6. 内部机制&lt;/h2>
&lt;p>内部机制有一些细节。大体就是一个接口 &lt;code>i&lt;/code> 包含两部分内容（指针），一个是接口代表的方法的集合，一个实现这个接口的具体对象；而一个对象 &lt;code>obj&lt;/code>，它包含了自己的内存中的值，也能通过其类型获取到 &lt;code>obj&lt;/code> 实现的方法集合。&lt;/p>
&lt;p>将这两个概念记住，在实现一些模式的时候就会少很多心智负担。&lt;/p>
&lt;h2 id="7-总结">7. 总结&lt;/h2>
&lt;p>Go 语言的这套基于 “duck typing” 的机制好不好，争论有很多。不过我一向对这些争论没有特别的倾向，至少理解其机制之后按照其设计思路来用还可以正常使用，而且里面没有复杂的概念和例外情形。&lt;/p>
&lt;p>也许我的理解有偏差，但现在还没有发现什么矛盾的地方。&lt;/p></content></item><item><title>defer, panic and recover in Golang</title><link>https://blog.formalscience.com/2018/08/21/2018-08-21_golang_exception_handling/</link><pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/08/21/2018-08-21_golang_exception_handling/</guid><description>1. 什么是异常处理 程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。 一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 try/catch/finally 机制（https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、 Python 的 try/raise/except/finally 机制（https://docs.python.org/3/tutorial/errors.html）等。
2. Go 语言中的异常处理机制 Go 语言中使用的是 defer/panic/recover 机制来处理异常。Go 语言官方博客的《Defer, Panic, and Recover》讲述了这个机制的具体应用方式。
还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：
The Right Places To Call The recover Function：https://go101.org/article/panic-and-recover-more.html ，几种使用 recover 恢复 Go 语言中 panic 的适用场景 7.异常处理：https://www.kancloud.cn/liupengjie/go/578555 ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节 如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 defer + recover 处理一个 panic，defer 结构要在 panic 触发之前被定义而且 recover 要直接在在 defer 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。
3. defer 语法糖的部分原理 在讲述 defer 机制的文章中，都会提到一个函数中多个 defer 结构执行的顺序和定义顺序是相反的，即后定义的 defer 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：
func g(n int) { println(n) } func h(str string) { println(str) } func f() { defer g(0) defer h(&amp;#34;h&amp;#34;) } 调用 f 输出为：</description><content>&lt;h2 id="1-什么是异常处理">1. 什么是异常处理&lt;/h2>
&lt;p>程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。
一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 &lt;code>try&lt;/code>/&lt;code>catch&lt;/code>/&lt;code>finally&lt;/code> 机制（https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、
Python 的 &lt;code>try&lt;/code>/&lt;code>raise&lt;/code>/&lt;code>except&lt;/code>/&lt;code>finally&lt;/code> 机制（https://docs.python.org/3/tutorial/errors.html）等。&lt;/p>
&lt;h2 id="2-go-语言中的异常处理机制">2. Go 语言中的异常处理机制&lt;/h2>
&lt;p>Go 语言中使用的是 &lt;code>defer&lt;/code>/&lt;code>panic&lt;/code>/&lt;code>recover&lt;/code> 机制来处理异常。Go 语言官方博客的《&lt;a href="https://blog.golang.org/defer-panic-and-recover">Defer, Panic, and Recover&lt;/a>》讲述了这个机制的具体应用方式。&lt;/p>
&lt;p>还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：&lt;/p>
&lt;ul>
&lt;li>The Right Places To Call The recover Function：https://go101.org/article/panic-and-recover-more.html ，几种使用 &lt;code>recover&lt;/code> 恢复 Go 语言中 &lt;code>panic&lt;/code> 的适用场景&lt;/li>
&lt;li>7.异常处理：https://www.kancloud.cn/liupengjie/go/578555 ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节&lt;/li>
&lt;/ul>
&lt;p>如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 &lt;code>defer&lt;/code> + &lt;code>recover&lt;/code> 处理一个 &lt;code>panic&lt;/code>，&lt;code>defer&lt;/code> 结构要在 &lt;code>panic&lt;/code> 触发之前被定义而且 &lt;code>recover&lt;/code> 要直接在在 &lt;code>defer&lt;/code> 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。&lt;/p>
&lt;h2 id="3-defer-语法糖的部分原理">3. &lt;code>defer&lt;/code> 语法糖的部分原理&lt;/h2>
&lt;p>在讲述 &lt;code>defer&lt;/code> 机制的文章中，都会提到一个函数中多个 &lt;code>defer&lt;/code> 结构执行的顺序和定义顺序是相反的，即后定义的 &lt;code>defer&lt;/code> 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(&lt;span style="color:#a6e22e">str&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">str&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;h&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用 &lt;code>f&lt;/code> 输出为：&lt;/p>
&lt;pre tabindex="0">&lt;code>h
0
&lt;/code>&lt;/pre>&lt;p>常见的函数调用流程为：&lt;/p>
&lt;ul>
&lt;li>将函数使用的参数压入栈&lt;/li>
&lt;li>执行函数指令&lt;/li>
&lt;li>函数执行结束返回到调用点&lt;/li>
&lt;/ul>
&lt;p>如果 &lt;code>defer&lt;/code> 相关的代码也是这么执行的话，那么为什么不是： &lt;code>0&lt;/code> 入栈 - 执行 &lt;code>g&lt;/code> - &lt;code>g&lt;/code> 返回 - &lt;code>&amp;quot;h&amp;quot;&lt;/code> 入栈 - 执行 &lt;code>h&lt;/code> - &lt;code>h&lt;/code> 返回 这个顺序呢？
按照这个顺序执行，调用 &lt;code>f&lt;/code> 输出应该是 &lt;code>0&lt;/code> 在 &lt;code>h&lt;/code> 前面符合预期。是不是 Go 语言中执行 &lt;code>defer&lt;/code> 时采用了特殊的处理流程？&lt;/p>
&lt;p>是，也不是。&lt;/p>
&lt;p>太阳底下无新鲜事，&lt;code>defer&lt;/code> 不过是一个语法糖，用来对一个函数 &lt;code>deferproc&lt;/code> 进行包装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Create a new deferred function fn with siz bytes of arguments.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// The compiler turns a defer statement into a call to this.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:nosplit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">deferproc&lt;/span>(&lt;span style="color:#a6e22e">siz&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>, &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">funcval&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>deferproc&lt;/code> 创建一个延迟调用的函数，其参数为 &lt;code>siz&lt;/code> （延迟调用的函数的参数占用的字节数量）和 &lt;code>fn&lt;/code>（被延迟调用的函数本身）。
当 Go 程序的编译器遇到 &lt;code>defer f()&lt;/code>，会将这条语句翻译为一条 &lt;code>deferproc&lt;/code> 和一条 &lt;code>deferreturn&lt;/code> 。
其中 &lt;code>deferproc&lt;/code> 把被调用的函数及其参数挂载在 goroutine （Go 中的并发单元，协程）结构的一个链表上；
&lt;code>deferreturn&lt;/code> 从链表上取下一个挂载的被延迟执行的函数，执行它。&lt;/p>
&lt;p>如何使用技巧绕过 &lt;code>defer&lt;/code> 关键字，模拟类似效果？
可以使用 &lt;code>linkname&lt;/code> 方法来把 Go 语言运行时的一些关键函数导出，从而进行某些不常见的操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#e6db74">&amp;#34;runtime&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Eface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">EfaceOf&lt;/span>(&lt;span style="color:#a6e22e">ep&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Eface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Eface&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">ep&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Funcval&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// variable-size, fn-specific data here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:linkname Deferproc runtime.deferproc
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Deferproc&lt;/span>(&lt;span style="color:#a6e22e">siz&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>, &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Funcval&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:linkname Deferreturn runtime.deferreturn
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Deferreturn&lt;/span>(&lt;span style="color:#a6e22e">arg0&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;hacked defer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fI&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#a6e22e">f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Attach a defer struct to the current goroutine struct
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Deferproc&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Funcval&lt;/span>)(&lt;span style="color:#a6e22e">EfaceOf&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">fI&lt;/span>).&lt;span style="color:#a6e22e">Data&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;original defer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Run a deferred function if there is one
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Deferreturn&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码会输出：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-output" data-lang="output">original defer
hacked defer
&lt;/code>&lt;/pre>&lt;p>当然，如果是使用 &lt;code>defer&lt;/code> 关键字，Go 语言的编译器会选择合适的位置插入 &lt;code>deferreturn&lt;/code> 语句，而不是像上述代码中一样手动放在结束位置处。&lt;/p>
&lt;h2 id="4-recover-生效位置的设计原因推测">4. &lt;code>recover&lt;/code> 生效位置的设计原因推测&lt;/h2>
&lt;p>言归正传，&lt;code>panic&lt;/code> 发生后，会根据函数调用顺序逐层上报，直到最后一层被抛出到系统导致崩溃或者被 &lt;code>recover&lt;/code> 机制处理。
那么如果被 &lt;code>recover&lt;/code> 处理，这个过程是怎么生效的？&lt;/p>
&lt;p>很多教程中都提到 &lt;code>recover&lt;/code> 一定要在 &lt;code>defer&lt;/code> 声明的函数里面（既不是这个函数本身也不能是函数里面的其他函数里面）才能正确处理当前的 &lt;code>panic&lt;/code> 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 1, not work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 2, not work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 3, work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么呢？&lt;/p>
&lt;p>先不考虑实现，先从理念上分析一下。&lt;/p>
&lt;ol>
&lt;li>&lt;code>defer&lt;/code> 直接作用于 &lt;code>recover()&lt;/code>：无法根据 &lt;code>recover()&lt;/code> 的返回值来进行不同类型的 &lt;code>panic&lt;/code> 处理&lt;/li>
&lt;li>在被 &lt;code>defer&lt;/code> 作用的函数内部的函数 &lt;code>g&lt;/code> 中使用 &lt;code>recover()&lt;/code>：如果 &lt;code>g&lt;/code> 是一个第三方库的函数，无法保证其中没有未知的 &lt;code>recover&lt;/code> 意外处理了系统中的 &lt;code>panic&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>因此事实上也只能通过这样的约束来使这个异常处理机制看上去直观易处理一些。当然通过对 Go 编译器进行修改，还是有办法使得上面三种情况下 &lt;code>recover&lt;/code> 都可以中断 &lt;code>panic&lt;/code> 向上层传递过程的。&lt;/p>
&lt;p>此外，由于被 &lt;code>defer&lt;/code> 处理的函数被挂载在 goroutine 结构的一个链表上，因此当 &lt;code>panic&lt;/code> 发生时，可以直接从这个链表上取下被延迟执行的函数一个个执行。
这也是 &lt;code>recover&lt;/code> 要放在 &lt;code>deferred function&lt;/code> 中的原因，因为这些函数是肯定可以执行到的。&lt;/p>
&lt;h2 id="5-总结">5. 总结&lt;/h2>
&lt;p>不能说 Go 中这个异常处理机制有多高明，基本上属于现代语言标配。了解更多背后的原理，在使用时可以更坚定一些。&lt;/p>
&lt;p>此外，最近看到一本书《最好的告别》（https://book.douban.com/subject/26576861/）。&lt;/p>
&lt;p>&lt;img src="https://images-na.ssl-images-amazon.com/images/I/41rwxKTGwXL._SX308_BO1,204,203,200_.jpg" alt="Being Mortal">&lt;/p>
&lt;p>豆瓣上的介绍：&lt;/p>
&lt;blockquote>
&lt;p>当独立、自助的生活不能再维持时，我们该怎么办？在生命临近终点的时刻，我们该和医生谈些什么？应该如何优雅地跨越生命的终点？对于这些问题，大多数人缺少清晰的观念，而只是把命运交由医学、技术和陌生人来掌控。影响世界的医生阿图•葛文德结合其多年的外科医生经验与流畅的文笔，讲述了一个个伤感而发人深省的故事，对在21世纪变老意味着什么进行了清醒、深入的探索。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>defer&lt;/code> / &lt;code>finally&lt;/code> 这些关键字让我们可以控制函数退出时的行为，但是我们自身呢？也许考虑这些问题可以让我们自身活得有意义一些。&lt;/p>
&lt;p>推荐大家看一下。&lt;/p></content></item><item><title>Useful Commands</title><link>https://blog.formalscience.com/2018/07/22/2018-07-22_commands/</link><pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/07/22/2018-07-22_commands/</guid><description>Convert images to a video ffmpeg -r 30 -start_number 3455 -i _IMG%d.jpg -s 960X600 -pix_fmt yuv420p 30fps-960.mov -r 30: 30 frames per second -s 960X600: resolution -pix_fmt yuv420p: for OsX youtube-dl video and extract audio file youtube-dl --proxy socks5://127.0.0.1:1080 -x --audio-format mp3 youtube-url
virtualenvwrapper WORKON_HOME: which directory your environments are created in /usr/local/bin/virtualenvwrapper.sh: default location for its configuration file mkvirtualenv test --python=python3: make a virtual environment &amp;rsquo;test&amp;rsquo; with python3 rmvirtualenv test: remove a virtual environment &amp;rsquo;test' workon test3 or lsvirtualenv -b test3: activate a virtual environment &amp;rsquo;test' deactivate: exit current environment more details: search engine how to avoid globa packages how to copy an environment node &amp;amp;&amp;amp; npm npm complains: Error: Cannot find module 'process-nextick-args'</description><content>&lt;h2 id="convert-images-to-a-video">Convert images to a video&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ffmpeg -r &lt;span style="color:#ae81ff">30&lt;/span> -start_number &lt;span style="color:#ae81ff">3455&lt;/span> -i _IMG%d.jpg -s 960X600 -pix_fmt yuv420p 30fps-960.mov
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>-r 30&lt;/code>: 30 frames per second&lt;/li>
&lt;li>&lt;code>-s 960X600&lt;/code>: resolution&lt;/li>
&lt;li>&lt;code>-pix_fmt yuv420p&lt;/code>: for OsX&lt;/li>
&lt;/ul>
&lt;h2 id="youtube-dl-video-and-extract-audio-file">youtube-dl video and extract audio file&lt;/h2>
&lt;p>&lt;code>youtube-dl --proxy socks5://127.0.0.1:1080 -x --audio-format mp3 youtube-url&lt;/code>&lt;/p>
&lt;h2 id="virtualenvwrapper">virtualenvwrapper&lt;/h2>
&lt;ul>
&lt;li>&lt;code>WORKON_HOME&lt;/code>: which directory your environments are created in&lt;/li>
&lt;li>&lt;code>/usr/local/bin/virtualenvwrapper.sh&lt;/code>: default location for its configuration file&lt;/li>
&lt;li>&lt;code>mkvirtualenv test --python=python3&lt;/code>: make a virtual environment &amp;rsquo;test&amp;rsquo; with python3&lt;/li>
&lt;li>&lt;code>rmvirtualenv test&lt;/code>: remove a virtual environment &amp;rsquo;test'&lt;/li>
&lt;li>&lt;code>workon test3&lt;/code> or &lt;code>lsvirtualenv -b test3&lt;/code>: activate a virtual environment &amp;rsquo;test'&lt;/li>
&lt;li>&lt;code>deactivate&lt;/code>: exit current environment&lt;/li>
&lt;li>more details: search engine
&lt;ul>
&lt;li>how to avoid globa packages&lt;/li>
&lt;li>how to copy an environment&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="node--npm">node &amp;amp;&amp;amp; npm&lt;/h2>
&lt;p>npm complains: &lt;code>Error: Cannot find module 'process-nextick-args'&lt;/code>&lt;/p>
&lt;p>Uninstall node, &lt;code>brew uninstall node&lt;/code>, then by &lt;a href="https://stackoverflow.com/questions/11177954/how-do-i-completely-uninstall-node-js-and-reinstall-from-beginning-mac-os-x">this stackoverflow post&lt;/a>:&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp
sudo rm -rf /opt/local/bin/node /opt/local/include/node /opt/local/lib/node_modules
sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node.1 /usr/local/lib/dtrace/node.d
&lt;/code>&lt;/pre>&lt;p>Just delete something, then &lt;code>brew install npm&lt;/code>.&lt;/p>
&lt;h2 id="delve-dlv-tips">delve (dlv) tips&lt;/h2>
&lt;ul>
&lt;li>funcs [regexp] : get function list&lt;/li>
&lt;li>call : call a function (in a newer a go version, dlv should be installed in the newer go version too)&lt;/li>
&lt;/ul>
&lt;h2 id="shadowsocks">shadowsocks&lt;/h2>
&lt;p>&lt;code>ssserver -c /etc/shadowsocks/config.json&lt;/code>&lt;/p>
&lt;p>&lt;code>sslocal&lt;/code> and &lt;code>ssserver&lt;/code> are all from &lt;code>apt-get install shadowsocks&lt;/code>.&lt;/p>
&lt;h2 id="wsl-2--vmware-switch">WSL 2 &amp;amp;&amp;amp; VMware switch&lt;/h2>
&lt;p>After enabling WSL 2 on Windows 10 insider preview, VMware virtual machine is disabled.
This is because collision between Hyper-V and VMware.&lt;/p>
&lt;p>Turn on VMware&lt;/p>
&lt;pre tabindex="0">&lt;code> bcdedit /set hypervisorlaunchtype off
&lt;/code>&lt;/pre>&lt;p>Turn on Hyper-V &amp;amp;&amp;amp; WSL 2&lt;/p>
&lt;pre tabindex="0">&lt;code> bcdedit /set hypervisorlaunchtype auto
&lt;/code>&lt;/pre>&lt;p>reference: &lt;a href="https://blog.minirplus.com/10268/">https://blog.minirplus.com/10268/&lt;/a>&lt;/p></content></item><item><title>Upgrade DigitalOcean's Ubuntu 17.04 to LTS version in 2018-06</title><link>https://blog.formalscience.com/2018/06/23/2018-06-23_update_vps_ubuntu_version/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/06/23/2018-06-23_update_vps_ubuntu_version/</guid><description>What happened? I found my proxy for accessing some websites stopped working today, so I had to change my VPS&amp;rsquo;s IP address. After some trials, everything seemed OK and I started watching a skiing video made by NorthFace on Youtube.
Emmmm, I noticed 12 packages needed to be updated. Well, I typed sudo apt-get update and got messages like this (I didn&amp;rsquo;t save the error messages then):
404 Not Found [IP: 91.</description><content>&lt;h2 id="what-happened">What happened?&lt;/h2>
&lt;p>I found my proxy for accessing some websites stopped working today, so I had to change my VPS&amp;rsquo;s IP address.
After some trials, everything seemed OK and I started watching a skiing video made by NorthFace on Youtube.&lt;/p>
&lt;p>Emmmm, I noticed 12 packages needed to be updated.
Well, I typed &lt;code>sudo apt-get update&lt;/code> and got messages like this (I didn&amp;rsquo;t save the error messages then):&lt;/p>
&lt;pre tabindex="0">&lt;code> 404 Not Found [IP: 91.189.91.23 80]
Ign:10 http://us.archive.ubuntu.com/ubuntu zesty-backports InRelease
Err:11 http://us.archive.ubuntu.com/ubuntu zesty Release
404 Not Found [IP: 91.189.91.26 80]
Err:12 http://us.archive.ubuntu.com/ubuntu zesty-updates Release
404 Not Found [IP: 91.189.91.26 80]
Err:13 http://us.archive.ubuntu.com/ubuntu zesty-backports Release
404 Not Found [IP: 91.189.91.26 80]
Reading package lists... Done
E: The repository &amp;#39;http://security.ubuntu.com/ubuntu zesty-security Release&amp;#39; does no longer have a Release file.
N: Updating from such a repository can&amp;#39;t be done securely, and is therefore disabled by default.
N: See apt-secure(8) manpage for repository creation and user configuration details.
E: The repository &amp;#39;http://us.archive.ubuntu.com/ubuntu zesty Release&amp;#39; does no longer have a Release file.
N: Updating from such a repository can&amp;#39;t be done securely, and is therefore disabled by default.
N: See apt-secure(8) manpage for repository creation and user configuration details.
E: The repository &amp;#39;http://us.archive.ubuntu.com/ubuntu zesty-updates Release&amp;#39; does no longer have a Release file.
N: Updating from such a repository can&amp;#39;t be done securely, and is therefore disabled by default.
N: See apt-secure(8) manpage for repository creation and user configuration details.
E: The repository &amp;#39;http://us.archive.ubuntu.com/ubuntu zesty-backports Release&amp;#39; does no longer have a Release file.
N: Updating from such a repository can&amp;#39;t be done securely, and is therefore disabled by default.
N: See apt-secure(8) manpage for repository creation and user configuration details.
&lt;/code>&lt;/pre>&lt;p>Wow, It was the first time I encountered such things.
After some digging, I realized it was because Ubuntu 17.04 (zesty) was not supported any longer.&lt;/p>
&lt;p>According to &lt;a href="https://wiki.ubuntu.com/ZestyZapus/ReleaseNotes">https://wiki.ubuntu.com/ZestyZapus/ReleaseNotes&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Ubuntu 17.04 will be supported for 9 months until January 2018. If you need Long Term Support, it is recommended you use Ubuntu 16.04 LTS instead.&lt;/p>
&lt;/blockquote>
&lt;p>It means my current release version (Ubuntu 17.04) won&amp;rsquo;t receive any updates in the future.&lt;/p>
&lt;p>&lt;img src="https://assets.ubuntu.com/v1/f02f0a4b-r-eol-ubuntu-full-2018-02-28.png" alt="release-end-of-life-date">&lt;/p>
&lt;h2 id="how-to-upgrade">How to upgrade&lt;/h2>
&lt;p>I was struggled to reveal some steps to upgrade my Ubuntu 17.04 (End-of-Life) to 18.04 (LTS version).&lt;/p>
&lt;p>The official guide to upgrade from an Ubuntu release which reaches its “end of life” is: &lt;a href="https://help.ubuntu.com/community/EOLUpgrades">https://help.ubuntu.com/community/EOLUpgrades&lt;/a>&lt;/p>
&lt;h3 id="1-update-sourceslist">1. Update sources.list&lt;/h3>
&lt;p>The path of &lt;em>sources.list&lt;/em> is &lt;em>/etc/apt/sources.list&lt;/em>.&lt;/p>
&lt;pre tabindex="0">&lt;code>## EOL upgrade sources.list
# Required
deb http://old-releases.ubuntu.com/ubuntu/ CODENAME main restricted universe multiverse
deb http://old-releases.ubuntu.com/ubuntu/ CODENAME-updates main restricted universe multiverse
deb http://old-releases.ubuntu.com/ubuntu/ CODENAME-security main restricted universe multiverse
# Optional
#deb http://old-releases.ubuntu.com/ubuntu/ CODENAME-backports main restricted universe multiverse
&lt;/code>&lt;/pre>&lt;p>In my case, &lt;code>CODENAME&lt;/code> should be replaced by &lt;code>zesty&lt;/code>.&lt;/p>
&lt;h3 id="2-upgrade">2. Upgrade&lt;/h3>
&lt;p>Try &lt;code>apt-get upgrade&lt;/code>, and I got:&lt;/p>
&lt;pre tabindex="0">&lt;code>dpkg: dependency problems prevent configuration of ubuntu-standard:
ubuntu-standard depends on libpam-systemd; however:
Package libpam-systemd:amd64 is not configured yet.
&lt;/code>&lt;/pre>&lt;p>By some method suggested by stackoverflowers, I finally got over it by these commands:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo dpkg --force-all -P libpam-systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -f install libpam-systemd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-dist-upgrade">3. Dist Upgrade&lt;/h3>
&lt;p>These are some normal steps for an upgrade.&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo apt-get dist-upgrade
sudo do-release-upgrade
&lt;/code>&lt;/pre>&lt;p>If you&amp;rsquo;re unlucky like me, you will not upgrade to a newer release completely.
You may see:&lt;/p>
&lt;pre tabindex="0">&lt;code>Package grub-efi-amd64 is not configured yet.
&lt;/code>&lt;/pre>&lt;p>According to &lt;a href="https://askubuntu.com/questions/330531/unable-to-fix-broken-package-system">a question&lt;/a> asked by someone, you can try this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo dpkg --force-all -P grub-efi-amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo dpkg --force-all -P grub-efi-amd64-signed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Execute &lt;code>sudo apt-get update&lt;/code> and &lt;code>sudo apt-get upgrade&lt;/code>.&lt;/p>
&lt;h3 id="4-thoughts">4. Thoughts&lt;/h3>
&lt;p>I first upgraded to Ubuntu 17.10 then Ubuntu 18.04.&lt;/p>
&lt;p>To see if I have done the right things, I check the release version by &lt;code>sudo lsb_release -a&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>Distributor ID: Ubuntu
Description: Ubuntu 18.04 LTS
Release: 18.04
Codename: bionic
&lt;/code>&lt;/pre>&lt;p>Is it the DigitalOcean&amp;rsquo;s customized release makes the upgrade so complex for a non-expert programmer or the Ubuntu release itself?&lt;/p>
&lt;p>But apparently, I&amp;rsquo;m not the only one who is confused by the error messages and asks questions on the web. Luckily I&amp;rsquo;ve found helping answers I need.&lt;/p>
&lt;p>The commands with words like &lt;code>force&lt;/code> or &lt;code>-f&lt;/code> make me feel anxious.&lt;/p>
&lt;blockquote>
&lt;p>These violent delights have violent ends.
&amp;mdash; by Shakespeare&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://cdn.vox-cdn.com/thumbor/NxFcQHzIb1eqgk5EXafSzFwy2UU=/0x0:5100x3400/920x613/filters:focal(1816x555:2632x1371):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/52220535/westworld_dolores.0.jpeg" alt="Dolores">&lt;/p>
&lt;p>Anyway, it works.&lt;/p></content></item><item><title>理解 C++ Traits</title><link>https://blog.formalscience.com/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/</link><pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/05/12/2018-05-12_%E7%90%86%E8%A7%A3_c-_traits/</guid><description>C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 type_relation 的成员 relation 获取比较结果。当前代码输出：
type_relation&amp;lt;bool, int&amp;gt;: different type_relation&amp;lt;int, int&amp;gt;: different 这段代码并未实现预期功能，因为比较 bool 和 int，以及 int 和 int 时，都输出 &amp;quot;different&amp;quot; 。下面继续完善这个 trait 实现。</description><content>&lt;p>C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。&lt;/p>
&lt;p>C++ 之父 Bjarne Stroustrup 说：&lt;/p>
&lt;blockquote>
&lt;p>Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.&lt;/p>
&lt;/blockquote>
&lt;p>嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。&lt;/p>
&lt;p>&lt;img src="https://blog.formalscience.com/uploads/trait1.png" alt="trait1">&lt;/p>
&lt;p>这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 &lt;code>type_relation&lt;/code> 的成员 &lt;code>relation&lt;/code> 获取比较结果。当前代码输出：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-output" data-lang="output">type_relation&amp;lt;bool, int&amp;gt;: different
type_relation&amp;lt;int, int&amp;gt;: different
&lt;/code>&lt;/pre>&lt;p>这段代码并未实现预期功能，因为比较 &lt;code>bool&lt;/code> 和 &lt;code>int&lt;/code>，以及 &lt;code>int&lt;/code> 和 &lt;code>int&lt;/code> 时，都输出 &lt;code>&amp;quot;different&amp;quot;&lt;/code> 。下面继续完善这个 trait 实现。&lt;/p>
&lt;p>&lt;img src="https://blog.formalscience.com/uploads/trait2.png" alt="trait2">&lt;/p>
&lt;p>第 11 行的类型参数种使用 &lt;code>&amp;lt;T, T&amp;gt;&lt;/code> （即两个相同的类型）进行模式匹配。这段代码输出：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-output" data-lang="output">type_relation&amp;lt;bool, int&amp;gt;: different
type_relation&amp;lt;int, int&amp;gt;: equal
&lt;/code>&lt;/pre>&lt;p>输出结果正确完成了类型比较的功能。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>实现&lt;/strong>&lt;/p>
&lt;p>trait 的实现基于 C++ 的模板引擎（template engine），能够在**编译时期（compile time）**将模板（基于最匹配的模式）展开。如果要在 Golang 或者 Java 种实现类似功能，可以使用反射或者 interface 之类的方法，而这些方法都是在运行时（runtime）进行判定，不可避免带来性能开销。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>进阶&lt;/strong>&lt;/p>
&lt;p>除了可以比较两个类型是否相等，还可以在类型参数上添加其他约束，例如：&lt;code>*&lt;/code>、&lt;code>[]&lt;/code> 等。下面是一个稍微复杂一些的版本：&lt;/p>
&lt;p>&lt;img src="https://blog.formalscience.com/uploads/trait3.png" alt="trait3">&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-output" data-lang="output">type_relation&amp;lt;bool, int&amp;gt;: different
type_relation&amp;lt;int, int&amp;gt;: equal
type_relation&amp;lt;int*, int&amp;gt;: is pointer of
type_relation&amp;lt;int[], int&amp;gt;: is array of
type_relation&amp;lt;int[4], int&amp;gt;: is array (length 4) of
&lt;/code>&lt;/pre>&lt;p>当然这个“进阶”仅仅是比上面的例子复杂了一些，trait 还有更多能力。
C++ 的模板引擎为 C++ 提供了强大的元编程（meta programming）能力，也使得现代的 C++ 代码看上去比较奇怪。
事实上模板引擎是图灵完备的，如果使用好的话，能够将 C++ 的易用性和优雅性提升到一个高度（从那些看不到模板实现细节的用户的视角）。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>感想&lt;/strong>&lt;/p>
&lt;p>每次 C++ 标准更新的新闻我都看到了，从 C++0X、C++11、C++14 到 C++17，新出的特性一直在关注，可却从来没有真正编写一段程序去试试这些特性。这让我很伤感。&lt;/p>
&lt;p>看到新的语言就想去尝试，OCaml、Clojure、Haskell …… 这些语言都很有特色，OCaml 让我体会到模式匹配的爽快，Clojure 让我体会到 S-表达式的自由和 Lisp 宏的强大，Haskell 让我体会到抽象的威力以及自己脑容量的有限。可是工作中用的最多的还是 Python、Java 和 C，当然还有 PHP （这个不能忘）。&lt;/p>
&lt;p>想我和 C++ 的关系，最初的时候还是看的 Bjarne Stroustrup 的《The C++ Programming Language》。后来怎么就越走越远了呢？虽然现在工作中暂时依旧用不到，还是希望以此为契机，了解更多模板引擎可以做的事情。&lt;/p>
&lt;p>追逐过的其他语言，各有各的契机，或许是缘分，或许是喜欢，或许是虚荣。现在都不敢说自己会 C++ 了。
如果当时能够更专注一些，自己目前的职业轨迹会不会有所区别？&lt;/p>
&lt;p>想起最初自己理解 Haskell 里 &lt;code>Monad&lt;/code> 概念的时候，一头雾水。后来懂了，就是懂了。为什么偏爱某一种语言呢？我也搞不清楚自己。&lt;/p>
&lt;p>也许爱情也是如此，回忆当初做的不同结果是否能够更好？也许。记住过往，抗拒住回忆的诱惑，很难，但不得不做。喜欢的，就喜欢着吧。有些事情就是不行，正如有些事情莫名其妙地发生。&lt;/p>
&lt;p>Just live with it.&lt;/p></content></item><item><title>‘How Does Monero Work?' 笔记</title><link>https://blog.formalscience.com/2018/01/21/2018-01-21_how-does-monero-work-%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 21 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/01/21/2018-01-21_how-does-monero-work-%E7%AC%94%E8%AE%B0/</guid><description>Monero 门罗币的一个介绍视频
我刚买到 1070Ti 显卡时曾经想要挖过这个币，后来放弃了，觉得没有意义。不过了解这个技术的一些原理还是有价值的。
Siraj Raval 的免责声明： 
Monero 是一种不可追踪的加密货币，网络上很多非法买卖东西的人会使用它。他介绍这个技术的原因是：你应当对你的数据有控制权，而很多数据是交易数据（transactional data）。目前很多公司可以从中免费挖掘信息，用来预测你的购买行为，以便向你展示广告。理想情况下他们应当为你的数据付费，而他们付费的唯一可能是你控制着数据，而唯一控制数据的方式为数据是匿名的。为了查阅你的交易历史，</description><content>&lt;p>Monero 门罗币的一个&lt;a href="https://www.youtube.com/watch?v=cjbHqvr4ffo&amp;amp;list=PL2-dafEMk2A7jW7CYUJsBu58JH27bqaNL">介绍视频&lt;/a>&lt;/p>
&lt;p>我刚买到 1070Ti 显卡时曾经想要挖过这个币，后来放弃了，觉得没有意义。不过了解这个技术的一些原理还是有价值的。&lt;/p>
&lt;hr>
&lt;p>Siraj Raval 的免责声明：
&lt;/p>
&lt;blockquote>
&lt;p>Monero 是一种不可追踪的加密货币，网络上很多非法买卖东西的人会使用它。他介绍这个技术的原因是：你应当对你的数据有控制权，而很多数据是交易数据（transactional data）。目前很多公司可以从中免费挖掘信息，用来预测你的购买行为，以便向你展示广告。理想情况下他们应当为你的数据付费，而他们付费的唯一可能是你控制着数据，而唯一控制数据的方式为数据是匿名的。为了查阅你的交易历史，&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://blog.formalscience.com/uploads/monero1.png" alt="">&lt;/p></content></item><item><title>两个玻璃球（网上流传的面试题）</title><link>https://blog.formalscience.com/2018/01/17/2018-01-17_%E4%B8%A4%E4%B8%AA%E7%8E%BB%E7%92%83%E7%90%83%E7%BD%91%E4%B8%8A%E6%B5%81%E4%BC%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/01/17/2018-01-17_%E4%B8%A4%E4%B8%AA%E7%8E%BB%E7%92%83%E7%90%83%E7%BD%91%E4%B8%8A%E6%B5%81%E4%BC%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>据说这是 Google 的一个面试题：
有一栋 100 层高的大楼，有两个完全相同的玻璃球。假设从某一层开始丢下玻璃球会摔碎，利用手中的两个玻璃球确定是第几层。最少扔几次玻璃球可以确定这个临界楼层（玻璃球在这一层以及更高的楼层扔下会摔碎）？
就如孔子说过的那句名言 &amp;ldquo;I Never Said All That Shit&amp;rdquo; 一样，这个题目出自哪里我也没有去考证。下面把我的思路整理一下。
如果只有一个玻璃球，能做的就是从 1 层开始尝试扔下玻璃球，然后尝试 2 层、3 层 ……，直到某一层扔下玻璃球后摔碎。而现在有两个玻璃球，我们可以用一个玻璃球从 1 层、11 层、21 层 …… 扔下去，确定一个较小的破碎范围，然后使用第二个玻璃球确定具体的楼层。
假如总共 N 层，我们从第 X 层扔下第一个玻璃球，有两种可能性：玻璃球摔碎或者没碎。如果玻璃球摔碎，说明临界楼层在 1~X 中；如果没摔碎，则临界楼层在 X+1~N 中。
如果临界楼层在 1~N 中是均匀分布的，那么 $N &amp;gt; 2$ 时确定临界楼层需要扔玻璃球的最少次数可以由以下公式表示：
$$ f(N)= \min_{X \in [1, N]} {1 + f(N-X)\frac{N-X}{N} + g(X)\frac{X}{N}} $$
$f(N)$ 为使用两个玻璃球确定区间长度为 N 时的临界楼层所用次数，$g(X)$ 为使用一个玻璃球确定区间长度为 N 时的临界楼层所用次数。这个公式的三部分分别对应：
一次扔玻璃球的尝试 玻璃球未摔碎概率$\times$此时继续尝试需要的次数 $f(N-X)$（两个玻璃球） 玻璃球摔碎概率$\times$此时继续尝试需要的次数 $g(X)$（一个玻璃球）。 显然有 $f(1)=0$，$g(N)=N-1$。可以用动态规划求解 $N=100$ 时需要的最少次数。</description><content>&lt;p>据说这是 Google 的一个面试题：&lt;/p>
&lt;blockquote>
&lt;p>有一栋 100 层高的大楼，有两个完全相同的玻璃球。假设从某一层开始丢下玻璃球会摔碎，利用手中的两个玻璃球确定是第几层。最少扔几次玻璃球可以确定这个临界楼层（玻璃球在这一层以及更高的楼层扔下会摔碎）？&lt;/p>
&lt;/blockquote>
&lt;p>就如孔子说过的那句名言 &amp;ldquo;I Never Said All That Shit&amp;rdquo; 一样，这个题目出自哪里我也没有去考证。下面把我的思路整理一下。&lt;/p>
&lt;p>如果只有一个玻璃球，能做的就是从 1 层开始尝试扔下玻璃球，然后尝试 2 层、3 层 ……，直到某一层扔下玻璃球后摔碎。而现在有两个玻璃球，我们可以用一个玻璃球从 1 层、11 层、21 层 …… 扔下去，确定一个较小的破碎范围，然后使用第二个玻璃球确定具体的楼层。&lt;/p>
&lt;p>假如总共 N 层，我们从第 X 层扔下第一个玻璃球，有两种可能性：玻璃球摔碎或者没碎。如果玻璃球摔碎，说明临界楼层在 1~X 中；如果没摔碎，则临界楼层在 X+1~N 中。&lt;/p>
&lt;p>如果临界楼层在 1~N 中是均匀分布的，那么 $N &amp;gt; 2$ 时确定临界楼层需要扔玻璃球的最少次数可以由以下公式表示：&lt;/p>
&lt;p>$$
f(N)= \min_{X \in [1, N]} {1 + f(N-X)\frac{N-X}{N} + g(X)\frac{X}{N}}
$$&lt;/p>
&lt;p>$f(N)$ 为使用两个玻璃球确定区间长度为 N 时的临界楼层所用次数，$g(X)$ 为使用一个玻璃球确定区间长度为 N 时的临界楼层所用次数。这个公式的三部分分别对应：&lt;/p>
&lt;ul>
&lt;li>一次扔玻璃球的尝试&lt;/li>
&lt;li>玻璃球未摔碎概率$\times$此时继续尝试需要的次数 $f(N-X)$（两个玻璃球）&lt;/li>
&lt;li>玻璃球摔碎概率$\times$此时继续尝试需要的次数 $g(X)$（一个玻璃球）。&lt;/li>
&lt;/ul>
&lt;p>显然有 $f(1)=0$，$g(N)=N-1$。可以用动态规划求解 $N=100$ 时需要的最少次数。&lt;/p></content></item><item><title>Golang 系统调用/Syscall</title><link>https://blog.formalscience.com/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</link><pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/01/15/2018-01-15_golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</guid><description>概述 很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：
func Read(fd int, p []byte) (n int, err error) func Write(fd int, p []byte) (n int, err error) 同时，Golang 也提供了对 Syscall 的直接调用支持：
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) RawSyscall 和 RawSyscall6 是对操作系统 Syscall 的直接调用；Syscall 和 Syscall6 会在调用操作系统 Syscall 前调用 runtime·entersyscall ，在操作系统 Syscall 返回后调用 runtime·exitsyscall 。</description><content>&lt;h1 id="概述">概述&lt;/h1>
&lt;p>很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Read&lt;/span>(&lt;span style="color:#a6e22e">fd&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#a6e22e">fd&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">p&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时，Golang 也提供了对 Syscall 的直接调用支持：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Syscall&lt;/span>(&lt;span style="color:#a6e22e">trap&lt;/span>, &lt;span style="color:#a6e22e">a1&lt;/span>, &lt;span style="color:#a6e22e">a2&lt;/span>, &lt;span style="color:#a6e22e">a3&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) (&lt;span style="color:#a6e22e">r1&lt;/span>, &lt;span style="color:#a6e22e">r2&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#a6e22e">Errno&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Syscall6&lt;/span>(&lt;span style="color:#a6e22e">trap&lt;/span>, &lt;span style="color:#a6e22e">a1&lt;/span>, &lt;span style="color:#a6e22e">a2&lt;/span>, &lt;span style="color:#a6e22e">a3&lt;/span>, &lt;span style="color:#a6e22e">a4&lt;/span>, &lt;span style="color:#a6e22e">a5&lt;/span>, &lt;span style="color:#a6e22e">a6&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) (&lt;span style="color:#a6e22e">r1&lt;/span>, &lt;span style="color:#a6e22e">r2&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#a6e22e">Errno&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">RawSyscall&lt;/span>(&lt;span style="color:#a6e22e">trap&lt;/span>, &lt;span style="color:#a6e22e">a1&lt;/span>, &lt;span style="color:#a6e22e">a2&lt;/span>, &lt;span style="color:#a6e22e">a3&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) (&lt;span style="color:#a6e22e">r1&lt;/span>, &lt;span style="color:#a6e22e">r2&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#a6e22e">Errno&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">RawSyscall6&lt;/span>(&lt;span style="color:#a6e22e">trap&lt;/span>, &lt;span style="color:#a6e22e">a1&lt;/span>, &lt;span style="color:#a6e22e">a2&lt;/span>, &lt;span style="color:#a6e22e">a3&lt;/span>, &lt;span style="color:#a6e22e">a4&lt;/span>, &lt;span style="color:#a6e22e">a5&lt;/span>, &lt;span style="color:#a6e22e">a6&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) (&lt;span style="color:#a6e22e">r1&lt;/span>, &lt;span style="color:#a6e22e">r2&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#a6e22e">Errno&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>RawSyscall&lt;/code> 和 &lt;code>RawSyscall6&lt;/code> 是对操作系统 Syscall 的直接调用；&lt;code>Syscall&lt;/code> 和 &lt;code>Syscall6&lt;/code> 会在调用操作系统 Syscall 前调用 &lt;code>runtime·entersyscall&lt;/code> ，在操作系统 Syscall 返回后调用 &lt;code>runtime·exitsyscall&lt;/code> 。&lt;/p>
&lt;p>这四个函数都是使用汇编语言实现，代码和具体的硬件体系结构和操作系统有关。&lt;code>RawSyscall&lt;/code> 和 &lt;code>RawSyscall6&lt;/code> 的行为和 C 语言中系统调用很类似，在这里不展开描述。而 &lt;code>Syscall&lt;/code> 和 &lt;code>Syscall6&lt;/code> 的行为（在进行真正的系统调用前后插入额外操作）与 Golang 的调度器关系紧密，在下面会进行要点描述。&lt;/p>
&lt;p>&lt;code>Syscall&lt;/code> 的关键在于 &lt;code>runtime·entersyscall&lt;/code> 和 &lt;code>runtime·exitsyscall&lt;/code> ，而 &lt;code>runtime·entersyscall&lt;/code> 还有一个行为有部分差异的版本 &lt;code>runtime·entersyscallblock&lt;/code> 。&lt;/p>
&lt;h1 id="runtimeentersyscall">&lt;code>runtime·entersyscall&lt;/code>&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">entersyscall&lt;/span>(&lt;span style="color:#a6e22e">dummy&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">reentersyscall&lt;/span>(&lt;span style="color:#a6e22e">getcallerpc&lt;/span>(), &lt;span style="color:#a6e22e">getcallersp&lt;/span>(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">dummy&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">reentersyscall&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">getg&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Disable preemption because during this function g is in Gsyscall status,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// but can have inconsistent g-&amp;gt;sched, do not let GC observe it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">locks&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Entersyscall must not call any function that might split/grow the stack.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// (See details in comment above.)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Catch calls that might, by replacing the stack guard with something that
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// will trip any stack check and leaving a flag to tell newstack to die.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stackguard0&lt;/span> = &lt;span style="color:#a6e22e">stackPreempt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">throwsplit&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Leave SP around for GC and traceback.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallsp&lt;/span> = &lt;span style="color:#a6e22e">sp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallpc&lt;/span> = &lt;span style="color:#a6e22e">pc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">casgstatus&lt;/span>(&lt;span style="color:#a6e22e">_g_&lt;/span>, &lt;span style="color:#a6e22e">_Grunning&lt;/span>, &lt;span style="color:#a6e22e">_Gsyscall&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallsp&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stack&lt;/span>.&lt;span style="color:#a6e22e">lo&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stack&lt;/span>.&lt;span style="color:#a6e22e">hi&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallsp&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;entersyscall inconsistent &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">hex&lt;/span>(&lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">syscallsp&lt;/span>), &lt;span style="color:#e6db74">&amp;#34; [&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">hex&lt;/span>(&lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stack&lt;/span>.&lt;span style="color:#a6e22e">lo&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">hex&lt;/span>(&lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stack&lt;/span>.&lt;span style="color:#a6e22e">hi&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;]\n&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">throw&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;entersyscall&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">trace&lt;/span>.&lt;span style="color:#a6e22e">enabled&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#a6e22e">traceGoSysCall&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// systemstack itself clobbers g.sched.{pc,sp} and we might
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// need them later when the G is genuinely blocked in a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// syscall
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">atomic&lt;/span>.&lt;span style="color:#a6e22e">Load&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sched&lt;/span>.&lt;span style="color:#a6e22e">sysmonwait&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#a6e22e">entersyscall_sysmon&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>().&lt;span style="color:#a6e22e">runSafePointFn&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// runSafePointFn may stack split if run on this stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#a6e22e">runSafePointFn&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">syscalltick&lt;/span> = &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>().&lt;span style="color:#a6e22e">syscalltick&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">sysblocktraced&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">mcache&lt;/span> = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>().&lt;span style="color:#a6e22e">m&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">atomic&lt;/span>.&lt;span style="color:#a6e22e">Store&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>().&lt;span style="color:#a6e22e">status&lt;/span>, &lt;span style="color:#a6e22e">_Psyscall&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">sched&lt;/span>.&lt;span style="color:#a6e22e">gcwaiting&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">systemstack&lt;/span>(&lt;span style="color:#a6e22e">entersyscall_gcwait&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">save&lt;/span>(&lt;span style="color:#a6e22e">pc&lt;/span>, &lt;span style="color:#a6e22e">sp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Goroutines must not split stacks in Gsyscall status (it would corrupt g-&amp;gt;sched).
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// We set _StackGuard to StackPreempt so that first split stack check calls morestack.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Morestack detects this case and throws.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">stackguard0&lt;/span> = &lt;span style="color:#a6e22e">stackPreempt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_g_&lt;/span>.&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">locks&lt;/span>&lt;span style="color:#f92672">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>runtime·entersyscall&lt;/code> 主要完成以下几件事：&lt;/p>
&lt;ol>
&lt;li>声明函数为 &lt;code>NOSPLIT&lt;/code> ，不触发栈扩展检查&lt;/li>
&lt;li>禁止抢占&lt;/li>
&lt;li>通过 &lt;code>dummy&lt;/code> 参数获得调用者的 &lt;code>SP&lt;/code> 和 &lt;code>PC&lt;/code> 的值，并保存到 goroutine 的 &lt;code>syscallsp&lt;/code> 和 &lt;code>syscallpc&lt;/code> 字段。同时记录 &lt;code>syscallstack&lt;/code> 和 &lt;code>syscallguard&lt;/code> ，使得垃圾回收器只对系统调用前的栈进行 &lt;strong>mark-sweep&lt;/strong> （cgo 机制也利用了 &lt;code>entersyscall&lt;/code> 来使得 cgo 中运行的代码不受垃圾回收机制管理）。&lt;/li>
&lt;li>将 goroutine 的状态切换到 Gsyscall 状态。&lt;/li>
&lt;li>唤醒后台线程 &lt;code>sysmon&lt;/code> （这个线程会监控执行 &lt;code>syscall&lt;/code> 的线程，如果超过某个时间阈值，就会将 M 与对应的 P 解除绑定）。&lt;/li>
&lt;li>置空 M 的 &lt;code>mcache&lt;/code> 、将 P 的 &lt;code>m&lt;/code> 字段，切换 P 的状态到 &lt;code>Psyscall&lt;/code>&lt;/li>
&lt;li>检查是否需要垃圾回收&lt;/li>
&lt;li>通过 &lt;code>g-&amp;gt;stackguard0 = StackPreempt&lt;/code> 使得出现 &lt;em>split stack&lt;/em> 时可以通过 &lt;code>morestack&lt;/code> 捕获并抛出错误&lt;/li>
&lt;li>恢复抢占&lt;/li>
&lt;/ol>
&lt;p>可以看到 &lt;code>reentersyscall&lt;/code> 多次调用 &lt;code>save&lt;/code> 保存 &lt;code>pc&lt;/code> 和 &lt;code>sp&lt;/code>。&lt;code>save&lt;/code> 更新 &lt;code>getg().sched&lt;/code> 中的 &lt;code>sp&lt;/code> 和 &lt;code>pc&lt;/code> ，使得调用 &lt;code>gogo&lt;/code> 的时候可以恢复 &lt;code>pc&lt;/code> 和 &lt;code>sp&lt;/code> 。&lt;code>reentersyscall&lt;/code> 中 &lt;code>save&lt;/code> 的目的都是为 goroutine 跳回这个 &lt;code>syscall&lt;/code> 调用者执行 &lt;code>syscall&lt;/code> 时刻的 &lt;code>pc&lt;/code> 和 &lt;code>sp&lt;/code>做准备。&lt;/p>
&lt;p>需要继续深入：&lt;/p>
&lt;ol>
&lt;li>&lt;code>StackPreempt&lt;/code>&lt;/li>
&lt;li>&lt;code>syscallstack&lt;/code> 和 &lt;code>syscallguard&lt;/code> 的具体作用时机&lt;/li>
&lt;/ol>
&lt;h1 id="runtimeentersyscallblock">&lt;code>runtime·entersyscallblock&lt;/code>&lt;/h1>
&lt;p>与 &lt;code>runtime·entersyscall&lt;/code> 区别在于这个函数认为当前执行的 &lt;code>syscall&lt;/code> 会运行较长时间，因此在函数中主动进行了 M 和 P 的解除绑定，无需等待 &lt;code>sysmon&lt;/code> 处理。解除 M 和 P 绑定的逻辑由 &lt;code>entersyscallblock_handoff&lt;/code> 实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">entersyscallblock_handoff&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">trace&lt;/span>.&lt;span style="color:#a6e22e">enabled&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">traceGoSysCall&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">traceGoSysBlock&lt;/span>(&lt;span style="color:#a6e22e">getg&lt;/span>().&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">ptr&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handoffp&lt;/span>(&lt;span style="color:#a6e22e">releasep&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="runtimeexitsyscall">&lt;code>runtime·exitsyscall&lt;/code>&lt;/h1>
&lt;p>主要实现了从 &lt;code>syscall&lt;/code> 状态中恢复的动作：&lt;/p>
&lt;ol>
&lt;li>尝试调用 &lt;code>exitsyscallfast&lt;/code> ，如果 M 与 P 没有完全解除绑定，那么该操作会将 M 和 P 重新绑定；否则获取一个空闲的 P 与当前 M 绑定。如果绑定成功，返回 &lt;code>True&lt;/code>，否则返回 &lt;code>False&lt;/code> 进行后续步骤处理。&lt;/li>
&lt;li>如果 &lt;code>exitsyscallfast&lt;/code> 返回 &lt;code>True&lt;/code> ，函数就直接返回；返回 &lt;code>False&lt;/code>，则进入 &lt;em>slow path&lt;/em> 将当前 goroutine 放到任务队列中等待调度，具体实现由 &lt;code>mcall(exitsyscall0)&lt;/code> 实现。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>exitsyscall0&lt;/code> 这个函数比较清晰，只是对其中 &lt;code>dropg()&lt;/code> 的目的还没想清楚。&lt;/p>
&lt;p>&lt;code>runtime·exitsyscall&lt;/code> 的函数说明中提到的 &lt;code>// Write barriers are not allowed because our P may have been stolen.&lt;/code> 也没有搞清楚，知道和 GC 有一定关系。&lt;/p>
&lt;h1 id="引用">引用&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://studygolang.com/articles/7005">https://studygolang.com/articles/7005&lt;/a>&lt;/li>
&lt;/ol></content></item><item><title>Golang 中学到的新东西</title><link>https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</link><pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/01/14/2018-01-14_golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</guid><description>数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&amp;amp;s[0]) var ptr unsafe.Pointer s := ((*[1&amp;lt;&amp;lt;10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(&amp;amp;s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;amp;o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.Data = uintptr(ptr) map 实现 整个页面的内容对我来说都是新的：https://tiancaiamao.</description><content>&lt;h1 id="数据类型">数据类型&lt;/h1>
&lt;h2 id="string-类型">&lt;code>string&lt;/code> 类型&lt;/h2>
&lt;p>&lt;code>string&lt;/code> 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。&lt;/p>
&lt;h2 id="slice-leftrightarrow-unsafepointer">&lt;code>slice&lt;/code> $\leftrightarrow$ &lt;code>unsafe.Pointer&lt;/code>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#ae81ff">200&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> ((&lt;span style="color:#f92672">*&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>]&lt;span style="color:#66d9ef">byte&lt;/span>)(&lt;span style="color:#a6e22e">ptr&lt;/span>))[:&lt;span style="color:#ae81ff">200&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">s1&lt;/span> = &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">len&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cap&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{&lt;span style="color:#a6e22e">ptr&lt;/span>, &lt;span style="color:#a6e22e">length&lt;/span>, &lt;span style="color:#a6e22e">length&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>[]&lt;span style="color:#66d9ef">byte&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">s1&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">o&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sliceHeader&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">SliceHeader&lt;/span>)((&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">o&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sliceHeader&lt;/span>.&lt;span style="color:#a6e22e">Cap&lt;/span> = &lt;span style="color:#a6e22e">length&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sliceHeader&lt;/span>.&lt;span style="color:#a6e22e">Len&lt;/span> = &lt;span style="color:#a6e22e">length&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sliceHeader&lt;/span>.&lt;span style="color:#a6e22e">Data&lt;/span> = uintptr(&lt;span style="color:#a6e22e">ptr&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="map-实现">&lt;code>map&lt;/code> 实现&lt;/h1>
&lt;p>整个页面的内容对我来说都是新的：https://tiancaiamao.gitbooks.io/go-internals/content/zh/02.3.html
不过这个页面描述的内容和最新的 Golang source 有一定差别。&lt;/p>
&lt;p>读 &lt;code>HashMap&lt;/code> 的实现，里面的一些核心关键词：&lt;code>bucket&lt;/code>、&lt;code>overflow&lt;/code> 让我理解起来有些困难。查询 &lt;code>HashMap&lt;/code> 相关的一些资料后有了进一步了解。&lt;/p>
&lt;ol>
&lt;li>&lt;code>bucket&lt;/code> 一般使用某种 &lt;code>array&lt;/code> 管理，从 &lt;code>key&lt;/code> 经过 &lt;code>hash-function&lt;/code> 映射的 &lt;code>hash-value&lt;/code>（可能截取一部分，也可以视作 sub-hash，我自己编的）作为 &lt;code>index&lt;/code> 直接得到。一个 &lt;code>bucket&lt;/code> 中可能包含多个不同的 &lt;code>hash-value&lt;/code> ，它们截取那一部分得到的 &lt;code>index&lt;/code> 相同。因此 &lt;code>bucket&lt;/code> 会用一个数据结构管理这些冲突的值，可能是 &lt;code>linked-list&lt;/code> 或者 &lt;code>tree-map&lt;/code> 之类的。这些内部的数据结构中的 &lt;code>node&lt;/code> 存储着真正对应 &lt;code>map&lt;/code> 的 &lt;code>key\value&lt;/code> 对(pair)。&lt;/li>
&lt;li>如果 &lt;code>bucket&lt;/code> 太满了，比如元素的数量超过 &lt;code>bucket&lt;/code> 数量一定倍数（&lt;code>load factor&lt;/code>），则会进行扩容，所有元素都被 &lt;code>rehashed&lt;/code> 到一个新的值。&lt;/li>
&lt;li>采用这种方式实现 &lt;code>HashMap&lt;/code>，&lt;code>bucket&lt;/code> 可以有两种选择：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>Direct chaining&lt;/strong> 只存一个指向冲突元素集合的 &lt;code>header&lt;/code>&lt;/li>
&lt;li>&lt;strong>Seperate Chaining&lt;/strong> 在 &lt;code>bucket&lt;/code> 存一部分（一个）元素集合（Golang &lt;code>HashMap&lt;/code> 实现里放了 8 个），和一个指向剩下冲突元素集合的 &lt;code>header&lt;/code>&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>上面 &lt;code>header&lt;/code> 指向的元素集合叫 &lt;code>overflow list&lt;/code> 或者 &lt;code>overflow some-other-data-structure&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>有了这些背景后，看代码应该会比较清晰了。&lt;/p>
&lt;p>目前 Golang 中的 &lt;code>bucket&lt;/code> 是为 &lt;code>insert&lt;/code> 操作优化的，找到第一个空余位置就可以插入，但是删除的时候要把所有相同 &lt;code>key&lt;/code> 的元素都删掉，要遍历 &lt;code>bucket&lt;/code> 的 &lt;code>overflow&lt;/code> 集合。&lt;/p>
&lt;p>如果 key 或者 value 小于 128 字节，那么它们是直接在 &lt;code>bucket&lt;/code> 存储值，否则存指向数据的指针。&lt;/p>
&lt;h1 id="nil-语义">&lt;code>nil&lt;/code> 语义&lt;/h1>
&lt;p>按照 Golang 规范，任何类型在未初始化时都对应一个零值：&lt;/p>
&lt;ul>
&lt;li>&lt;code>bool&lt;/code> $\rightarrow$ &lt;code>true&lt;/code>&lt;/li>
&lt;li>&lt;code>integer&lt;/code> $\rightarrow$ &lt;code>0&lt;/code>&lt;/li>
&lt;li>&lt;code>string&lt;/code> $\rightarrow$ &lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/li>
&lt;li>&lt;code>pointer&lt;/code>/&lt;code>function&lt;/code>/&lt;code>interface&lt;/code>/&lt;code>slice&lt;/code>/&lt;code>channel&lt;/code>/&lt;code>map&lt;/code> $\rightarrow$ &lt;code>nil&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="关于-interface">关于 &lt;code>interface{}&lt;/code>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#75715e">// v == nil
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} &lt;span style="color:#75715e">// i == nil
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span> = &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#75715e">// i != nil
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="关于-channel">关于 &lt;code>channel&lt;/code>&lt;/h2>
&lt;p>一些操作规则：&lt;/p>
&lt;ul>
&lt;li>读写一个 &lt;code>nil&lt;/code> 的 &lt;code>channel&lt;/code> 会立即阻塞&lt;/li>
&lt;li>读一个关闭的 &lt;code>channel&lt;/code> 会立刻返回一个 &lt;code>channel&lt;/code> 元素类型的零值，即 &lt;code>chan int&lt;/code> 会返回 &lt;code>0&lt;/code>&lt;/li>
&lt;li>写一个关闭的 &lt;code>channel&lt;/code> 会导致 &lt;code>panic&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="函数调用">函数调用&lt;/h1>
&lt;h2 id="汇编">汇编&lt;/h2>
&lt;p>可以看一下这个 Golang 的官方介绍页面：https://golang.org/doc/asm&lt;/p>
&lt;p>&lt;strong>add.go&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>) &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>add_amd64.s&lt;/strong> 或使用其他平台后缀，和 &lt;strong>add.go&lt;/strong> 在同一个目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">TEXT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">·&lt;/span>Add&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(SB),&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> a&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(FP),BX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> b&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>(FP),BP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ADDQ&lt;/span> BP,BX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BX,res&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">RET&lt;/span> ,
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="golang-调用-c">Golang 调用 C&lt;/h2>
&lt;p>&lt;strong>add.c&lt;/strong> ，和 &lt;strong>add.go&lt;/strong> 在同一个目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">·&lt;/span>Add(uint64 a, uint64 b, uint64 ret) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FLUSH(&lt;span style="color:#f92672">&amp;amp;&lt;/span>ret);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译这个包：&lt;code>go install add&lt;/code>&lt;/p>
&lt;p>C 文件中需要包含 &lt;code>runtime.h&lt;/code> 头文件。因为 Golang 使用特殊寄存器存放像全局 &lt;code>struct G&lt;/code> 和 &lt;code>struct M&lt;/code> ，包含这个文件可以让所有链接到 Go 的 C 文件感知这一点，避免编译器使用这些特定的寄存器做其他用途。&lt;/p>
&lt;p>上面示例中返回值为空，使用 &lt;code>ret&lt;/code> 作为返回值，&lt;code>FLUSH&lt;/code> 在 &lt;code>pkg/runtime/runtime.h&lt;/code> 中定义为 &lt;code>USED()&lt;/code> ，防止编译器优化掉对某个变量的赋值操作（因为看不到这个变量在后面其他地方使用了）。&lt;/p>
&lt;h2 id="函数调用时的内存布局">函数调用时的内存布局&lt;/h2>
&lt;p>Golang 中使用的 C 编译器是 plan9 的 C 编译器，与 gcc 有一定差异。
这个页面中有部分基础介绍：
&lt;a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.1.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.1.html&lt;/a>&lt;/p>
&lt;p>如果返回多个值，&lt;code>func f(a, b int) (d, e int)&lt;/code> 内存布局如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>slot for e
slot for d
b
a
&amp;lt;- SP
&lt;/code>&lt;/pre>&lt;p>调用后为&lt;/p>
&lt;pre tabindex="0">&lt;code>slot for e
slot for d
b
a &amp;lt;- FP
PC &amp;lt;- SP
f&amp;#39;s stack
&lt;/code>&lt;/pre>&lt;p>plan9 的 C 汇编器对被调用函数的参数值的修改是会返回到调用函数中的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BX,d&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BX,e&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="go-关键字">&lt;code>go&lt;/code> 关键字&lt;/h1>
&lt;p>&lt;code>f(1, 2, 3)&lt;/code> 的汇编:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> f(SB)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>go f(1, 2, 3)&lt;/code> 的汇编：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVL&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PUSHQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>f(SB)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PUSHQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> runtime.newproc(SB)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">POPQ&lt;/span> AX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">POPQ&lt;/span> AX
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>12&lt;/code> 是参数占用的大小，&lt;code>runtime.newproc&lt;/code> 函数接受的参数为：参数大小、新的 goroutine 要运行的函数、函数的参数。&lt;code>runtime.newproc&lt;/code> 会新建一个栈空间，将栈参数的 12 个字节复制到新的栈空间，并让栈指针指向参数。可以看做 &lt;code>runtime.newproc(size, f, args)&lt;/code> 。&lt;/p>
&lt;h1 id="defer-关键字">&lt;code>defer&lt;/code> 关键字&lt;/h1>
&lt;p>&lt;code>return x&lt;/code> 不是原子语句，函数执行顺序为：&lt;/p>
&lt;ol>
&lt;li>给返回值赋值&lt;/li>
&lt;li>&lt;code>defer&lt;/code> 调用&lt;/li>
&lt;li>&lt;code>return&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>&lt;code>defer&lt;/code> 实现对应 &lt;code>runtime.deferproc&lt;/code>，其出现的地方插入指令 &lt;code>call runtime.deferproc&lt;/code> ，函数返回之前的地方，插入 &lt;code>call runtime.deferreturn&lt;/code> 。 goroutine 的控制结构中有一张表记录 &lt;code>defer&lt;/code>，表以栈行为运作。&lt;/p>
&lt;h1 id="continuous-stack">Continuous Stack&lt;/h1>
&lt;p>我也基本理解了思路，具体细节可以看：https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html&lt;/p>
&lt;p>最后的 &lt;code>runtime.lessstack&lt;/code> 有些没看懂。&lt;/p>
&lt;h1 id="闭包">闭包&lt;/h1>
&lt;p>闭包中引用的变量不能在栈上分配，否则闭包函数返回的时候，栈上变量的地址就失效了。&lt;/p>
&lt;h2 id="逃逸分析escape-analyze">逃逸分析（escape analyze）&lt;/h2>
&lt;p>Golang 有个特性，可以自动识别哪些变量在栈上分配，哪些在堆上分配。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Cursor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">Cursor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">X&lt;/span> = &lt;span style="color:#ae81ff">500&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">noinline&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>type.&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.Cursor&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(SB),(SP) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">取变量&lt;/span>c的类型&lt;span style="color:#960050;background-color:#1e0010">，也就是&lt;/span>Cursor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> ,runtime.new(SB) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">调用&lt;/span>new函数&lt;span style="color:#960050;background-color:#1e0010">，相当于&lt;/span>new(Cursor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>(SP),AX &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">取&lt;/span>c.X的地址放到AX寄存器
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">500&lt;/span>,(AX) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">将&lt;/span>AX&lt;span style="color:#960050;background-color:#1e0010">存放的内存地址的值赋为&lt;/span>&lt;span style="color:#ae81ff">500&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> AX,&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.~r0&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ADDQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>,SP
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在编译的过程中可以通过指令输出哪些变量逃逸了：&lt;code>go build --gcflags=-m main.go&lt;/code>&lt;/p>
&lt;h2 id="闭包结构体">闭包结构体&lt;/h2>
&lt;p>闭包将函数和它引用的环境表示为一个结构体：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Closure&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">F&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>()()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>整体思路是返回闭包的时候，返回一个结构体，包含闭包返回函数的地址和引用的环境中的变量地址。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">func&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-nasm" data-lang="nasm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>type.int&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(SB),(SP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> ,runtime.new(SB) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">是不是很熟悉，这一段就是&lt;/span>i &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span> new(int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>type.struct &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span> F uintptr&lt;span style="color:#75715e">; A0 *int }+0(SB),(SP) // 这个结构体就是闭包的类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">CALL&lt;/span> ,runtime.new(SB) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">接下来相当于&lt;/span> new(Closure)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">PCDATA&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>(SP),AX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">NOP&lt;/span> ,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.func&lt;span style="color:#960050;background-color:#1e0010">·&lt;/span>&lt;span style="color:#ae81ff">001&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>(SB),BP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BP,(AX) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">函数地址赋值给&lt;/span>Closure的F部分
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">NOP&lt;/span> ,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.&lt;span style="color:#f92672">&amp;amp;&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>(SP),BP &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">将堆中&lt;/span>new的变量i的地址赋值给Closure的值部分
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> BP,&lt;span style="color:#ae81ff">8&lt;/span>(AX)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">MOVQ&lt;/span> AX,&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.~r1&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>(FP)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ADDQ&lt;/span> &lt;span style="color:#66d9ef">$&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>,SP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">RET&lt;/span> ,
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="引用">引用&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://tiancaiamao.gitbooks.io/go-internals">https://tiancaiamao.gitbooks.io/go-internals&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/07_Hashing_Chaining.pdf">http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/07_Hashing_Chaining.pdf&lt;/a>&lt;/li>
&lt;/ol></content></item><item><title>使用 Nvidia 显卡加速机器学习算法的一些资料</title><link>https://blog.formalscience.com/2018/01/13/2018-01-13_%E4%BD%BF%E7%94%A8-nvidia-%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/</link><pubDate>Sat, 13 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/01/13/2018-01-13_%E4%BD%BF%E7%94%A8-nvidia-%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/</guid><description>Nnidia 显卡可以用来加速机器学习算法（特别是深度学习），但安装驱动过程中总会碰到这样或者那样的问题。 一个难点是安装库的时候没有下载链接，比如 Nvidia 的 Cuda/cuDNN 主页经常会出现这样的提示：
NVIDIA Developer Site is under going maintenance. The site will be back by shortly. We apologize for any inconvenience. 虽然不能按照官方路径进行下载，但经过搜索总能找到一些入口。下面是我收集的一些链接：
cuDNN 下载页面：https://developer.nvidia.com/rdp/cudnn-download 这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 cuDNN v5.1 到 cuDNN 7.0.5 的版本 CUDA 下载页面：https://developer.nvidia.com/cuda-toolkit-archive 这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 CUDA Toolkit 1.0 到 CUDA Toolkit 9.0 的版本，最新的 CUDA Toolkit 9.1 的链接仍然指向正在维护的提示页面 Ubuntu 16.04 CUDA Toolkit 9.1 下载链接：http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_9.1.85-1_amd64.deb 此外可以在这个页面找到其他 Linux 发行版的安装包：http://developer.download.nvidia.com/compute/cuda/repos/ Windows 10 版本的 CUDA Toolkit 9.1 我成功下载过一次，但是和当前的 TensorFlow 1.</description><content>&lt;p>Nnidia 显卡可以用来加速机器学习算法（特别是深度学习），但安装驱动过程中总会碰到这样或者那样的问题。
一个难点是安装库的时候没有下载链接，比如 Nvidia 的 Cuda/cuDNN 主页经常会出现这样的提示：&lt;/p>
&lt;pre tabindex="0">&lt;code>NVIDIA Developer Site is under going maintenance.
The site will be back by shortly.
We apologize for any inconvenience.
&lt;/code>&lt;/pre>&lt;p>虽然不能按照官方路径进行下载，但经过搜索总能找到一些入口。下面是我收集的一些链接：&lt;/p>
&lt;ul>
&lt;li>cuDNN
&lt;ul>
&lt;li>下载页面：https://developer.nvidia.com/rdp/cudnn-download&lt;/li>
&lt;li>这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 &lt;code>cuDNN v5.1&lt;/code> 到 &lt;code>cuDNN 7.0.5&lt;/code> 的版本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CUDA
&lt;ul>
&lt;li>下载页面：https://developer.nvidia.com/cuda-toolkit-archive&lt;/li>
&lt;li>这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 &lt;code>CUDA Toolkit 1.0&lt;/code> 到 &lt;code>CUDA Toolkit 9.0&lt;/code> 的版本，最新的 &lt;code>CUDA Toolkit 9.1&lt;/code> 的链接仍然指向&lt;em>正在维护&lt;/em>的提示页面&lt;/li>
&lt;li>Ubuntu 16.04 &lt;code>CUDA Toolkit 9.1&lt;/code> 下载链接：http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_9.1.85-1_amd64.deb&lt;/li>
&lt;li>此外可以在这个页面找到其他 Linux 发行版的安装包：http://developer.download.nvidia.com/compute/cuda/repos/&lt;/li>
&lt;li>Windows 10 版本的 &lt;code>CUDA Toolkit 9.1&lt;/code> 我成功下载过一次，但是和当前的 &lt;code>TensorFlow 1.4&lt;/code> 不兼容，刚才发现之前组合出来的下载链接无效了。如果找到链接会补充上。当前可用 &lt;code>cuDNN v6.1&lt;/code> 和 &lt;code>CUDA Toolkit 8.0 GA2&lt;/code> 版本。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content></item><item><title>一些有趣的项目 Protocol Labs</title><link>https://blog.formalscience.com/2018/01/12/2018-01-12_%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE_protocol_labs/</link><pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/01/12/2018-01-12_%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE_protocol_labs/</guid><description>最初在 3Blue1Brown 发布的一个介绍区块链原理的视频中看到了这个组织的连接。发现比较有意思，给大家分享一下~
项目的使命：
We believe the internet has become humanity&amp;rsquo;s most important technology. We build protocols, systems, and tools to improve how it works. Today, we are focused on how we store, locate, and move information.
我们相信互联网已成为人类最重要的技术。我们构建提升互联网工作能力的协议、系统和工具。当前我们集中在如何存储、定位和移动信息的工作上。
这段文字翻译得有点机器翻译风格。
项目地址：https://protocol.ai/projects/ ，目前上面有 5 个项目：
Filecoin 加密货币，Miners 通过向网络提供存储空间来获取 Filecoin ，使用者通过消耗 Filecoin 来在去中心化的网络中存储加密后的文件。 IPFS (InterPlanetary File System) 一种新型协议，用来使网络去中心化。IPFS 通过内容寻址和数字签名来创建完全去中心化和分布式的应用。IPFS 使得网络更快、更安全以及更加开放。 这是一段 YouTube 上的介绍视频：https://www.youtube.com/watch?v=8CMxDNuuAiQ ，介绍了 IPFS 的一些基本使用方法。根据我的理解，这是通过 content-address（immutable hash） 访问的分布式加密文件系统，可以通过命令行、网页界面等多种方式进行访问，有点类似 Samba，不过是分布式的。Siraj Raval 制作的一个视频：https://www.youtube.com/watch?v=BA2rHlbB5i0 ，也对 IPFS 进行了介绍，主要对 Why 的部分进行阐述。 带宽，多个客户端对中心节点访问 延迟 弹性 Resiliency，中心节点失效（网络断开或者数据删除）后无法进行数据访问 中心化 Centralization，主流网站掌控所有数据，用户无从得知数据的使用方式，此外会受到政府或者其他势力的干扰。 使用的技术：Chord、DHT、bit swap(bittorrent mechanism)、MerkleDAG Libp2p 一个模块化的网络栈，把一系列传输协议和 peer-to-peer 协议整合在一起，方便开发者构建大型、健壮的 p2p 网络 IPLD 去中心化网络（content-addressable web）的数据模型，它通过加密哈希值的方式连接了所有数据，使得数据的遍历和彼此链接更加容易。网站的示意图中连接了 bitcoin、以太坊、IPFS、Git Repo 等。 Multiformats 这个项目是面向未来验证系统（future-proof systems）的协议集合， 自描述的格式可以让你的系统可以互操作和具有可升级性。</description><content>&lt;p>最初在 3Blue1Brown 发布的一个介绍区块链原理的视频中看到了这个组织的连接。发现比较有意思，给大家分享一下~&lt;/p>
&lt;p>项目的使命：&lt;/p>
&lt;blockquote>
&lt;p>We believe the internet has become humanity&amp;rsquo;s most important technology. We build protocols, systems, and tools to improve how it works. Today, we are focused on how we store, locate, and move information.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>我们相信互联网已成为人类最重要的技术。我们构建提升互联网工作能力的协议、系统和工具。当前我们集中在如何存储、定位和移动信息的工作上。&lt;/p>
&lt;/blockquote>
&lt;p>这段文字翻译得有点机器翻译风格。&lt;/p>
&lt;p>项目地址：https://protocol.ai/projects/ ，目前上面有 5 个项目：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Filecoin&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>加密货币，Miners 通过向网络提供存储空间来获取 &lt;code>Filecoin&lt;/code> ，使用者通过消耗 &lt;code>Filecoin&lt;/code> 来在&lt;strong>去中心化的&lt;/strong>网络中存储加密后的文件。&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>&lt;strong>IPFS&lt;/strong> (InterPlanetary File System)&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>一种新型协议，用来使网络去中心化。IPFS 通过内容寻址和数字签名来创建完全去中心化和分布式的应用。IPFS 使得网络更快、更安全以及更加开放。&lt;/li>
&lt;li>这是一段 YouTube 上的介绍视频：https://www.youtube.com/watch?v=8CMxDNuuAiQ ，介绍了 IPFS 的一些基本使用方法。根据我的理解，这是通过 content-address（immutable hash） 访问的分布式加密文件系统，可以通过命令行、网页界面等多种方式进行访问，有点类似 Samba，不过是分布式的。Siraj Raval 制作的一个视频：https://www.youtube.com/watch?v=BA2rHlbB5i0 ，也对 IPFS 进行了介绍，主要对 &lt;strong>Why&lt;/strong> 的部分进行阐述。
&lt;ul>
&lt;li>带宽，多个客户端对中心节点访问&lt;/li>
&lt;li>延迟&lt;/li>
&lt;li>弹性 Resiliency，中心节点失效（网络断开或者数据删除）后无法进行数据访问&lt;/li>
&lt;li>中心化 Centralization，主流网站掌控所有数据，用户无从得知数据的使用方式，此外会受到政府或者其他势力的干扰。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用的技术：Chord、DHT、bit swap(bittorrent mechanism)、MerkleDAG&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>&lt;strong>Libp2p&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>一个模块化的网络栈，把一系列传输协议和 peer-to-peer 协议整合在一起，方便开发者构建大型、健壮的 p2p 网络&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>&lt;strong>IPLD&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>去中心化网络（content-addressable web）的数据模型，它通过加密哈希值的方式连接了所有数据，使得数据的遍历和彼此链接更加容易。网站的示意图中连接了 bitcoin、以太坊、IPFS、Git Repo 等。&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>&lt;strong>Multiformats&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>这个项目是面向未来验证系统（future-proof systems）的协议集合， 自描述的格式可以让你的系统可以互操作和具有可升级性。&lt;/li>
&lt;/ul></content></item><item><title>Ingress_Passcode_自动提交</title><link>https://blog.formalscience.com/2017/01/18/2017-01-18_ingress-passcode-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/</link><pubDate>Wed, 18 Jan 2017 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2017/01/18/2017-01-18_ingress-passcode-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/</guid><description>什么是 Passcode？ 根据 Ingress 中文游戏指南 的讲解，Passcode 是 Ingress 提供的一种奖励。
使用 Investigation Board 来了解 Ingress 的最新剧情并寻求对 Niantic Project, NIA, XM, Shapers 以及各阵营不同问题的答案。 可以使用隐藏在这些报告之中的 Passcode 来兑换道具（Resonator，XMP 等），XM 或者 AP。
另外，一些官方活动会向到场者赠送包含 Passcode 的卡片，特定的官方周边也会赠送此类卡片。卡片上的 Passcode 一般能够兑换活动徽章。
注：在很多社交网站上可以找到有效的 Passcode
在 iOS 平台的 Ingress 客户端上 Passcode 兑换功能不可用，因此只能使用 Intel Map 来兑换。
在 Intel Map 上兑换 在右上方点击 Passcode 输入你的 passcode，然后点击 SUBMIT 兑换 自动化 Intel Map 兑换过程 可以通过浏览器的调试页面，自动将搜寻到的 passcode 提交，进行物品兑换。
表单提交 document.getElementById(&amp;#34;redeem_reward_form&amp;#34;).submit(); 不能正确提交表单失败的原因是这个表单的 input 元素名称就是 submit，需要重命名。
var field = document.</description><content>&lt;h2 id="什么是-passcode">什么是 Passcode？&lt;/h2>
&lt;p>根据 &lt;a href="https://www.gitbook.com/book/hz-ingress/ingress-tutorial/">Ingress 中文游戏指南&lt;/a> 的讲解，Passcode 是 Ingress 提供的一种奖励。&lt;/p>
&lt;blockquote>
&lt;p>使用 Investigation Board 来了解 Ingress 的最新剧情并寻求对 Niantic Project, NIA, XM, Shapers 以及各阵营不同问题的答案。 可以使用隐藏在这些报告之中的 Passcode 来兑换道具（Resonator，XMP 等），XM 或者 AP。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>另外，一些官方活动会向到场者赠送包含 Passcode 的卡片，特定的官方周边也会赠送此类卡片。卡片上的 Passcode 一般能够兑换活动徽章。&lt;/p>
&lt;/blockquote>
&lt;p>注：在很多社交网站上可以找到有效的 Passcode&lt;/p>
&lt;p>在 iOS 平台的 Ingress 客户端上 Passcode 兑换功能不可用，因此只能使用 Intel Map 来兑换。&lt;/p>
&lt;h2 id="在-intel-map-上兑换">在 Intel Map 上兑换&lt;/h2>
&lt;ol>
&lt;li>在右上方点击 Passcode&lt;/li>
&lt;li>输入你的 passcode，然后点击 SUBMIT 兑换&lt;/li>
&lt;/ol>
&lt;h2 id="自动化-intel-map-兑换过程">自动化 Intel Map 兑换过程&lt;/h2>
&lt;p>可以通过浏览器的调试页面，自动将搜寻到的 passcode 提交，进行物品兑换。&lt;/p>
&lt;ol>
&lt;li>表单提交&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;redeem_reward_form&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">submit&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不能正确提交表单失败的原因是这个表单的 &lt;code>input&lt;/code> 元素名称就是 &lt;code>submit&lt;/code>，需要重命名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">field&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;chicken&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">field&lt;/span>.&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;horse&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// using element properties
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">field&lt;/span>.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;horse&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// using .setAttribute() method
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;chicken&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">setAttribte&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;name&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;horse&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;redeem_reward_form&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">submit&lt;/span>.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;submit_code&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些都不太管用，应该是 form 之前的 submit 属性已经被设置了，改了名字也不能绑定 submit 方法了。:|&lt;/p>
&lt;p>有效的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;redeem_reward_form&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">submit&lt;/span>.&lt;span style="color:#a6e22e">click&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>每隔一段时间自动提交一个 passcode&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">codes&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;DEADDROP7DT73AM6&amp;#39;&lt;/span>]; &lt;span style="color:#75715e">//Here put the number of times you want to auto submit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">submitPasscode&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">codes&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;redeem_reward_form&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">passcode&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">codes&lt;/span>[&lt;span style="color:#a6e22e">count&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;redeem_reward_form&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">submit&lt;/span>.&lt;span style="color:#a6e22e">click&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">count&lt;/span>&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">submitPasscode&lt;/span>, &lt;span style="color:#ae81ff">3000&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>((Math.&lt;span style="color:#a6e22e">random&lt;/span>() &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">500&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);); &lt;span style="color:#75715e">//Each second
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>})();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>增加一个输入窗口，用来输入获得的 Passcodes&lt;/li>
&lt;/ol>
&lt;p>Passcode 收集过来后一行一行整理好：&lt;/p>
&lt;pre tabindex="0">&lt;code>ada3zc36qq9
ada9yv83mp5
algorithm9ek27ux3
algorithm9gh35cj3
artifact3ne73hh3
bletchley9ob65ca4
blue2xc26da2
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">susubmitPasscodes&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">codes&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;passcodesArea&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">value&lt;/span>.&lt;span style="color:#a6e22e">replace&lt;/span>( &lt;span style="color:#e6db74">/\n/g&lt;/span>, &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> ).&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Submit code count: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">codes&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">submitPasscode&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">codes&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">count&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">alert&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;All passcodes are processed.&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;redeem_reward_form&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">passcode&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">codes&lt;/span>[&lt;span style="color:#a6e22e">count&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Submit code: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">codes&lt;/span>[&lt;span style="color:#a6e22e">count&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;redeem_reward_form&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">submit&lt;/span>.&lt;span style="color:#a6e22e">click&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">count&lt;/span>&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">submitPasscode&lt;/span>, &lt;span style="color:#ae81ff">25000&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>((Math.&lt;span style="color:#a6e22e">random&lt;/span>() &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">25000&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">submitPasscode&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">passcodeBox&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;header_passcode_box&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">passcodesArea&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;textarea&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">passcodesArea&lt;/span>.&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;passcodesArea&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">passcodeBox&lt;/span>.&lt;span style="color:#a6e22e">appendChild&lt;/span>(&lt;span style="color:#a6e22e">passcodesArea&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">batchSubmit&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;button&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//&amp;lt;button onclick=&amp;#34;myFunction()&amp;#34;&amp;gt;Click me&amp;lt;/button&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">batchSubmit&lt;/span>.&lt;span style="color:#a6e22e">type&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;button&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">batchSubmit&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;batch-submit&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">batchSubmit&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Submit&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">batchSubmit&lt;/span>.&lt;span style="color:#a6e22e">onclick&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">susubmitPasscodes&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">batchSubmit&lt;/span>.&lt;span style="color:#a6e22e">textContent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;batchSubmit&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">passcodeBox&lt;/span>.&lt;span style="color:#a6e22e">appendChild&lt;/span>(&lt;span style="color:#a6e22e">batchSubmit&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>如何构建一个 Java Agent</title><link>https://blog.formalscience.com/2017/01/16/2017-01-16_%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA_java_agent/</link><pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2017/01/16/2017-01-16_%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA_java_agent/</guid><description>First. Implement a static premain (as an analogy to main) method, like this:
import java.lang.instrument.Instrumentation; class Example { public static void premain(String args, Instrumentation inst) { ... } } Second. Create a manifest file (say, manifest.txt) marking this class for pre-main execution. Its contents are:
Premain-Class: Example
Third. Compile the class and package this class into a JAR archive:
javac Example.java jar cmf manifest.txt yourAwesomeAgent.jar *.class
Fourth. Execute your JVM whith -javaagent parameter, like this:</description><content>&lt;p>First. Implement a static premain (as an analogy to main) method, like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.lang.instrument.Instrumentation&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Example&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">premain&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String args&lt;span style="color:#f92672">,&lt;/span> Instrumentation inst&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Second. Create a manifest file (say, manifest.txt) marking this class for pre-main execution. Its contents are:&lt;/p>
&lt;p>&lt;code>Premain-Class: Example&lt;/code>&lt;/p>
&lt;p>Third. Compile the class and package this class into a JAR archive:&lt;/p>
&lt;p>&lt;code>javac Example.java&lt;/code>
&lt;code>jar cmf manifest.txt yourAwesomeAgent.jar *.class&lt;/code>&lt;/p>
&lt;p>Fourth. Execute your JVM whith -javaagent parameter, like this:&lt;/p>
&lt;p>&lt;code>java -javaagent:yourAwesomeAgent.jar -jar yourApp.jar&lt;/code>&lt;/p></content></item><item><title>Windows 推荐软件</title><link>https://blog.formalscience.com/2016/09/16/2016-09-16_windows_%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6/</link><pubDate>Fri, 16 Sep 2016 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2016/09/16/2016-09-16_windows_%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6/</guid><description>在知乎上看了一些推荐
Total Commander Listary AutoHotKey Internet Download Manager paint.net pot player Tickeys 7-zip Beyond Compare PowerTab (Powershell auto complete) Fiddler ZoomIt Postman - Chrome 里的 HTTP/REST 客户端，Web 服务专用神器 Pixie - 简单，可爱，便携的取色器 快捷键
Windows+Tab调出虚拟桌面 Alt+Tab 切换不同的窗口 Windows+Ctrl+D 创建新的虚拟桌面 Windows+Ｃtrl+F4 关闭当前虚拟桌面 Ctrl＋Windows＋左右箭头　虚拟桌面切换</description><content>&lt;p>在知乎上看了一些推荐&lt;/p>
&lt;ul>
&lt;li>Total Commander&lt;/li>
&lt;li>Listary&lt;/li>
&lt;li>&lt;a href="https://www.autohotkey.com/docs/scripts/index.htm">AutoHotKey&lt;/a>&lt;/li>
&lt;li>Internet Download Manager&lt;/li>
&lt;li>paint.net&lt;/li>
&lt;li>pot player&lt;/li>
&lt;li>Tickeys&lt;/li>
&lt;li>7-zip&lt;/li>
&lt;li>Beyond Compare&lt;/li>
&lt;li>PowerTab (Powershell auto complete)&lt;/li>
&lt;li>Fiddler&lt;/li>
&lt;li>ZoomIt&lt;/li>
&lt;li>Postman - Chrome 里的 HTTP/REST 客户端，Web 服务专用神器&lt;/li>
&lt;li>Pixie - 简单，可爱，便携的取色器&lt;/li>
&lt;/ul>
&lt;p>快捷键&lt;/p>
&lt;ul>
&lt;li>Windows+Tab调出虚拟桌面&lt;/li>
&lt;li>Alt+Tab 切换不同的窗口&lt;/li>
&lt;li>Windows+Ctrl+D 创建新的虚拟桌面&lt;/li>
&lt;li>Windows+Ｃtrl+F4 关闭当前虚拟桌面&lt;/li>
&lt;li>Ctrl＋Windows＋左右箭头　虚拟桌面切换&lt;/li>
&lt;/ul></content></item><item><title>为什么 Haskell 中 函数类型 不是 “Show” 类型类的实例</title><link>https://blog.formalscience.com/2016/02/03/2016-02-03_%E4%B8%BA%E4%BB%80%E4%B9%88_haskell_%E4%B8%AD_%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B_%E4%B8%8D%E6%98%AF_show_%E7%B1%BB%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B/</link><pubDate>Wed, 03 Feb 2016 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2016/02/03/2016-02-03_%E4%B8%BA%E4%BB%80%E4%B9%88_haskell_%E4%B8%AD_%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B_%E4%B8%8D%E6%98%AF_show_%E7%B1%BB%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B/</guid><description>问题 为什么函数类型不是 show 类型类的实例以显示参数和值的类型？
为什么我不能在 GHCi 或者 Hugs 中输入 \x -&amp;amp;gt; x + x ，在结果中看到同样的表达式形式作为输出。
为什么存在一个 Show 实例，却只打印函数的类型？
Prelude&amp;amp;gt; :m + Text.Show.Functions Prelude Text.Show.Functions&amp;amp;gt; show Char.ord &amp;quot;&amp;amp;lt;function&amp;amp;gt;&amp;quot; `&amp;lt;/pre&amp;gt; 如何让 lambdabot 有如下显示： &amp;lt;pre&amp;gt;`dons &amp;amp;gt; ord lambdabot&amp;amp;gt; &amp;amp;lt;Char -&amp;amp;gt; Int&amp;amp;gt; `&amp;lt;/pre&amp;gt; # 答案 ## 实践中的答案 Haskell 编译器并不保持表达式原本的形式，而是将它们转成机器代码或者其他的底层表示。 函数 `\x -&amp;amp;gt; x - x + x :: Int -&amp;amp;gt; Int` 也许被优化成 `\x -&amp;amp;gt; x :: Int -&amp;amp;gt; Int` 。没有那个地方l存储了变量名 `x` 。 你也许会想，Haskell 是一门脚本语言，在运行时环境中维护着表达式的内容。情况并非如此，[Lambda 表达式](https://wiki.</description><content>&lt;h1 id="问题">问题&lt;/h1>
&lt;p>为什么函数类型不是 &lt;code>show&lt;/code> 类型类的实例以显示参数和值的类型？&lt;/p>
&lt;p>为什么我不能在 GHCi 或者 Hugs 中输入 &lt;code>\x -&amp;amp;gt; x + x&lt;/code> ，在结果中看到同样的表达式形式作为输出。&lt;/p>
&lt;p>为什么存在一个 Show 实例，却只打印函数的类型？&lt;/p>
&lt;pre>&lt;code>Prelude&amp;amp;gt; :m + Text.Show.Functions
Prelude Text.Show.Functions&amp;amp;gt; show Char.ord
&amp;quot;&amp;amp;lt;function&amp;amp;gt;&amp;quot;
`&amp;lt;/pre&amp;gt;
如何让 lambdabot 有如下显示：
&amp;lt;pre&amp;gt;`dons &amp;amp;gt; ord
lambdabot&amp;amp;gt; &amp;amp;lt;Char -&amp;amp;gt; Int&amp;amp;gt;
`&amp;lt;/pre&amp;gt;
# 答案
## 实践中的答案
Haskell 编译器并不保持表达式原本的形式，而是将它们转成机器代码或者其他的底层表示。
函数 `\x -&amp;amp;gt; x - x + x :: Int -&amp;amp;gt; Int` 也许被优化成 `\x -&amp;amp;gt; x :: Int -&amp;amp;gt; Int` 。没有那个地方l存储了变量名 `x` 。
你也许会想，Haskell 是一门脚本语言，在运行时环境中维护着表达式的内容。情况并非如此，[Lambda 表达式](https://wiki.haskell.org/Lambda_abstraction)仅仅是[匿名函数](https://wiki.haskell.org/Anonymous_function)。你没可能在运行时环境中查询变量的名字，或者观察函数定义的结构。你也不能从程序员用户那里接收一个表达式，调用你程序中的变量，然后求值。即，Haskell 不是[反射的](https://wiki.haskell.org/index.php?title=Reflexive_language&amp;amp;amp;action=edit&amp;amp;amp;redlink=1 &amp;quot;Reflexive_language&amp;amp;amp;action=edit&amp;amp;amp;redlink=1&amp;quot;)。一切都是可编译的。一个例外是 [hs-plugins](https://wiki.haskell.org/index.php?title=Hs-plugins&amp;amp;amp;action=edit&amp;amp;amp;redlink=1 &amp;quot;Hs-plugins&amp;amp;amp;action=edit&amp;amp;amp;redlink=1&amp;quot;)
## 理论上的答案
函数式编程是关于函数的。一个数学函数是由它的图通过二元组（参数，值）完全定义的。即：
- ![\sqrt{\ } = &amp;amp;#123;(0,0), (1,1), (4,2), (9,3), \dots &amp;amp;#125;](https://wiki.haskell.org/wikiupload/math/7/a/9/7a95d49d189193b2987374c4bcd3d186.png)
- ![ (\lambda x.\ x+x) = &amp;amp;#123;(0,0), (1,2), (2,4), (3,6), \dots &amp;amp;#125; ](https://wiki.haskell.org/wikiupload/math/e/a/f/eaf7cde16e0aa626caa2b0365e0a79b1.png)
既然图 ![ \mathrm{show}(\lambda x.\ x+x) \ne \mathrm{show}(\lambda x.\ 2\cdot x) ](https://wiki.haskell.org/wikiupload/math/5/3/e/53ef58b99d9d9b4a63006980946855b9.png) 和 ![ \lambda x.\ 2\cdot x ](https://wiki.haskell.org/wikiupload/math/e/3/8/e38a5466b5a1b4d3c8339d700ac9d939.png) 是等价的，因为它们都表示了同样的函数。想象一下如果两个项都按照其形式被 GHCi 或 Hugs 显示，这就意味着等价的函数导致了不同的输出。交互式的 Haskell 环境使用通常的 `show` 函数，这也意味着 ![ \mathrm{show}(\lambda x.\ x+x) \ne \mathrm{show}(\lambda x.\ 2\cdot x) ](https://wiki.haskell.org/wikiupload/math/d/2/1/d21e1b708260732dd43095f9f7b1c881.png) 。这将打破[引用透明](https://wiki.haskell.org/Referential_transparency)。这也意味着显示函数的唯一可行方式是显示定义它们的图：
&amp;lt;pre&amp;gt;`Prelude&amp;amp;gt; \x -&amp;amp;gt; x+x
functionFromGraph [(0,0), (1,2), (2,4), (3,6),
Interrupted.
&lt;/code>&lt;/pre>
&lt;p>能够实现这个功能的代码在 &lt;a href="http://hackage.haskell.org/package/universe-reverse-instances">universe-reverse-instances&lt;/a> 包中有。（这个包在安装 &lt;a href="http://hackage.haskell.org/package/universe">universe&lt;/a> 包时会被安装）&lt;/p>
&lt;h1 id="引用">引用&lt;/h1>
&lt;p>&lt;a href="https://wiki.haskell.org/Show_instance_for_functions">https://wiki.haskell.org/Show_instance_for_functions&lt;/a>
&lt;a href="http://www.haskell.org/pipermail/haskell-cafe/2006-April/015161.html">http://www.haskell.org/pipermail/haskell-cafe/2006-April/015161.html&lt;/a>&lt;/p></content></item><item><title>函数式语言课程期末考试判卷中遇到的一个问题</title><link>https://blog.formalscience.com/2016/02/03/2016-02-03_%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%88%A4%E5%8D%B7%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 03 Feb 2016 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2016/02/03/2016-02-03_%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%88%A4%E5%8D%B7%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</guid><description>在使用半自动化 Judge 系统对同学的答题进行评测的时候，遇到了一个奇怪的问题，总是会提示: Test_1: output.txt: openFile: resource busy (file is locked)
起初以为是 haskell 惰性求值导致的 IO 问题，因为搜索引擎也把猜测引导向这个原因，但是始终解决不了。
后来改变了思路，“现在看来好像是模块引入带来的 main 函数重名问题”，这是后面的猜疑。
继而发现将函数改名字也解决不了问题，实际也不是，就是 IO 的问题。因为如果先移除 output.txt， 那么使用 ghc 执行就不会出现之前的错误提示，不过在 ghci 中执行总是不会出错。
使用如下代码测试一下：
dir = &amp;quot;/home/user-name/Downloads/auto_check/work/2015final/ref/tests/words&amp;quot; main :: IO () main = do print &amp;quot;hehe&amp;quot; solution = runTest (map (\f -&amp;amp;gt; combine dir f) [&amp;quot;input1-1.txt&amp;quot;, &amp;quot;input1-2.txt&amp;quot;, &amp;quot;input1-3.txt&amp;quot;]) (combine dir &amp;quot;output1.txt&amp;quot;) `&amp;lt;/pre&amp;gt; 执行得到如下结果： &amp;lt;pre&amp;gt;`➜ test ghci Test_1.hs GHCi, version 7.8.4: http://www.haskell.org/ghc/ :? for help Loading package ghc-prim .</description><content>&lt;p>在使用半自动化 Judge 系统对同学的答题进行评测的时候，遇到了一个奇怪的问题，总是会提示:
&lt;code>Test_1: output.txt: openFile: resource busy (file is locked)&lt;/code>&lt;/p>
&lt;hr>
&lt;p>起初以为是 haskell 惰性求值导致的 IO 问题，因为搜索引擎也把猜测引导向这个原因，但是始终解决不了。&lt;/p>
&lt;hr>
&lt;p>后来改变了思路，“现在看来好像是模块引入带来的 main 函数重名问题”，这是后面的猜疑。&lt;/p>
&lt;hr>
&lt;p>继而发现将函数改名字也解决不了问题，实际也不是，就是 IO 的问题。因为如果先移除 output.txt， 那么使用 ghc 执行就不会出现之前的错误提示，不过在 ghci 中执行总是不会出错。&lt;/p>
&lt;p>使用如下代码测试一下：&lt;/p>
&lt;pre>&lt;code>dir = &amp;quot;/home/user-name/Downloads/auto_check/work/2015final/ref/tests/words&amp;quot;
main :: IO ()
main = do print &amp;quot;hehe&amp;quot;
solution = runTest
(map (\f -&amp;amp;gt; combine dir f) [&amp;quot;input1-1.txt&amp;quot;, &amp;quot;input1-2.txt&amp;quot;, &amp;quot;input1-3.txt&amp;quot;])
(combine dir &amp;quot;output1.txt&amp;quot;)
`&amp;lt;/pre&amp;gt;
执行得到如下结果：
&amp;lt;pre&amp;gt;`➜ test ghci Test_1.hs
GHCi, version 7.8.4: http://www.haskell.org/ghc/ :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 3] Compiling Main ( Main.hs, interpreted )
[2 of 3] Compiling FileBasedTest ( FileBasedTest.hs, interpreted )
[3 of 3] Compiling Test ( Test_1.hs, interpreted )
Ok, modules loaded: Test, FileBasedTest, Main.
*Test&amp;amp;gt; main
Loading package array-0.5.0.0 ... linking ... done.
Loading package deepseq-1.3.0.2 ... linking ... done.
Loading package old-locale-1.0.0.6 ... linking ... done.
Loading package time-1.4.2 ... linking ... done.
Loading package bytestring-0.10.4.0 ... linking ... done.
Loading package unix-2.7.0.1 ... linking ... done.
Loading package filepath-1.3.0.2 ... linking ... done.
Loading package directory-1.2.1.0 ... linking ... done.
&amp;quot;hehe&amp;quot;
*Test&amp;amp;gt;
Leaving GHCi.
➜ test rm Test_1.hi
➜ test ghc Test_1.hs -o Test_1
[3 of 3] Compiling Test ( Test_1.hs, Test_1.o )
Linking Test_1 ...
➜ test ./Test_1
Test_1: output.txt: openFile: resource busy (file is locked)
➜ test
&lt;/code>&lt;/pre>
&lt;p>可以看到直接执行 ghc 编译得到的二进制文件就会出现问题，而在 ghci 中就不会。&lt;/p>
&lt;hr>
&lt;p>经过了一些过程之后终于修复，根本原因是，整个项目的程序入口是 test01.hs 中 Test 模块的 main 函数，而引入了同学实现的代码中的 Main 模块，导致 ghc 编译的时候使用 Main 模块中的 main 函数作为入口。最后通过指定那个模块中的 main 函数作为入口解决：
&lt;code>ghc -main-is Test.main Test_1.hs -o Test_1&lt;/code>&lt;/p></content></item><item><title>關於 LLVM Pass 的一些基本操作</title><link>https://blog.formalscience.com/2016/01/09/2016-01-09_%E9%97%9C%E6%96%BC_llvm_pass_%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 09 Jan 2016 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2016/01/09/2016-01-09_%E9%97%9C%E6%96%BC_llvm_pass_%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid><description>關於 LLVM Pass 的一些基本操作 記錄一下關於 LLVM Pass 的一些操作，主要是一些配置工作。雖然目前的工作流程不是很優雅，但是可以自定義 LLVM Pass 的處理過程，通過進一步學習可以作出更有意思的東西。
本文的 GitHub 地址： https://github.com/ronhuafeng/HandleLLVMPassBasic ，有這篇文章和一些粗糙的源代碼。
網絡上已經有一下教程了，我也參考了這些教程。
使用 clang 加載 LLVM 的 Pass LLVM - Run Own Pass automatically with clang stack overflow 上的回答，試圖使用 clang 加載 LLVM 的 Pass。 Polly 库加載 LLVM Pass 的方法也是一个解决思路，我參考了這裏面的很多：Load Polly into clang and automatically run it at -O3 具体的加載過程參考了 Adrian Sampson 博客 Run an LLVM Pass Automatically with Clang 中提到的操作。 工作流程 準備工作 將系統中自帶的 llvm 和 clang 都卸載掉，保證 llvm 和 clang 版本的一致性（非常重要），即保證使用的 clang 和 編譯出的 Pass 的動態鏈接庫文件 .</description><content>&lt;h1 id="關於-llvm-pass-的一些基本操作">關於 LLVM Pass 的一些基本操作&lt;/h1>
&lt;p>記錄一下關於 LLVM Pass 的一些操作，主要是一些配置工作。雖然目前的工作流程不是很優雅，但是可以自定義 LLVM Pass 的處理過程，通過進一步學習可以作出更有意思的東西。&lt;/p>
&lt;p>本文的 GitHub 地址： &lt;a href="https://github.com/ronhuafeng/HandleLLVMPassBasic">https://github.com/ronhuafeng/HandleLLVMPassBasic&lt;/a> ，有這篇文章和一些粗糙的源代碼。&lt;/p>
&lt;p>網絡上已經有一下教程了，我也參考了這些教程。&lt;/p>
&lt;h2 id="使用-clang-加載-llvm-的-pass">使用 clang 加載 LLVM 的 Pass&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://stackoverflow.com/questions/23130821/llvm-run-own-pass-automatically-with-clang">LLVM - Run Own Pass automatically with clang&lt;/a>
stack overflow 上的回答，試圖使用 clang 加載 LLVM 的 Pass。&lt;/li>
&lt;li>Polly 库加載 LLVM Pass 的方法也是一个解决思路，我參考了這裏面的很多：&lt;a href="http://polly.llvm.org/example_load_Polly_into_clang.html">Load Polly into clang and automatically run it at -O3&lt;/a>&lt;/li>
&lt;li>具体的加載過程參考了 Adrian Sampson 博客 &lt;a href="http://adriansampson.net/blog/clangpass.html">Run an LLVM Pass Automatically with Clang&lt;/a> 中提到的操作。&lt;/li>
&lt;/ul>
&lt;h1 id="工作流程">工作流程&lt;/h1>
&lt;h2 id="準備工作">準備工作&lt;/h2>
&lt;p>將系統中自帶的 llvm 和 clang 都卸載掉，保證 llvm 和 clang 版本的一致性（非常重要），即保證使用的 clang 和 編譯出的 Pass 的動態鏈接庫文件 .so 的一致性。&lt;/p>
&lt;p>下載 LLVM 帶有 clang 的源碼，解壓縮到某個目錄，我解壓到了 &lt;em>~/Projects/llvm-3.7.0.src&lt;/em> 。如果沒有的話可以下載對應版本的 clang 源碼放到 llvm 下的 tools 目錄下面，具體參考這個教程： &lt;a href="http://clang.llvm.org/get_started.html">Getting Started: Building and Running Clang&lt;/a> 。&lt;/p>
&lt;p>應該是使用下面的幾個命令編譯下項目：&lt;/p>
&lt;pre>&lt;code>mkdir build
cd build
../configure
cmake ..
`&amp;lt;/pre&amp;gt;
然後執行 `make` 或者 `make -jn` （n 爲並行編譯參數，我的 CPU 是 _4 核 Intel(R) Xeon(R) CPU E3-1225 V2 @ 3.20GHz_ ，使用了 `make -j2`，因爲還要同時做其他事情）。
編譯完成後就可以使用 `make install` 進行安裝了。由於 Ubuntu 的庫中自帶 clang 是 3.6 版，所以一開始這裏繞了一些彎路。
## 將一個 C 文件編譯成 LLVM 的 Bitcode
`clang -emit-llvm -c hello.c -o hello.bc`
_hello.c_
&amp;lt;pre&amp;gt;`#include &amp;quot;stdio.h&amp;quot;
int main()
{
int a = 0;
if (a == 1)
return 0;
if (a == 2)
return 0;
if (a == 3)
return 0;
return 0;
}
`&amp;lt;/pre&amp;gt;
## 自定義 LLVM Pass
這部分網絡上有很多教程，就不多說了，教程都比較詳細。
我實現了一個 FunctionPass，主要就是給每個 main 函數中的 BasicBlock 添加上名字，然後插入一條打印指令，打印出這個名字和迷之數字 42 。
代碼放在最後吧，畢竟比較長。
[實現代碼](#PassCode)
最後的註冊 Pass 的部分：
&amp;lt;pre&amp;gt;`char MyInstrument::ID = 0;
static RegisterPass&amp;amp;lt;MyInstrument&amp;amp;gt; Z(&amp;quot;MyInstrument&amp;quot;, &amp;quot;MyInstrument Pass&amp;quot;, false, false);
static void registerMyPass(const PassManagerBuilder &amp;amp;amp;, legacy::PassManagerBase &amp;amp;amp;PM) {
PM.add(new MyInstrument());
}
static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerMyPass);
`&amp;lt;/pre&amp;gt;
## 編譯自定義的 LLVM Pass
由於沒有成功爲 LLVM 項目配置好 [_Clion_(a c++ IDE)](https://www.jetbrains.com/clion/) cmake 的 Makefile （這一點是由於對 cmake 和 makefile 不瞭解的緣故），所以只能採用某種方式繞過。
假設已經把 LLVM 的源碼下載在某個目錄，把自己修改的 Pass 文件複製到 LLVM 源碼樹下 Pass 的對應文件夾，然後編譯。
&amp;lt;pre&amp;gt;`cp ~/ClionProjects/LLVMPass/ListBasicBlock/ListBasicBlock.cpp ~/Projects/llvm-3.7.0.src/lib/Transforms/Mypass/Mypass.cpp;
cd ~/Projects/llvm-3.7.0.src/build/lib/Transforms/Mypass/;
make
`&amp;lt;/pre&amp;gt;
這樣會得到 _~/Projects/llvm-3.7.0.src/build/lib/LLVMMypass.so_ 。
## 執行自定義 Pass
&amp;lt;pre&amp;gt;`opt -load ~/Projects/llvm-3.7.0.src/build/lib/LLVMMypass.so -MyInstrument &amp;amp;lt;hello.bc -o new_hello.bc
`&amp;lt;/pre&amp;gt;
## 編譯得到可執行文件
調用 LLVM 的靜態編譯器 llc，`llc new_hello.bc`，然後編譯得到可執行文件 _a.out_，`clang new_hello.s` 。
## 執行可執行文件
`./a.out` 可以得到輸出
&amp;lt;pre&amp;gt;`main_0 42
main_02 42
main_04 42
main_06 42
main_07 42
`&amp;lt;/pre&amp;gt;
到此爲止就基本結束了，至於如果按照自定義需求修改 Pass 是就要繼續學習了。
* * *
## 附錄
### &amp;lt;a name=&amp;quot;PassCode&amp;quot;/&amp;gt;實現代碼
&amp;lt;pre&amp;gt;`//===- Mypass.cpp - Example code from &amp;quot;Writing an LLVM Pass&amp;quot; ---------------===//
//
// The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements two versions of the LLVM &amp;quot;Mypass&amp;quot; pass described
// in docs/WritingAnLLVMPass.html
//
//===----------------------------------------------------------------------===//
#include &amp;quot;llvm/Transforms/Instrumentation.h&amp;quot;
#include &amp;quot;llvm/ADT/Statistic.h&amp;quot;
#include &amp;quot;llvm/IR/Function.h&amp;quot;
#include &amp;quot;llvm/IR/Module.h&amp;quot;
#include &amp;quot;llvm/Pass.h&amp;quot;
#include &amp;quot;llvm/IR/BasicBlock.h&amp;quot;
#include &amp;quot;llvm/IR/DebugInfo.h&amp;quot;
#include &amp;quot;llvm/IR/DebugLoc.h&amp;quot;
#include &amp;quot;llvm/IR/IRBuilder.h&amp;quot;
#include &amp;quot;llvm/IR/InstIterator.h&amp;quot;
#include &amp;quot;llvm/IR/Instructions.h&amp;quot;
#include &amp;quot;llvm/IR/IntrinsicInst.h&amp;quot;
#include &amp;quot;llvm/Support/raw_ostream.h&amp;quot;
#include &amp;amp;lt;llvm/IR/GlobalVariable.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/LLVMContext.h&amp;amp;gt;
#include &amp;amp;lt;llvm/Pass.h&amp;amp;gt;
#include &amp;amp;lt;llvm/ADT/SmallVector.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/CallingConv.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/Constants.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/DerivedTypes.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/Function.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/GlobalVariable.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/IRPrintingPasses.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/InlineAsm.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/Instructions.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/LLVMContext.h&amp;amp;gt;
#include &amp;amp;lt;llvm/IR/Module.h&amp;amp;gt;
#include &amp;amp;lt;llvm/Support/FormattedStream.h&amp;amp;gt;
#include &amp;amp;lt;llvm/Support/MathExtras.h&amp;amp;gt;
#include &amp;amp;lt;algorithm&amp;amp;gt;
#include &amp;quot;llvm/IR/Type.h&amp;quot;
#include &amp;quot;llvm/IR/DerivedTypes.h&amp;quot;
#include &amp;quot;llvm/IR/LegacyPassManager.h&amp;quot;
#include &amp;quot;llvm/Transforms/IPO/PassManagerBuilder.h&amp;quot;
using namespace llvm;
using namespace llvm;
#define DEBUG_TYPE &amp;quot;mypass&amp;quot;
STATISTIC(MypassCounter, &amp;quot;Counts number of functions greeted&amp;quot;);
namespace {
// MyInstrument - Try to construct a pass to instrument log information.
struct MyInstrument : public FunctionPass {
static char ID;
MyInstrument() : FunctionPass(ID) {}
Function * getPrintF(IRBuilder&amp;amp;lt;&amp;amp;gt; &amp;amp;amp;Builder, Module *M) {
const char *Name = &amp;quot;printf&amp;quot;;
Function *F = M-&amp;amp;gt;getFunction(Name);
if (!F) {
GlobalValue::LinkageTypes Linkage = Function::ExternalLinkage;
FunctionType *Ty = FunctionType::get(Builder.getInt32Ty(), true);
F = Function::Create(Ty, Linkage, Name, M);
}
return F;
}
void createPrintF(IRBuilder&amp;amp;lt;&amp;amp;gt; &amp;amp;amp;Builder,
std::string Format,
ArrayRef&amp;amp;lt;Value *&amp;amp;gt; Values,
Module *M) {
Value *FormatString = Builder.CreateGlobalStringPtr(Format);
std::vector&amp;amp;lt;Value *&amp;amp;gt; Arguments;
Arguments.push_back(FormatString);
Arguments.insert(Arguments.end(), Values.begin(), Values.end());
Builder.CreateCall(getPrintF(Builder, M), Arguments);
}
bool runOnFunction(Function&amp;amp;amp; F) override {
MypassCounter++;
// 如果不是 main 函數，就不做處理
if (F.getName().equals(&amp;quot;main&amp;quot;) == false)
{
return false;
}
// 獲取 printf 函數
Module* m = F.getParent();
Function* printFun = m-&amp;amp;gt;getFunction(&amp;quot;printf&amp;quot;);
if (nullptr == printFun)
{
errs() &amp;amp;lt;&amp;amp;lt; &amp;quot;printf function not get.&amp;quot; &amp;amp;lt;&amp;amp;lt; '\n';
}
///////////////////////////////////////////
Module* mod = F.getParent();
BasicBlock * pb = nullptr;
errs() &amp;amp;lt;&amp;amp;lt; &amp;quot;Function is: &amp;quot; &amp;amp;lt;&amp;amp;lt; F.getName() &amp;amp;lt;&amp;amp;lt; '\n';
// 按照如下格式重命名 BasicBlock
// Name each basic block in the format 'FunctionName_BasicBlockID'
int count;
count = 0;
for (Function::iterator b: F)
{
pb = b;
IRBuilder&amp;amp;lt;&amp;amp;gt; Builder(pb);
b-&amp;amp;gt;setName(F.getName() + &amp;quot;_&amp;quot; + Twine(count));
}
// 依次在每個 BasicBlock 處插入打印語句
count = 0;
for (Function::iterator b : F)
{
pb = b;
IRBuilder&amp;amp;lt;&amp;amp;gt; Builder(pb);
Builder.SetInsertPoint(pb, pb-&amp;amp;gt;begin());
std::vector&amp;amp;lt;Value *&amp;amp;gt; ArgsV;
Twine format(pb-&amp;amp;gt;getName());
format.concat(&amp;quot; %d\n&amp;quot;);
//errs() &amp;amp;lt;&amp;amp;lt; format.str() &amp;amp;lt;&amp;amp;lt; '\n';
std::string formatStr = pb-&amp;amp;gt;getName().str();
formatStr += &amp;quot;\t%d \n&amp;quot;;
Value *FormatString = Builder.CreateGlobalStringPtr(formatStr);
ArgsV.push_back(FormatString);
ArgsV.push_back(Builder.getInt32(42));
Builder.CreateCall(getPrintF(Builder, mod), ArgsV);
}
return true;
}
};
}
char MyInstrument::ID = 0;
static RegisterPass&amp;amp;lt;MyInstrument&amp;amp;gt; Z(&amp;quot;MyInstrument&amp;quot;, &amp;quot;MyInstrument Pass&amp;quot;, false, false);
static void registerMyPass(const PassManagerBuilder &amp;amp;amp;,
legacy::PassManagerBase &amp;amp;amp;PM) {
PM.add(new MyInstrument());
}
static RegisterStandardPasses
RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,
registerMyPass);
&lt;/code>&lt;/pre></content></item><item><title>Thinkpad T430 Windows&amp;Ubuntu Dual Boot</title><link>https://blog.formalscience.com/2015/12/11/2015-12-11_thinkpad_t430_windowsubuntu_dual_boot/</link><pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2015/12/11/2015-12-11_thinkpad_t430_windowsubuntu_dual_boot/</guid><description>在 Thinkpad T430 带有原装操作系统（其实是原声的 EFI 分区）的情形下，UEFI 模式下安装 Ubuntu 并成功启动进入 Ubuntu 系统。主要难度是原装电脑启动时会首先加载一个 “LenovoBT.efi” 的文件，然后 Lenovo 直接会去找 Windows 系统相关的 efi 文件，然后忽略其他的系统。T440s 预装win8.1 GPT+EFI ubuntu 双系统 图文过程中提到这样的启动处理：
加载 /EFI/Boot/LenovoBT.EFI /EFI/Boot/bootx64.efi，加载windows的boot loader /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi，启动windows 因此这个文档记录了如何把这个流程给截断，使得 Ubuntu 的启动引导文件可以被看到。
首先说明没有起作用的教程：
Windows 10 Pro + Ubuntu 14.04.3 LTS 雙系統安裝 中提到最后在 Windows 的命令行中使用如下命令 bcdedit /set {bootmgr} path \EFI\ubuntu\grubx64.efi 并没有生效 百度贴吧一个教程 - T440s 预装win8.1 GPT+EFI ubuntu 双系统 图文过程 中提到使用 Ubuntu 的引导文件 “grubx64.efi” 替换 “EFI/Boot” 里面的 “bootx64.efi”，没有效果，可能是 “LenovoBT.efi” 没有走前文提到的处理流程。 有效的教程 Windows 8 removes Grub as default boot manager：</description><content>&lt;p>在 Thinkpad T430 带有原装操作系统（其实是原声的 EFI 分区）的情形下，UEFI 模式下安装 Ubuntu 并成功启动进入 Ubuntu 系统。主要难度是原装电脑启动时会首先加载一个 “LenovoBT.efi” 的文件，然后 Lenovo 直接会去找 Windows 系统相关的 efi 文件，然后忽略其他的系统。&lt;a href="http://tieba.baidu.com/p/2805772637">T440s 预装win8.1 GPT+EFI ubuntu 双系统 图文过程&lt;/a>中提到这样的启动处理：&lt;/p>
&lt;ol>
&lt;li>加载 /EFI/Boot/LenovoBT.EFI&lt;/li>
&lt;li>/EFI/Boot/bootx64.efi，加载windows的boot loader&lt;/li>
&lt;li>/boot/efi/EFI/Microsoft/Boot/bootmgfw.efi，启动windows&lt;/li>
&lt;/ol>
&lt;p>因此这个文档记录了如何把这个流程给截断，使得 Ubuntu 的启动引导文件可以被看到。&lt;/p>
&lt;p>首先说明没有起作用的教程：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://blog.birkhoff.me/windows-10-and-ubuntu-14_04_3-lts-dual-boot/">Windows 10 Pro + Ubuntu 14.04.3 LTS 雙系統安裝&lt;/a> 中提到最后在 Windows 的命令行中使用如下命令 &lt;code>bcdedit /set {bootmgr} path \EFI\ubuntu\grubx64.efi&lt;/code> 并没有生效&lt;/li>
&lt;li>百度贴吧一个教程 - &lt;a href="http://tieba.baidu.com/p/2805772637">T440s 预装win8.1 GPT+EFI ubuntu 双系统 图文过程&lt;/a> 中提到使用 Ubuntu 的引导文件 “grubx64.efi” 替换 “EFI/Boot” 里面的 “bootx64.efi”，没有效果，可能是 “LenovoBT.efi” 没有走前文提到的处理流程。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>有效的教程 &lt;a href="http://askubuntu.com/questions/235567/windows-8-removes-grub-as-default-boot-manager">Windows 8 removes Grub as default boot manager&lt;/a>：&lt;/p>
&lt;p>I can make no promises, but try this from a Windows Command Prompt window launched with Administrator privileges:&lt;/p>
&lt;p>&lt;code>bcdedit /set {bootmgr} path \EFI\ubuntu\grubx64.efi&lt;/code>&lt;/p>
&lt;p>Note that {bootmgr} should be typed exactly; that&amp;rsquo;s not a variable. If that doesn&amp;rsquo;t work, you could try this in Linux:&lt;/p>
&lt;ol>
&lt;li>Back up the entire contents of /boot/efi (your EFI System Partition, or ESP).&lt;/li>
&lt;li>Type &lt;code>sudo mv /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi /boot/efi/EFI/Microsoft&lt;/code>.&lt;/li>
&lt;li>Type &lt;code>cp /boot/efi/EFI/ubuntu/grubx64.efi /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi&lt;/code>.&lt;/li>
&lt;li>Create a new /etc/grub.d/40_custom file entry that refers to EFI/Microsoft/bootmgfw.efi. Model it after the existing entry in /boot/grub/grub.cfg that refers to EFI/Microsoft/Boot/bootmgfw.efi; just remove Boot from the boot path and give the entry a new name.&lt;/li>
&lt;li>Type &lt;code>sudo update-grub&lt;/code> to install the new GRUB entry.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>上面的流程进行完第三步就足够了。&lt;/p>
&lt;p>关键技术点：&lt;/p>
&lt;ol>
&lt;li>关闭 Windows 的“安全启动”&lt;/li>
&lt;li>CSM Support 这个可以开启也可以关闭&lt;/li>
&lt;li>UEFI 模式下安装好 Ubuntu 后，再次使用 Live USB 进入 UBuntu 系统，将 Windows 的 EFI 分区挂载，进行文件替换操作&lt;/li>
&lt;li>虽然不推荐，但是可以在 &lt;code>sudo update-grub&lt;/code> 后直接修改 /boot/grub/grub.cfg ，将其中的 Windows EFI 文件地址修正为真正的 EFI 文件所在位置（我的是 /boot/efi/EFI/Microsoft/bootmgfw.efi）。这样做不太好，因为这个文件是用 /etc/grub.d/ 下的文件自动生成出来的，正确的做法是去那个文件夹下面增加或者修改一个 Entry 。&lt;/li>
&lt;/ol></content></item><item><title>那些关于函数式编程和函数式编程语言的神话（译）</title><link>https://blog.formalscience.com/2015/10/22/2015-10-22_%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/</link><pubDate>Thu, 22 Oct 2015 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2015/10/22/2015-10-22_%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/</guid><description>这是翻译自 Quora 一个问题 “What are some myths about functional programming and functional programming languages?” 的一个高票答案，我也不记得当初决定翻译它时的心情，不过历经多次组会，最终完工了。
下面是我能想到的，更具体的一些细节会在后面给出：
“函数式编程”是定义明确的概念 函数式编程仅仅是命令式编程的特殊形式 函数式编程本来就很难 函数式编程本来就是复杂的 函数式编程不宜编写图形用户界面 Haskell 仅仅是函数式的 你需要大量的数学知识来进行函数式编程 函数式程序员必须非常聪明而且擅长计算机科学 “函数式编程” 是一个（明确的）概念 它不是。它是计算机科学中定义最糟糕的术语之一 —— 甚至不如“面向对象”，但比“声明式编程”好一点点。弄清楚一种语言是否是“函数式的”是一个人类学（anthropology）上的练习而非计算机科学。
没有任何一种“函数式编程”的技术定义不会引发众人抱怨。有些定义过于宽泛 —— 如果你想要的是 lambda 表达式，那么一切从 C ++ 到 Java 到 Python 的语言突然都变得“函数式”了，只有 C 和汇编不是！如果你要一个数学上的定义，那么只有 Coq、Agda 和它们的朋友们是函数式的，因为就算是 Haskell 都允许部分函数和非终止性。还有异常。哦，上帝，异常！
就我个人来讲，称每一种带有“脉冲”的语言（即任何具有 lambda 表达式的语言，lambda 的符号为 λ，像一个脉冲）为“函数式的”并没什么用。当我说“函数式的”，我通常是指像 Haskell 或至少是 ML 的语言，而不是像 Java、Python、 JavaScript，或者甚至是 Common Lisp 的语言。Scheme 和 Clojure 有点是函数式的，但我不会对它们谈论过多，即便我的确有大量关于前者（Scheme）的经验。
好吧，实话说，我的意思只是“Haskell”，除非我明确提出不是。是啊，这是为了你们的语言学上的定义。（脑补出这个翻译）如果你花更少的时间用命令式语言和更多的时间阅读我的思维，你就会明白3。
当然，有些人倾向于给“函数式编程”一个更杂糅的定义！
函数式编程仅仅是少了某些东西的命令式编程 这也许是最有害的神话，因为它广泛流传，特别具有误导性，通常未被明确说出。人们随意假设进行函数式编程就像一个穿着紧身衣的“正常”编程。并不是！一点也不。相反，函数式编程为编程提供了一个新的基础。你使用不同的方式表达事情。通常是全然不同的。事实上，大多数时间，在你使用命令式方法完成的事情和使用函数式方法完成的事情之间，不存在一个一一映射。
在 Haskell 上这点最明显，因为它是唯一把函数式特性放在第一位的语言 。这实际上让 Haskell 比混合语言明显更有表达能力 —— 从确定性的并行到重写规则（即矢量融合）到 软件事务性内存（STM，Software Transactional Memory）到惰性（计算）到它大量的库，这一切都是因为 Haskell 的函数式核心才成为可能。同时，这也使得 Haskell 与其他语言如此不同。这是一种完全不同的思考方式，一个新的基础 —— 不是同样香肠的不同型号，就如许多其他的语言一样（还有 BMWs5）。</description><content>&lt;p>这是翻译自 Quora 一个问题&lt;a href="https://www.quora.com/What-are-some-myths-about-functional-programming-and-functional-programming-languages"> “What are some myths about functional programming and functional programming languages?” &lt;/a>的一个高票答案，我也不记得当初决定翻译它时的心情，不过历经多次组会，最终完工了。&lt;/p>
&lt;hr>
&lt;p>下面是我能想到的，更具体的一些细节会在后面给出：&lt;/p>
&lt;ul>
&lt;li>“函数式编程”是定义明确的概念&lt;/li>
&lt;li>函数式编程仅仅是命令式编程的特殊形式&lt;/li>
&lt;li>函数式编程本来就很难&lt;/li>
&lt;li>函数式编程本来就是复杂的&lt;/li>
&lt;li>函数式编程不宜编写图形用户界面&lt;/li>
&lt;li>Haskell 仅仅是函数式的&lt;/li>
&lt;li>你需要大量的数学知识来进行函数式编程&lt;/li>
&lt;li>函数式程序员必须非常聪明而且擅长计算机科学&lt;/li>
&lt;/ul>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程---是一个明确的概念函数式编程-是一个明确的概念">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B---%E6%98%AF%E4%B8%80%E4%B8%AA%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A6%82%E5%BF%B5">&lt;/a>“函数式编程” 是一个（明确的）概念&lt;/h2>
&lt;p>它不是。它是计算机科学中定义最糟糕的术语之一 —— 甚至不如“面向对象”，但比“声明式编程”好一点点。弄清楚一种语言是否是“函数式的”是一个&lt;strong>人类学&lt;/strong>（anthropology）上的练习而非计算机科学。&lt;/p>
&lt;p>&lt;strong>没有任何一种&lt;/strong>“函数式编程”的技术定义不会引发众人抱怨。有些定义过于宽泛 —— 如果你想要的是 lambda 表达式，那么一切从 C ++ 到 Java 到 Python 的语言突然都变得“函数式”了，只有 C 和汇编不是！如果你要一个数学上的定义，那么只有 Coq、Agda 和它们的朋友们是函数式的，因为就算是 Haskell 都允许部分函数和非终止性。还有异常。哦，上帝，异常！&lt;/p>
&lt;p>就我个人来讲，称每一种带有“脉冲”的语言（即任何具有 lambda 表达式的语言，lambda 的符号为 λ，像一个脉冲）为“函数式的”并没什么用。当我说“函数式的”，我通常是指像 Haskell 或至少是 ML 的语言，而不是像 Java、Python、 JavaScript，或者甚至是 Common Lisp 的语言。Scheme 和 Clojure 有点是函数式的，但我不会对它们谈论过多，即便我的确有大量关于前者（Scheme）的经验。&lt;/p>
&lt;p>好吧，实话说，我的意思只是“Haskell”，除非我明确提出不是。是啊，这是为了你们的语言学上的定义。（脑补出这个翻译）如果你花更少的时间用命令式语言和更多的时间阅读我的思维，你就会明白&lt;!-- raw HTML omitted -->3&lt;!-- raw HTML omitted -->。&lt;/p>
&lt;p>当然，有些人倾向于给“函数式编程”一个更杂糅的定义！&lt;/p>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程仅仅是少了某些东西的命令式编程函数式编程仅仅是少了某些东西的命令式编程">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%BB%85%E4%BB%85%E6%98%AF%E5%B0%91%E4%BA%86%E6%9F%90%E4%BA%9B%E4%B8%9C%E8%A5%BF%E7%9A%84%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B">&lt;/a>函数式编程仅仅是少了某些东西的命令式编程&lt;/h2>
&lt;p>这也许是最有害的神话，因为它广泛流传，特别具有误导性，通常未被明确说出。人们随意假设进行函数式编程就像一个穿着紧身衣的“正常”编程。并不是！一点也不。相反，函数式编程为编程提供了一个&lt;strong>新的基础&lt;/strong>。你使用不同的方式表达事情。通常是全然不同的。事实上，大多数时间，在你使用命令式方法完成的事情和使用函数式方法完成的事情之间，不存在一个一一映射。&lt;/p>
&lt;p>在 Haskell 上这点最明显，因为它是唯一把函数式特性放在第一位的语言 。这实际上让 Haskell 比混合语言明显更有表达能力 —— 从&lt;a href="https://www.quora.com/Haskell/What-are-the-novel-ideas-and-profound-insights-in-the-design-of-the-Haskell-programming-language/answer/Tikhon-Jelvis?srid=p9P3&amp;amp;share=1">确定性的并行&lt;/a>到重写规则（即矢量融合）到 软件事务性内存（STM，Software Transactional Memory）到惰性（计算）到它大量的库，这一切都是因为 Haskell 的函数式核心才成为可能。同时，这也使得 Haskell 与其他语言如此不同。这是一种完全不同的思考方式，一个新的基础 —— 不是同样香肠的不同型号，就如许多其他的语言一样（还有 BMWs&lt;!-- raw HTML omitted -->5&lt;!-- raw HTML omitted -->）。&lt;/p>
&lt;p>这使我想起一个小的主题神话： Haskell 和不纯的函数式语言之间的差异仅仅是是（纯净）程度上的，而非类别上的 。这绝对不真实。根据我的经验，Haskell 的纯（函数式）和惰性（计算）与 OCaml 或 Scala 等类似语言，存在与生俱来的实践和哲学上的重大差异。多范型语言的倡导者喜欢声称函数式和命令式都支持才最好，但并不是；在许多方面来看，Haskell 比混合语言表达能力更强。&lt;/p>
&lt;p>例如，Haskell 中可以很容易地将计算具体化（reify）为数据，这可以得到更加模块化的代码。这可以很容易地将一个计算的定义与其求值解耦和。列表通常以数据结构的形式替代循环；树可以表示复杂的递归函数。反过来，这使得任意类型上的 &lt;code>fold&lt;/code> 和 &lt;code>unfold&lt;/code> 操作在 Haskell 中比在其他语言中更强有力。&lt;/p>
&lt;p>在类如 Scala 的语言中尝试模拟 Haskell 风格的函数式编程并不容易。Edward Kmett —— 一个领先的开源 Haskell 开发者 —— 甚至走得更远，他重写了一个新的 JVM 语言来克服这些限制；可以看一下他的关于&lt;a href="http://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu">“为何 Scala 不够”&lt;/a> 的这一点上细致详细的论述。&lt;/p>
&lt;p>寓意：&lt;strong>不纯粹（的函数式特性）并没得到完全性的胜利；它不仅在安全性上做出了巨大牺牲，同时在表达能力上也是。&lt;/strong> 当然，不纯粹性也使得一些代码的实现更容易，但其中的大部分都被 Haskell 中的特性覆盖了，例如状态线程（ST，state threads）或者 IO。&lt;/p>
&lt;p>所有这一切，也忽略了一些其他功能，哈斯克尔我提到这取决于纯度或懒惰像载体的融合，重写规则或确定性的并行性。&lt;/p>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程原本就难函数式编程原本就难">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%8E%9F%E6%9C%AC%E5%B0%B1%E9%9A%BE">&lt;/a>函数式编程原本就难&lt;/h2>
&lt;p>函数式编程与大多数人习惯的编程方式差别很大。很多人发现学习函数式编程很难，因为这就像&lt;strong>完全重新学习如何编程&lt;/strong>。回忆一下你学习第一门语言时的感受，那么可以想象你将重新体验一遍。当然了，这看上去会很难！&lt;/p>
&lt;p>从 Java 迁移到 C# 很简单。从 Java 到 Python 需要一点智力上的迁移，但是基本上还是那回事。甚至从 C 到 Java 也不太糟 —— 从概念的角度考虑，Java 是在和 C 同样的基础上增加的概念，两者都有变量、控制结构和表达式。从你最初学习的语言到当今流行的新命令式语言，这个过程是渐进的。&lt;/p>
&lt;p>函数式编程并不是这样，这就像从你脚下抽走地毯一样。最基础的想法都被完全替换掉了。不再有语句（statement），不再有循环（loop），不再有变量。见鬼，不再有程序执行 —— 对于一段函数式程序，你不是运行它，而是对它求值。事实上，对于一门类如 Haskell 的语言，求值的顺序是在你的抽象层次之下的，并不影响你的程序的所作所为 —— 执行的顺序控制了作用（effect）何时发生，其同表达式怎样被求值是完全分离的。这意味着你书写程序的顺序很大程度上不再重要，而这对于命令式程序员来说很奇怪，因为命令式的思考方式要求你时刻将程序的执行顺序记在脑中。&lt;/p>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程本质就是复杂的函数式编程本质就是复杂的">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E5%A4%8D%E6%9D%82%E7%9A%84">&lt;/a>函数式编程本质就是复杂的&lt;/h2>
&lt;p>同时，“复杂”也是“困难”的代名词。Rich Hickey 的“简单导致容易（Simple Made Easy）”&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->的演讲精彩地阐述了“复杂”和“困难”的关系。前者（简单还是复杂）是系统的一个属性，粗略地说，就是它有多大。后者是人的一个属性 —— 一件事情有多难很大程度上依赖于其经验和接受的教育。&lt;/p>
&lt;p>有些人切身感觉函数式语言很难。但这并不意味着它是复杂的！事实上，你可以把一门类如 Haskell 语言的核心求值规则和类型规则塞到一张纸上。当然，你必须使用非常精确的数学符号才行，但这也仅在规则比较少时行得通。对 ML 语言也是如此。诚然，任何在现实世界中使用的语言，包括 Haskell，都会迅速滋长额外的复杂度。但至少，函数式语言依旧可以基于 λ 演算，保持一个最小的、简单的以及良好定义的内核 —— 这是命令式语言不能声称的特性。&lt;/p>
&lt;p>一个重要的概念是实现的简单和语义的简洁的差别。函数式语言意在后者：它们以更复杂的运行时环境或编译器为代价，来追求更加一致的行为。命令式语言（以 Google 的 Go 语言作为一个极端例子）通常采用相反的方针：比起语义的简洁，更加注重实现上的简单。它们选择了不一致和未定义的行为，来换取一种简单的实现，此外还期待一种更加简单的与硬件的映射。&lt;/p>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式编程适合编写图形用户界面gui函数式编程适合编写图形用户界面gui">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%80%82%E5%90%88%E7%BC%96%E5%86%99%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2gui">&lt;/a>函数式编程适合编写图形用户界面（GUI）&lt;/h2>
&lt;p>函数式编程用来编写 GUI 再合适不过了！我们只是采用不同的方式而已。我们有一个编写 GUI 代码的全新&lt;!-- raw HTML omitted -->6&lt;!-- raw HTML omitted -->范式：函数反应式编程（FRP）。FRP 使 GUI 代码更简单，更加模块化，更具声明式特性。&lt;/p>
&lt;p>GUI 代码是对时间的建模。使用命令式语言，时间是使用可改变的状态和回掉函数被隐式建模的。其中时间确凿无疑地是一个二等公民。这使得我们不能直接谈论时间，不可避免陷入回掉函数错综复杂的泥潭，纠缠在严重耦合的全局状态之中。当然如果你很小心，这可能只会变成半全局状态。你甚至不能拿一个变量，然后声称“当 x 大于 7 时，让这个变量变红；否则使它变蓝”。相反，你需要相当多的“仪式”以及外部结构来把 x 封装在一个模型之中（或者其他什么东西之中），还要带上事件监听器（event listeners）和常用的访问器（accessors）。&lt;/p>
&lt;p>而使用 FRP，时间是你可以精确表示出来的东西。这就是我所说的让时间成为“一等公民”：你可以编写代码，直接引用变量值在时间上的行为。&lt;/p>
&lt;p>查看&lt;a href="https://www.quora.com/What-is-Functional-Reactive-Programming">什么是函数反应式编程？&lt;/a>以及我的生命游戏中的例子 &lt;a href="http://jelv.is/frp/">FPR | jelv.is&lt;/a> （带有完整的代码&lt;a href="https://github.com/TikhonJelvis/Reactive-Life">Reactive-Life&lt;/a>）。&lt;/p>
&lt;p>FRP 不仅仅让我们可以编写漂亮的反应式 GUI 代码：它对于音乐以及甚至是机器人学中的应用也很好！ 对于所有的这些应用来说，比起使用回掉函数和状态，这绝对是前进性的一步！&lt;/p>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmdhaskell-仅仅是一门函数式语言haskell-仅仅是一门函数式语言">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#haskell-%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E9%97%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80">&lt;/a>Haskell 仅仅是一门函数式语言&lt;/h2>
&lt;p>不，Haskell 是一门完全的多范式语言.它很容易就能支持命令式编程 —— 人们戏称它为“最好的命令式语言”或者“完美的 Algol”&lt;!-- raw HTML omitted -->1&lt;!-- raw HTML omitted --> —— 以及逻辑式编程。它甚至能够支持面向对象编程（OOP），当然没有人给出足够的关注。Haskell 代码甚至可以&lt;a href="http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html">看起来像 C 语言&lt;/a>，当然要付出一点努力！&lt;/p>
&lt;p>唯一的区别是，不同于其他任何一门多范式语言，Haskell 是函数式为先的。其他的语言给你一个命令式的基础，然后在此之上叠加函数式的功能。Haskell 给你一个函数式的基础，然后在此之上叠加命令式或者逻辑式的功能。&lt;/p>
&lt;p>由于这是 Haskell 异于其他语言之处，同样也是非 Haskell 人员（non-Haskellers）纠缠之处。这也引发了初学者针对函数式语言提出的一堆无意义的讨论，例如“Haskell 为什么不允许值的改变（mutation）”。&lt;/p>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd你需要大量的数学知识才能使用函数式编程你需要大量的数学知识才能使用函数式编程">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E4%BD%A0%E9%9C%80%E8%A6%81%E5%A4%A7%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E6%89%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">&lt;/a>你需要大量的数学知识才能使用函数式编程&lt;/h2>
&lt;p>实际上不需要。当然了，函数式语言是在数学基础上设计的 —— 同时命令式语言是在计算机体系结构基础上设计的。然而，你使用 C 语言时并不需要知道关于 ALU （Arithmetic Logic Unit，计算逻辑单元）的寄存器知识。&lt;/p>
&lt;p>我在对除了基本的微积分外一无所知的情况下接触函数式编程的。此外，我从来没有特别擅长过数学。而这对我没有造成一点障碍。我很好地学习了实践意义上的 monads（单子）、applicatives 以及 functors（函子），在我理解任何相关理论之前。&lt;/p>
&lt;p>实际上我是通过 Haskell 来学习相关的数学知识的。但是你也不必这样做（指学习数学知识），如果你真心讨厌数学的话。学习 Haskell 中例如函子和单子的抽象，就像你学习的 Java bean，Lua 的协程或 Scheme 的宏一样。事实上，函子（Functor）的思想是我最初学到的 关于计算机科学的内容之一 —— 它仅仅是你可以将一个函数映射在其上的任何类型。&lt;/p>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd函数式程序员必须非常聪明而且擅长计算机科学函数式程序员必须非常聪明而且擅长计算机科学">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E9%9D%9E%E5%B8%B8%E8%81%AA%E6%98%8E%E8%80%8C%E4%B8%94%E6%93%85%E9%95%BF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">&lt;/a>函数式程序员必须非常聪明而且擅长计算机科学&lt;/h2>
&lt;p>无需多言，我是一个函数式程序员 :) 。&lt;/p>
&lt;p>函数式编程不是黑暗、邪恶的魔法。（好吧，也许 &lt;strong>Coq&lt;/strong> 是：P）。在许多方面，函数式编程实际上有助于你弥补并不强力的智商。Haskell 的类型系统极大地限制了你能写出的各种类型的错误功能，这使得你仅仅无脑利用类型系统就可以在困难的问题面前披荆斩棘。&lt;/p>
&lt;p>我发现 Haskell 是进行编程喝酒&lt;!-- raw HTML omitted -->7&lt;!-- raw HTML omitted -->活动时最好的语言。所有愚蠢的错误 —— 以及一些不愚蠢的错误 —— 都可以被编译器捕捉到。所以我可以摆弄我的代码直到类型检查通过。然后，程序（通常）就可以正常工作了。通常到比其应有的（通过类型检查就能正常工作正常工作）的频率高得多。Haskell 给你提供诸多工具使你克服你自己的不靠谱。&lt;/p>
&lt;p>函数式编程对初学者也是出奇地容易上手。例如，在 Jane Street 公司，他们为所有新进的交易员教授 OCaml 语言。我承认 Jane Steet 公司的交易员是特别聪明的一群人，但是他们中许多人绝不是程序员更不是计算机科学家。然而他们在短暂的 OCaml 集中培训后变得卓有效率，其中一些交易员花费了大量时间写函数式代码。&lt;/p>
&lt;p>另一个很好的例子是 IMVU 公司。我的一个朋友在他们的团队，帮助相当数量的普通程序员迁移到 Haskell 上。对于 web 开发，同样地，人们能在短时间内变得有效率。冒着听起来傲慢自大的风险，像 IMVU 的公司中员工的平均智商水平比不上世界上顶级交易公司的员工。&lt;/p>
&lt;p>也就是说，我的经验是 Haskell 社区中的人_确实_不成比例地聪明以及擅长计算机科学。并不是 Haskell 要求你如此，而是这个社区具有相当的自我选择特性。聪明的人似乎更可能主动选择 Haskell。实际上就像不久之前的 &lt;a href="http://paulgraham.com/pypar.html">The Python Paradox&lt;/a>，揭示了 Python 是如何被广泛接受为最易学的语言！&lt;/p>
&lt;hr>
&lt;h2 id="httpsgithubcomronhuafengronhuafenggithubioblobmasterfunctional-programming-mythsmd脚注4脚注sup4sup">&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/functional-programming-myths.md#%E8%84%9A%E6%B3%A84">&lt;/a>脚注&lt;!-- raw HTML omitted -->4&lt;!-- raw HTML omitted -->：&lt;/h2>
&lt;p>&lt;!-- raw HTML omitted -->1&lt;!-- raw HTML omitted -->这是一个很好的例子 &lt;a href="http://www.catb.org/jargon/html/H/ha-ha-only-serious.html">&lt;em>ha ha only serious&lt;/em>&lt;/a> —— 有些最初看上去只是一个笑话，但实际上有深层的含义。Haskell 是一个很好的命令式语言，因为它拥有作为一等公民的“命令式动作”（“imperative actions”）；你不必将语句封装在 lambda 中来将它们传来传去！这也使得将表示性的命令式控制结构，从这样的表示：&lt;/p>
&lt;pre>&lt;code>when
to
callCC
&lt;/code>&lt;/pre>
&lt;p>变成了库。&lt;/p>
&lt;p>此外，&lt;a href="http://www.catb.org/jargon/html/">Jargon File&lt;/a>是令人难以置信的，如果你对计算机科学发展历程和“黑客”文化真正感兴趣，这将会是绝佳的资源。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->2&lt;!-- raw HTML omitted -->这是一段美妙的谈话。我爱他定义的概念框架，即便我不同意他的一些结论。静态类型 —— 尤其是基于 Hindley-Milner 且不带 subtyping 的 —— 实际上不复杂。其实在某些方面，它们比动态类型系统的 Clojure 使用简单！（译者注：竟然黑 Clojure！）&lt;/p>
&lt;p>这里是一个谈话的链接：&lt;a href="http://www.infoq.com/presentations/Simple-Made-Easy-QCon-London-2012">Simple Make Easy&lt;/a>&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->3&lt;!-- raw HTML omitted -->我坚持认为，这是成为有趣程序员简单而有趣的一个方式。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->4&lt;!-- raw HTML omitted -->还记得我提到在函数式编程中顺序并不重要？是的，这完全是我不能以一种合适方式记住脚注顺序的借口。毕竟，我内心深处还是一个函数式程序员！&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->5&lt;!-- raw HTML omitted -->两类完全不同的模型（前面的是 5 系列，后面的是 7 系列），大多数编程语言都大体如此。&lt;/p>
&lt;p>&lt;a href="https://github.com/ronhuafeng/ronhuafeng.github.io/blob/master/BMW-5-7.jpg">&lt;img src="https://github.com/ronhuafeng/ronhuafeng.github.io/raw/master/BMW-5-7.jpg" alt="BMW-5-7">&lt;/a>&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->6&lt;!-- raw HTML omitted -->实际上，就像函数式编程一样，FRP（函数反应式语言）已经存在一段时间了，至少从 1997 年开始。但它仅仅临近时日才开始抓住人们的目光。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->7&lt;!-- raw HTML omitted -->我喝酒时用过大量不同的语言，所以我可以做出公平比较。在旧金山的疯狂的世界中，我们通过解决 &lt;a href="http://projecteuler.net/">Project Euler&lt;/a> 上的问题以及喝酒来寻乐子。多么美妙的生活啊！&lt;/p></content></item><item><title>为什么用Clojure，以及一点感悟</title><link>https://blog.formalscience.com/2013/09/02/2013-09-02_%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8clojure%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Mon, 02 Sep 2013 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2013/09/02/2013-09-02_%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8clojure%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>1.Java互操作
Clojure和Java互操作还是比较简单的，网上有很多案例。
首先讲下Java中调用Clojure。
一种方式是用过clojure.lang中的一些方法引入一个命名空间中的函数和变量，然后使用，这种方法就要注意ClassPath和ClassLoader的问题，这在Eclipse的RCP开发中还是比较烦的。另外要注意如果有Clojure源码文件被编译成Class文件了，调用这些文件的Clojure.jar和编译出这些文件的Clojure.jar版本一定要一致。
另外一种方式就是使用 “:aot :all“ 命令把所有Clojure源码编译成JVM的Class文件，然后调用genclass方法产生的类和函数。这个可以比较方便地把接口暴露出来。这篇文章针对genclass的各种用法讲得很好。
在Clojure中调用Java就很简单了，随便一搜就是一大堆，官方文档也有很多例子。
2.编程模式
Clojure本身就是JVM上的一个Lisp方言，所以编程模式主要就是函数式。当然我对函数式这个术语理解也不是很透彻，目前理解的函数式语言的特点就是：函数是第一公民、尽量保持无状态操作、有利于并行化操作、具有较强的作为meta language的能力（可以用来构建DSL）。这个可以看一下SCIP（计算机程序的构造和解释）这本书。
3.初衷
我本来想用Scala的好嘛！其实，当时主要想做BIP（这个还是高端大气上档次的）这个形式化语言的一个解释器，然后依靠那个不靠谱的方案和一个还不存在的同步形式化语言解释器进行对接，构建一个仿真环境。
其实同为JVM上寄生的函数式语言，明显Scala做这个工作更有优势一点：基于OCaml（这个的前身ML我之前用过）、有方便的类型模式匹配机制（这个机制在写解释器时应该比较有用）。Clojure我也调研过，但是当时是没有这个想法用它的。但是呢，但是呢，亚马逊给我推送了一封邮件，里面就有《Clojure编程》这本书，然后我还顺着广告点过去买了。于是在我刚开始做这个工作的时候，Clojure就被选中了。
都是缘分啊！
4.困难
困难一部分来自对Clojure一些库不了解，对一些常见的实现习惯不了解，后来实践中逐渐搜索学习，也就掌握了。
另外一些来自于和实验室主项目集成的时候，Eclipse RCP项目的ClassLoader比较诡异，我之前也没怎么了解过，碰到了各种”ClassNotFound“的错误，后来经过查找还是解决了。这个是我的一个Evernote笔记。
5.编辑环境的的配置和各种尝试
我先后试过Emacs和Intellij IDEA。
Emacs我还是很喜欢的，特别是里面的ParEdit插件，用来进行Lisp中大量的括号相关的操作简直无敌了，就是要先学习一下快捷键，效率会提升很多。但是有一个缺点（我能说Emacs的缺点么？），配置起来麻烦。虽然各种插件我都装上了，用起来也不错，但是过程中遇到的各种陷阱还是很多的，网上的教程也不总是和预想中的一样有效。我还是一直坚持使用Emacs的。后来实验室的另一个工作要在Windows上进行，在Windows下我一直无法用Emacs启动Clojure的REPL，因此转向了神器——Intellij IDEA。
神器只要下个LaClojure的插件和Leiningen插件就好了。各种只能提示啦，测试啦都可以很方便使用，我还把keymap改成了Emacs式的，算是一个念想。不过神器下面没有ParEdit插件，没法那么方便地处理括号，有些不开心。
6.总结
在学校的一个优势呢，就是可以尝试新的东西（虽然想让我赶快完成项目的老板不这样想）。以前我也学习Lisp，ML等函数式语言，但是一直没有实际动手做个东西。这次虽然使用Clojure做这个解释器有些冲动的成分在里面，整体而言还是很满意的。最后解释器效率可能有些问题（我写的程序有问题，和语言无关），但是程序工作起来还比较正确（至少那些单元测试都还能通过），修改起来也比较容易（还需要一些重构）。我对于Java和Clojure的了解也都稍微深刻了那么一点（是在命名空间这方面）。
下次要不要试试其他的语言呢？
7.项目
主要是做了一个BIP的解释器，还没有做完，只是完成了核心的语义解释的一部分。前段的语法解析器没有做，不过这个有现成的。
8.经验
实践出真知！
这首歌我最近一直在单曲循环。</description><content>&lt;p>&lt;!-- raw HTML omitted -->&lt;strong>1.Java互操作&lt;/strong>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>Clojure和Java互操作还是比较简单的，网上有很多案例。&lt;/p>
&lt;p>首先讲下Java中调用Clojure。&lt;/p>
&lt;p>一种方式是用过clojure.lang中的一些方法引入一个命名空间中的函数和变量，然后使用，这种方法就要注意ClassPath和ClassLoader的问题，这在Eclipse的RCP开发中还是比较烦的。另外要注意如果有Clojure源码文件被编译成Class文件了，调用这些文件的Clojure.jar和编译出这些文件的Clojure.jar版本一定要一致。&lt;/p>
&lt;p>另外一种方式就是使用 “:aot :all“ 命令把所有Clojure源码编译成JVM的Class文件，然后调用genclass方法产生的类和函数。这个可以比较方便地把接口暴露出来。&lt;a href="https://kotka.de/blog/2010/02/gen-class_how_it_works_and_how_to_use_it.html" title="这篇文章">这篇文章&lt;/a>针对genclass的各种用法讲得很好。&lt;/p>
&lt;p>在Clojure中调用Java就很简单了，随便一搜就是一大堆，官方文档也有很多例子。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;strong>2.编程模式&lt;/strong>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>Clojure本身就是JVM上的一个Lisp方言，所以编程模式主要就是函数式。当然我对函数式这个术语理解也不是很透彻，目前理解的函数式语言的特点就是：函数是第一公民、尽量保持无状态操作、有利于并行化操作、具有较强的作为meta language的能力（可以用来构建DSL）。这个可以看一下&lt;a href="http://book.douban.com/subject/1148282/" title="SCIP（计算机程序的构造和解释）">SCIP（计算机程序的构造和解释）&lt;/a>这本书。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;strong>3.初衷&lt;/strong>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>我本来想用Scala的好嘛！其实，当时主要想做&lt;a href="http://www-verimag.imag.fr/New-BIP-tools.html?lang=en" title="BIP">BIP&lt;/a>（这个还是高端大气上档次的）这个形式化语言的一个解释器，然后依靠那个不靠谱的方案和一个还不存在的同步形式化语言解释器进行对接，构建一个仿真环境。&lt;/p>
&lt;p>其实同为JVM上寄生的函数式语言，明显Scala做这个工作更有优势一点：基于OCaml（这个的前身ML我之前用过）、有方便的类型模式匹配机制（这个机制在写解释器时应该比较有用）。Clojure我也调研过，但是当时是没有这个想法用它的。但是呢，但是呢，亚马逊给我推送了一封邮件，里面就有《&lt;a href="http://book.douban.com/subject/21661495/" title="《Clojure编程》">Clojure编程&lt;/a>》这本书，然后我还顺着广告点过去买了。于是在我刚开始做这个工作的时候，Clojure就被选中了。&lt;/p>
&lt;p>都是缘分啊！&lt;/p>
&lt;p>&lt;strong>&lt;!-- raw HTML omitted -->4.困难&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>困难一部分来自对Clojure一些库不了解，对一些常见的实现习惯不了解，后来实践中逐渐搜索学习，也就掌握了。&lt;/p>
&lt;p>另外一些来自于和实验室主项目集成的时候，Eclipse RCP项目的ClassLoader比较诡异，我之前也没怎么了解过，碰到了各种”ClassNotFound“的错误，后来经过查找还是解决了。&lt;a href="evernote:///view/1204641/s10/3c46b4c5-4bde-4be6-b9c8-753fae940d21/3c46b4c5-4bde-4be6-b9c8-753fae940d21/http://" title="这个是我的一个Evernote笔记">这个是我的一个Evernote笔记&lt;/a>。&lt;/p>
&lt;p>&lt;strong>&lt;!-- raw HTML omitted -->5.编辑环境的的配置和各种尝试&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>我先后试过Emacs和Intellij IDEA。&lt;/p>
&lt;p>Emacs我还是很喜欢的，特别是里面的ParEdit插件，用来进行Lisp中大量的括号相关的操作简直无敌了，就是要先学习一下快捷键，效率会提升很多。但是有一个缺点（我能说Emacs的缺点么？），配置起来麻烦。虽然各种插件我都装上了，用起来也不错，但是过程中遇到的各种陷阱还是很多的，网上的教程也不总是和预想中的一样有效。我还是一直坚持使用Emacs的。后来实验室的另一个工作要在Windows上进行，在Windows下我一直无法用Emacs启动Clojure的REPL，因此转向了神器——Intellij IDEA。&lt;/p>
&lt;p>神器只要下个LaClojure的插件和Leiningen插件就好了。各种只能提示啦，测试啦都可以很方便使用，我还把keymap改成了Emacs式的，算是一个念想。不过神器下面没有ParEdit插件，没法那么方便地处理括号，有些不开心。&lt;/p>
&lt;p>&lt;strong>&lt;!-- raw HTML omitted -->6.总结&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>在学校的一个优势呢，就是可以尝试新的东西（虽然想让我赶快完成项目的老板不这样想）。以前我也学习Lisp，ML等函数式语言，但是一直没有实际动手做个东西。这次虽然使用Clojure做这个解释器有些冲动的成分在里面，整体而言还是很满意的。最后解释器效率可能有些问题（我写的程序有问题，和语言无关），但是程序工作起来还比较正确（至少那些单元测试都还能通过），修改起来也比较容易（还需要一些重构）。我对于Java和Clojure的了解也都稍微深刻了那么一点（是在命名空间这方面）。&lt;/p>
&lt;p>下次要不要试试其他的语言呢？&lt;/p>
&lt;p>&lt;strong>&lt;!-- raw HTML omitted -->7.项目&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>主要是做了一个BIP的解释器，还没有做完，只是完成了核心的语义解释的一部分。前段的语法解析器没有做，不过这个有现成的。&lt;/p>
&lt;p>&lt;strong>&lt;!-- raw HTML omitted -->8.经验&lt;!-- raw HTML omitted -->&lt;/strong>&lt;/p>
&lt;p>实践出真知！&lt;/p>
&lt;p>这首歌我最近一直在单曲循环。&lt;/p>
&lt;p> 
&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p></content></item><item><title>建模语言</title><link>https://blog.formalscience.com/2013/05/28/2013-05-28_%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</link><pubDate>Tue, 28 May 2013 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2013/05/28/2013-05-28_%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</guid><description>今天晚上和师兄师弟们一起吃饭。去食堂的路上，一直到食堂为止都特别伤心。自己研究生生活都已经过了快两年，对自己的研究方向依然不能向别人解释清楚。特迷茫，特无助。下面是我的一些理解，不是很全面（不是我全部所想的，未必全部是对的）。
1.何谓建模？
建模就是对一个表示的抽象表示，使得抽象过的表示在一定假设下可以回答原始表示能够回答的问题。例如：
把程序抽象成一个流程图，这个流程图可以回答给定输入产生什么输出的问题； 把程序抽象成一个函数依赖图，可以回答关于函数之间调用关系的问题； 把一个地表的自由落体抽象成成真空中的自由落体，（忽略掉空气阻力和允许一定误差情况下）回答自由落体从指定高度到达地面的时间问题 2.建模语言 语言是一种表现形式，就如眼神一样，直达人的灵魂深处。好吧，我文（che）艺（dan）了。写程序需要（编程）语言，刻画物理现象需要（数学）语言，把听到的曲调记录下来也需要（乐谱使用的）语言。建立这些事物的抽象表示（建模过程）也需要一种语言，称为建模语言，例如：UML、Petri Net、自动机（Automata）、正则表达式、上下文无关文法等。
3.建模语言分类
正如编程语言、数学语言有能力强弱、是否易用、山头派系之分，建模语言也是如此。这里主要针对程序建模语言进行说明。
图灵机是一种基础的建模语言，有许多建模语言都用图灵机作为基础来解释自身语义，或者来比较自己的能力。有一些语言表达能力等价于图灵机，有一些语言表达能力则非常有限。能力强弱并不对应语言的好坏。
其中一些语言的等价性可以用来出一些题目，例如把一个正则表达式转化为一个DFA（确定有限自动机）。
这些语言又可以按照是否有形式化的表示分为：形式化语言（Formal Languages）和非形式化语言（Informal Languages）。形式化语言的形式化表示一般使用数学中的集合和映射表示；非形式化语言一般都会有对应的非形式化的执行语义（即用自然语言说明语言中各种操作的含义，例如普通的C语言）。
按照使用范围会有针对嵌入式系统的建模语言（VHDL）、针对需求的建模语言（UML）、针对算法的建模语言（程序流程图）等等。
还有其他按照各种方法的各种分类，例如同步建模语言、异步建模语言、全局异步局部同步建模语言。我知道的并不全面，每次和大牛交流都感觉到自己的无知。
4.建模语言领域研究什么
如何在增加语言表达能力和易用性同时不影响语言其他方面的性质（语法的简洁性等）。例如图灵机中是没有整形变量的表示的，我们能看到的只有0/1的纸带。因此汇编、C等加入了各种数据结构，但是其需要解释的语义就更复杂了。相比之下Lisp的语法语义就比较简洁。
如何针对特定领域对语言进行封装优化。近些年比较火热的领域特定语言（DSL）目的就是如此。
如何能够支持模型的性质检测。可以参考模型检测领域（Model Checking）的相关知识。
如何能够用建模的模型生成一些代码，即用建模语言作为一种编程语言。这样要求建模语言要有和生成代码使用语言的比较优势（较少的代码量、简洁清晰的语义、更简单的并行并发描述等）。这种使用方式有一个相关概念：模型驱动的开发。
下面的 #5 内容会和 #4 没有那么正交，请海涵。
5.建模语言领域能够贡献的工作
写一种全新的建模语言。嗯，这个一般都是持续N（&amp;gt;10）年的工作。
在一种建模语言基础上添加/封装一些操作符，从而对一些被建模对象的行为提供直接支持（例如支持建模buffered signal transmission）。DSL。
把两种建模语言整合起来。比较难，需要用更低级的语言解释两者语义，以及其他一大堆问题需要处理。
对指定的建模语言生成另一种语言的代码。例如：C to Verilog，Esterel to C等。
给建模语言建立的模型写simulator，即解释建模语言的执行语义。
给建模语言写图形化的编辑器，例如Visual Studio中的GUI绘制工具。
等等一系列，一系列。
6.我在做啥
最近在做对增加了时间表示的BIP模型和增加了时间表示的Esterel模型二者混合模型的执行语义解释。现在正处于用Clojure写没有时间表示的BIP模型执行语义解释的地步。
最近在做把BIP模型生成的代码转化成C语言代码，然后在ARM板卡上执行的流程探索。这条路已经基本走通，我能说今天中午什么事都没有做，然后之前bug的程序就能够在ARM板卡上运行了么。这真是上天不负有（gou）心（shi）人（yun）啊。</description><content>&lt;p>今天晚上和师兄师弟们一起吃饭。去食堂的路上，一直到食堂为止都特别伤心。自己研究生生活都已经过了快两年，对自己的研究方向依然不能向别人解释清楚。特迷茫，特无助。下面是我的一些理解，不是很全面（不是我全部所想的，未必全部是对的）。&lt;/p>
&lt;p>1.何谓建模？&lt;/p>
&lt;p>建模就是对一个表示的抽象表示，使得抽象过的表示在一定假设下可以回答原始表示能够回答的问题。例如：&lt;/p>
&lt;ul>
&lt;li>把程序抽象成一个流程图，这个流程图可以回答给定输入产生什么输出的问题；&lt;/li>
&lt;li>把程序抽象成一个函数依赖图，可以回答关于函数之间调用关系的问题；&lt;/li>
&lt;li>把一个地表的自由落体抽象成成真空中的自由落体，（忽略掉空气阻力和允许一定误差情况下）回答自由落体从指定高度到达地面的时间问题
2.建模语言&lt;/li>
&lt;/ul>
&lt;p>语言是一种表现形式，就如眼神一样，直达人的灵魂深处。好吧，我文（che）艺（dan）了。写程序需要（编程）语言，刻画物理现象需要（数学）语言，把听到的曲调记录下来也需要（乐谱使用的）语言。建立这些事物的抽象表示（建模过程）也需要一种语言，称为建模语言，例如：UML、Petri Net、自动机（Automata）、正则表达式、上下文无关文法等。&lt;/p>
&lt;p>3.建模语言分类&lt;/p>
&lt;p>正如编程语言、数学语言有能力强弱、是否易用、山头派系之分，建模语言也是如此。这里主要针对程序建模语言进行说明。&lt;/p>
&lt;p>图灵机是一种基础的建模语言，有许多建模语言都用图灵机作为基础来解释自身语义，或者来比较自己的能力。有一些语言表达能力等价于图灵机，有一些语言表达能力则非常有限。能力强弱并不对应语言的好坏。&lt;/p>
&lt;p>其中一些语言的等价性可以用来出一些题目，例如把一个正则表达式转化为一个DFA（确定有限自动机）。&lt;/p>
&lt;p>这些语言又可以按照是否有形式化的表示分为：形式化语言（Formal Languages）和非形式化语言（Informal Languages）。形式化语言的形式化表示一般使用数学中的集合和映射表示；非形式化语言一般都会有对应的非形式化的执行语义（即用自然语言说明语言中各种操作的含义，例如普通的C语言）。&lt;/p>
&lt;p>按照使用范围会有针对嵌入式系统的建模语言（VHDL）、针对需求的建模语言（UML）、针对算法的建模语言（程序流程图）等等。&lt;/p>
&lt;p>还有其他按照各种方法的各种分类，例如同步建模语言、异步建模语言、全局异步局部同步建模语言。我知道的并不全面，每次和大牛交流都感觉到自己的无知。&lt;/p>
&lt;p>4.建模语言领域研究什么&lt;/p>
&lt;p>如何在增加语言表达能力和易用性同时不影响语言其他方面的性质（语法的简洁性等）。例如图灵机中是没有整形变量的表示的，我们能看到的只有0/1的纸带。因此汇编、C等加入了各种数据结构，但是其需要解释的语义就更复杂了。相比之下Lisp的语法语义就比较简洁。&lt;/p>
&lt;p>如何针对特定领域对语言进行封装优化。近些年比较火热的领域特定语言（DSL）目的就是如此。&lt;/p>
&lt;p>如何能够支持模型的性质检测。可以参考模型检测领域（Model Checking）的相关知识。&lt;/p>
&lt;p>如何能够用建模的模型生成一些代码，即用建模语言作为一种编程语言。这样要求建模语言要有和生成代码使用语言的比较优势（较少的代码量、简洁清晰的语义、更简单的并行并发描述等）。这种使用方式有一个相关概念：模型驱动的开发。&lt;/p>
&lt;p>下面的 #5 内容会和 #4 没有那么正交，请海涵。&lt;/p>
&lt;p>5.建模语言领域能够贡献的工作&lt;/p>
&lt;p>写一种全新的建模语言。嗯，这个一般都是持续N（&amp;gt;10）年的工作。&lt;/p>
&lt;p>在一种建模语言基础上添加/封装一些操作符，从而对一些被建模对象的行为提供直接支持（例如支持建模buffered signal transmission）。DSL。&lt;/p>
&lt;p>把两种建模语言整合起来。比较难，需要用更低级的语言解释两者语义，以及其他一大堆问题需要处理。&lt;/p>
&lt;p>对指定的建模语言生成另一种语言的代码。例如：C to Verilog，Esterel to C等。&lt;/p>
&lt;p>给建模语言建立的模型写simulator，即解释建模语言的执行语义。&lt;/p>
&lt;p>给建模语言写图形化的编辑器，例如Visual Studio中的GUI绘制工具。&lt;/p>
&lt;p>等等一系列，一系列。&lt;/p>
&lt;p>6.我在做啥&lt;/p>
&lt;p>最近在做对增加了时间表示的BIP模型和增加了时间表示的Esterel模型二者混合模型的执行语义解释。现在正处于用Clojure写没有时间表示的BIP模型执行语义解释的地步。&lt;/p>
&lt;p>最近在做把BIP模型生成的代码转化成C语言代码，然后在ARM板卡上执行的流程探索。这条路已经基本走通，我能说今天中午什么事都没有做，然后之前bug的程序就能够在ARM板卡上运行了么。这真是上天不负有（gou）心（shi）人（yun）啊。&lt;/p>
&lt;p> &lt;/p>
&lt;p> &lt;/p></content></item><item><title>Archlinux Install Notes</title><link>https://blog.formalscience.com/2013/03/27/2013-03-27_archlinux_install_notes/</link><pubDate>Wed, 27 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2013/03/27/2013-03-27_archlinux_install_notes/</guid><description>分区格式化 cfdisk mkfs.ext /dev/sda* mkswap /dev/sdaX swapon /dev/sdaX
挂载当前分区 检查当前磁盘的标识符和布局 lsblk /dev/sda mount /dev/sda1 /mnt mkdir /mnt/home 如果是home独立分区 mount /dev/sda2 /mnt/home
编辑 /etc/pacman.d/mirrorlist 更新 pacman -Syy
使用pacstrap脚本安装基本系统
pacstrap /mnt base base-devel 如果 pacman 报告安装时遇到错误的签名(error: failed to commit transaction (invalid or corrupted package))，请运行如下命令：
pacman-key &amp;ndash;init &amp;amp;&amp;amp; pacman-key &amp;ndash;populate archlinux base 来自 [core] 软件源的最小基本系统。 base-devel 来自 [core] 的附加工具例如make和 automake。大部分新手都应该安装它，后续扩展系统会用到它，安装AUR中软件包时，base-devel也是必须的
生成 fstab
用下面命令生成 fstab。如果想使用 UUIDs，使用 -U 选项；如果想使用标签，用 -L 选项，完成后最好检查一下生成的/etc/fstab。 Note: 后面如果出现问题，请不要再次运行genfstab，如果需要，手动编辑/etc/fstab。
genfstab -U -p /mnt | sed &amp;rsquo;s/rw,relatime,data=ordered/defaults,relatime/&amp;rsquo; &amp;gt;&amp;gt; /mnt/etc/fstab nano /mnt/etc/fstab Chroot 到新系统</description><content>&lt;p>分区格式化
cfdisk
mkfs.ext /dev/sda*
mkswap /dev/sdaX
swapon /dev/sdaX&lt;/p>
&lt;p>挂载当前分区
检查当前磁盘的标识符和布局
lsblk /dev/sda
mount /dev/sda1 /mnt
mkdir /mnt/home
如果是home独立分区
mount /dev/sda2 /mnt/home&lt;/p>
&lt;p>编辑 /etc/pacman.d/mirrorlist
更新 pacman -Syy&lt;/p>
&lt;p>使用pacstrap脚本安装基本系统&lt;/p>
&lt;h1 id="pacstrap-mnt-base-base-devel">pacstrap /mnt base base-devel&lt;/h1>
&lt;p>如果 pacman 报告安装时遇到错误的签名(error: failed to commit transaction (invalid or corrupted package))，请运行如下命令：&lt;/p>
&lt;h1 id="pacman-key---init-ampamp-pacman-key---populate-archlinux">pacman-key &amp;ndash;init &amp;amp;&amp;amp; pacman-key &amp;ndash;populate archlinux&lt;/h1>
&lt;p>base
来自 [core] 软件源的最小基本系统。
base-devel
来自 [core] 的附加工具例如make和 automake。大部分新手都应该安装它，后续扩展系统会用到它，安装AUR中软件包时，base-devel也是必须的&lt;/p>
&lt;p>生成 fstab&lt;/p>
&lt;p>用下面命令生成 fstab。如果想使用 UUIDs，使用 -U 选项；如果想使用标签，用 -L 选项，完成后最好检查一下生成的/etc/fstab。
Note: 后面如果出现问题，请不要再次运行genfstab，如果需要，手动编辑/etc/fstab。&lt;/p>
&lt;h1 id="genfstab--u--p-mnt--sed-srwrelatimedataordereddefaultsrelatime-gtgt-mntetcfstab">genfstab -U -p /mnt  | sed &amp;rsquo;s/rw,relatime,data=ordered/defaults,relatime/&amp;rsquo; &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/h1>
&lt;h1 id="nano-mntetcfstab">nano /mnt/etc/fstab&lt;/h1>
&lt;p>Chroot 到新系统&lt;/p>
&lt;h1 id="arch-chroot-mnt">arch-chroot /mnt&lt;/h1>
&lt;p>Locale
需要编辑两个文件：locale.gen 和 locale.conf.&lt;/p>
&lt;p>默认情况下 /etc/locale.gen 是一个仅包含注释文档的空文件。选定你需要的本地化类型(移除前面的＃即可), 比如中文系统可以使用:&lt;/p>
&lt;p>en_US.UTF-8 UTF-8
zh_CN.GB18030 GB18030
zh_CN.GBK GBK
zh_CN.UTF-8 UTF-8
zh_CN GB2312&lt;/p>
&lt;p>然后运行：&lt;/p>
&lt;h1 id="locale-gen">locale-gen&lt;/h1>
&lt;p>locale.conf 文件默认不存在，一般设置LANG就行了，它是其它设置的默认值。
/etc/locale.conf&lt;/p>
&lt;p>LANG=en_US.UTF-8
LC_TIME=en_GB.UTF-8&lt;/p>
&lt;p>Hostname&lt;/p>
&lt;h1 id="echo-myhostname-gt-etchostname">echo myhostname &amp;gt; /etc/hostname&lt;/h1>
&lt;p>网络查看接口     #ip link
动态 IP
If you only use a single fixed wired network connection, you do not need a network management service and
can simply enable the dhcpcd service, Where &amp;lt;interface&amp;gt; is your wired interface:&lt;/p>
&lt;h1 id="systemctl-enable-dhcpcdltinterfacegtservice">systemctl enable dhcpcd@&amp;lt;interface&amp;gt;.service&lt;/h1>
&lt;p>Alternatively, you can use netcfg&amp;rsquo;s net-auto-wired, which gracefully handles dynamic connections to new networks:&lt;/p>
&lt;p>Install ifplugd, which is required for net-auto-wired:&lt;/p>
&lt;h1 id="pacman--s-ifplugd">pacman -S ifplugd&lt;/h1>
&lt;p>Set up the dhcp profile and enable the net-auto-wired service:&lt;/p>
&lt;h1 id="cd-etcnetworkd">cd /etc/network.d&lt;/h1>
&lt;h1 id="ln--s-examplesethernet-dhcp-">ln -s examples/ethernet-dhcp .&lt;/h1>
&lt;h1 id="systemctl-enable-net-auto-wiredservice">systemctl enable net-auto-wired.service&lt;/h1>
&lt;p>在 Arch x86_64 上运行 32 位应用程序，请在 /etc/pacman.conf 中加入如下内容以启用 [multilib] 源
[multilib]
SigLevel = PackageRequired
Include = /etc/pacman.d/mirrorlist&lt;/p>
&lt;p>修改完成后需要用pacman 的 -Sy 参数更新服务器信息，否则会出现 &amp;ldquo;warning: database file for &amp;lsquo;multilib&amp;rsquo; does not exist&amp;rdquo; 错误。&lt;/p>
&lt;p>设置 Root 密码并创建一般用户
用 passwd 设置一个root密码：&lt;/p>
&lt;h1 id="passwd">passwd&lt;/h1>
&lt;p>警告: Linux 是个多用户环境。请不要使用 root 登录进行日常工作。这不仅仅是坏习惯，还非常危险。Root 账户仅是用来做管理任务的。&lt;/p>
&lt;p>因此，下面将创建用户archie，交互方式请使用adduser。&lt;/p>
&lt;h1 id="useradd--m--g-users--g-wheel--s-binbash-archie">useradd -m -g users -G wheel -s /bin/bash archie&lt;/h1>
&lt;h1 id="passwd-archie">passwd archie&lt;/h1>
&lt;p>新非 root 用户创建完成，同时还建立了用户主目录和登录密码。&lt;/p>
&lt;p>如果你弄错了账户设置，或者你想删除一个账户，或者你想要换个账户名，或者任何其他什么原因，使用 /usr/sbin/userdel ：&lt;/p>
&lt;h1 id="userdel--r-archie">userdel -r archie&lt;/h1>
&lt;p>Grub
Install the grub-bios package and then run grub-install:&lt;/p>
&lt;h1 id="pacman--s-grub-bios">pacman -S grub-bios&lt;/h1>
&lt;h1 id="grub-install---recheck-devsda">grub-install &amp;ndash;recheck /dev/sda&lt;/h1>
&lt;h1 id="cp-usrsharelocaleenquotlc_messagesgrubmo-bootgrublocaleenmo">cp /usr/share/locale/en@quot/LC_MESSAGES/grub.mo /boot/grub/locale/en.mo&lt;/h1>
&lt;p>虽然手动配置grub.cfg完全可以工作，建议用户自动生成这个文件。&lt;/p>
&lt;p>要搜索硬盘上安装的其它操作系统，请先用 # pacman -S os-prober 安装 os-prober。&lt;/p>
&lt;h1 id="grub-mkconfig--o-bootgrubgrubcfg">grub-mkconfig -o /boot/grub/grub.cfg&lt;/h1>
&lt;p>卸载分区并重启系统
如果还在 chroot 环境，先用 exit 命令退出系统：&lt;/p>
&lt;h1 id="exit">exit&lt;/h1>
&lt;p>卸载/mnt中挂载的系统：&lt;/p>
&lt;h1 id="umount-mntboothome">umount /mnt/{boot,home,}&lt;/h1>
&lt;p>要退出到/mnt目录外面才能卸载
重启：&lt;/p>
&lt;h1 id="reboot">reboot&lt;/h1>
&lt;p>图形用户界面
安装 X
X 窗口管理系统(X11或者X) 是基于网络的显示协议，提供了窗口功能，包含建立图形用户界面(GUI)的标准工具和协议。&lt;/p>
&lt;p>安装基础的 Xorg 包：&lt;/p>
&lt;h1 id="pacman--s-xorg-server-xorg-xinit-xorg-utils-xorg-server-utils">pacman -S xorg-server xorg-xinit xorg-utils xorg-server-utils&lt;/h1>
&lt;p>安装 mesa 以获得 3D 支持:&lt;/p>
&lt;h1 id="pacman--s-mesa">pacman -S mesa&lt;/h1>
&lt;p>安装显卡驱动
注意: 如果是从 Virtualbox 虚拟机安装，则不需要安装显卡驱动，参见 此文，然后跳到下面的配置部分。&lt;/p>
&lt;p>Linux 内核包含了开源的视频驱动，支持硬件加速的 framebuffers。OpenGL 和 X11 的 2D 加速需要用户空间工具。&lt;/p>
&lt;p>如果不知道显卡类型，请执行如下命令进行查询：&lt;/p>
&lt;p>$ lspci | grep VGA&lt;/p>
&lt;p>输入下面命令，查看所有开源驱动:&lt;/p>
&lt;p>$ pacman -Ss xf86-video | less&lt;/p>
&lt;p>vesa是一个支持大部分显卡的通用驱动，不提供任何 2D 和 3D 加速功能。如果无法找到显卡芯片组的对应驱动或载入失败，Xorg 会使用vesa：要安装：&lt;/p>
&lt;h1 id="pacman--s-xf86-video-vesa">pacman -S xf86-video-vesa&lt;/h1>
&lt;p>Intel     开源     xf86-video-intel     lib32-intel-dri
Nvidia
开源
xf86-video-nouveau     lib32-nouveau-dri
86-video-nv         –
闭源
nvidia             lib32-nvidia-utils
nvidia-304xx     lib32-nvidia-304xx-utils&lt;/p>
&lt;p>笔记本(或触摸屏)用户需要 synaptics 软件包以支持触摸板/触摸屏：&lt;/p>
&lt;h1 id="pacman--s-xf86-input-synaptics">pacman -S xf86-input-synaptics&lt;/h1>
&lt;p>最小安装kde&lt;/p>
&lt;p>如果你想最小安装KDE SC，安装 kdebase， phonon-vlc 或 phonon-gstreamer 以及，可选的语言包 kde-l10n-yourlanguagehere （对于简体中文语言数据，它是kde-l10n-zh_cn）。
注意: 各种后端需要一个 ttf-* 字体软件包。 phonon-vlc 已经依赖于 ttf-freefont，但你使用 phonon-gstreamer 时，你还应该安装 ttf-dejavu 或者别的字体。更多信息可以浏览 FS#26012。&lt;/p>
&lt;p>使用 xinitrc
xinitrc的意义和用途在这里有详细描述。&lt;/p>
&lt;p>安装 kdebase-workspace 编辑 ~/.xinitrc。然后取消注释：&lt;/p>
&lt;p>exec startkde&lt;/p>
&lt;p>启动不了X
copy file
I just looked in /etc/skel/.xinitrc and copied it to my home directory.&lt;/p></content></item><item><title>Python使用smtplib发送邮件</title><link>https://blog.formalscience.com/2012/11/13/2012-11-13_python%E4%BD%BF%E7%94%A8smtplib%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</link><pubDate>Tue, 13 Nov 2012 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2012/11/13/2012-11-13_python%E4%BD%BF%E7%94%A8smtplib%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</guid><description>from smtplib import SMTP
#这些库是邮件格式使用的 from email.mime.text import MIMEText from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart
smtp = SMTP()
smtp.connect(&amp;lsquo;smtp.163.com&amp;rsquo;)
#这句话是必不可少的 smtp.helo()
#选择认证方式 smtp.esmtp_features[&amp;lsquo;auth&amp;rsquo;] = &amp;lsquo;LOGIN&amp;rsquo; smtp.login(&amp;rsquo;####@163.com&amp;rsquo;, &amp;lsquo;password&amp;rsquo;)
message = MIMEMultipart() message.attach(MIMEText(&amp;lsquo;content&amp;rsquo;)) message[&amp;ldquo;Subject&amp;rdquo;] = &amp;lsquo;subject&amp;rsquo;
smtp.sendmail(&amp;rsquo;####@163.com&amp;rsquo;, [&amp;lsquo;mail_to@163.com&amp;rsquo;], message.as_string())
差不多邮件这样就可以发送出去了</description><content>&lt;p>from smtplib import SMTP&lt;/p>
&lt;p>#这些库是邮件格式使用的
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart&lt;/p>
&lt;p>smtp = SMTP()&lt;/p>
&lt;p>smtp.connect(&amp;lsquo;smtp.163.com&amp;rsquo;)&lt;/p>
&lt;p>#这句话是必不可少的
smtp.helo()&lt;/p>
&lt;p>#选择认证方式
smtp.esmtp_features[&amp;lsquo;auth&amp;rsquo;] = &amp;lsquo;LOGIN&amp;rsquo;
smtp.login(&amp;rsquo;####@163.com&amp;rsquo;, &amp;lsquo;password&amp;rsquo;)&lt;/p>
&lt;p>message = MIMEMultipart()
message.attach(MIMEText(&amp;lsquo;content&amp;rsquo;))
message[&amp;ldquo;Subject&amp;rdquo;] = &amp;lsquo;subject&amp;rsquo;&lt;/p>
&lt;p>smtp.sendmail(&amp;rsquo;####@163.com&amp;rsquo;, [&amp;lsquo;mail_to@163.com&amp;rsquo;], message.as_string())&lt;/p>
&lt;p>差不多邮件这样就可以发送出去了&lt;/p></content></item><item><title>基于OpenShift搭建MediaWiki</title><link>https://blog.formalscience.com/2012/11/12/2012-11-12_%E5%9F%BA%E4%BA%8Eopenshift%E6%90%AD%E5%BB%BAmediawiki/</link><pubDate>Mon, 12 Nov 2012 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2012/11/12/2012-11-12_%E5%9F%BA%E4%BA%8Eopenshift%E6%90%AD%E5%BB%BAmediawiki/</guid><description>1.按照OpenShift建立用用的过程新建一个PHP 5.3应用，可以通过网页方式创建（推荐）；本地完成一些初始化工作（参考官方教程）
2.按照应用页面给出的git地址，把代码库clone到本地，然后把MediaWiki代码push到Master库中。（git使用方法）
3.在应用页面点击那个“Add a Cartridge”，然后加上一个MySql数据库（应该是这样，我在命令行中添加的）和一个phpMyAdmin；把获得的数据库root用户名和密码记下来； 但是如何重新访问这些Cartridge，我还不知道啊，也许从命令行可以过去。
4.进入phpMyAdmin进行管理，左上方有MediaWiki连接数据库要使用的数据库地址（这个地方寻找地址卡了好久，直到安装了phpMyAdmin才得到的sql连接地址，应该还有其他方法的）
5.进入应用URL进行MediaWiki的初始化工作，剩下的就很简单了</description><content>&lt;p>1.按照&lt;a href="https://openshift.redhat.com/app/" title="OpenShift">OpenShift&lt;/a>建立用用的过程新建一个PHP 5.3应用，可以通过网页方式创建（推荐）；本地完成一些初始化工作（参考官方&lt;a href="https://openshift.redhat.com/community/get-started" title="OpenShift本地设置的一些步骤">教程&lt;/a>）&lt;/p>
&lt;p>2.按照应用页面给出的git地址，把代码库clone到本地，然后把MediaWiki代码push到Master库中。（&lt;a href="http://rogerdudler.github.com/git-guide/index.zh.html" title="git使用方法">git使用方法&lt;/a>）&lt;/p>
&lt;p>3.在应用页面点击那个“Add a Cartridge”，然后加上一个MySql数据库（应该是这样，我在命令行中添加的）和一个phpMyAdmin；把获得的数据库root用户名和密码记下来；
但是如何重新访问这些Cartridge，我还不知道啊，也许从命令行可以过去。&lt;/p>
&lt;p>4.进入phpMyAdmin进行管理，左上方有MediaWiki连接数据库要使用的数据库地址（这个地方寻找地址卡了好久，直到安装了phpMyAdmin才得到的sql连接地址，应该还有其他方法的）&lt;/p>
&lt;p>5.进入应用URL进行MediaWiki的初始化工作，剩下的就很简单了&lt;/p></content></item><item><title>Spin工具的Eclipse集成</title><link>https://blog.formalscience.com/2012/08/19/2012-08-19_spin%E5%B7%A5%E5%85%B7%E7%9A%84eclipse%E9%9B%86%E6%88%90/</link><pubDate>Sun, 19 Aug 2012 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2012/08/19/2012-08-19_spin%E5%B7%A5%E5%85%B7%E7%9A%84eclipse%E9%9B%86%E6%88%90/</guid><description>Spin是Promela建模语言的解释器和验证工具。它本身有一个图形化的工具iSpin，不过这个图形化实在有些简陋。下面介绍一个Eclipse的插件，这样我们可以使用Eclipse的编辑环境来使用Spin。
首先，在Eclipse的install new software中添加 http://matrix.uni-mb.si/fileadmin/datoteke/znanost/orodja/ep4s/update-site/ 把Group items by category选项去掉，否则看不到可安装的插件；安装此插件。
然后，在菜单栏中选择Spin项，进入Spin Configuration，
Spin工具可以从其官网下载。
C Complier里的gcc可以用cygwin安装，记得选择直接的版本，不要选择gcc.exe，否则可能出现不能验证通过的错误。
基本上这样就算安装完成了，如果你有什么问题，可以给我留言。</description><content>&lt;p>Spin是Promela建模语言的解释器和验证工具。它本身有一个图形化的工具iSpin，不过这个图形化实在有些简陋。下面介绍一个Eclipse的插件，这样我们可以使用Eclipse的编辑环境来使用Spin。&lt;/p>
&lt;p>首先，在Eclipse的install new software中添加
&lt;a href="http://matrix.uni-mb.si/fileadmin/datoteke/znanost/orodja/ep4s/update-site/">http://matrix.uni-mb.si/fileadmin/datoteke/znanost/orodja/ep4s/update-site/&lt;/a>
把Group items by category选项去掉，否则看不到可安装的插件；安装此插件。&lt;/p>
&lt;p>然后，在菜单栏中选择Spin项，进入Spin Configuration，&lt;a href="http://www.formalscience.com/blog/wp-content/uploads/2012/08/image.png">&lt;img src="http://www.formalscience.com/blog/wp-content/uploads/2012/08/image_thumb.png" alt="image" title="image">&lt;/a>&lt;/p>
&lt;p>Spin工具可以从其&lt;a href="http://spinroot.com/spin/Man/README.html">官网&lt;/a>下载。&lt;/p>
&lt;p>C Complier里的gcc可以用cygwin安装，记得选择直接的版本，不要选择gcc.exe，否则可能出现不能验证通过的错误。&lt;/p>
&lt;p>基本上这样就算安装完成了，如果你有什么问题，可以给我留言。&lt;/p></content></item><item><title>如何增加人人网的访问量</title><link>https://blog.formalscience.com/2012/06/28/2012-06-28_%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E4%BA%BA%E4%BA%BA%E7%BD%91%E7%9A%84%E8%AE%BF%E9%97%AE%E9%87%8F/</link><pubDate>Thu, 28 Jun 2012 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2012/06/28/2012-06-28_%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E4%BA%BA%E4%BA%BA%E7%BD%91%E7%9A%84%E8%AE%BF%E9%97%AE%E9%87%8F/</guid><description>主要是利用人们的好奇心吸引回访。
用爬虫去爬去一定数量的好友列表，获得一定数量的id文件。 用自己的帐号认证，然后从id文件中取得一个id，然后访问他的页面。 当访问的页面到达一定规模的时候，在这么多人里肯定有些人很好奇想要看看你是谁，然后就点回你的页面。 访问量和好友申请就飕飕涨了。</description><content>&lt;p>主要是利用人们的好奇心吸引回访。&lt;/p>
&lt;ol>
&lt;li>用爬虫去爬去一定数量的好友列表，获得一定数量的id文件。&lt;/li>
&lt;li>用自己的帐号认证，然后从id文件中取得一个id，然后访问他的页面。&lt;/li>
&lt;li>当访问的页面到达一定规模的时候，在这么多人里肯定有些人很好奇想要看看你是谁，然后就点回你的页面。&lt;/li>
&lt;li>访问量和好友申请就飕飕涨了。&lt;/li>
&lt;/ol></content></item><item><title>Eclipse导入Github库</title><link>https://blog.formalscience.com/2012/06/17/2012-06-17_eclipse%E5%AF%BC%E5%85%A5github%E5%BA%93/</link><pubDate>Sun, 17 Jun 2012 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2012/06/17/2012-06-17_eclipse%E5%AF%BC%E5%85%A5github%E5%BA%93/</guid><description>导入要点
使用HTTPS的方式会容易一些，SSH的方式会有一些认证问题（这个极有可能是伪命题，因为第2条的原因） 先通过命令行把库拖下来，最好不要放在eclipse的workplace中 然后新建一个项目，在Team|Share|&amp;hellip;|Git一路选下去就好 （这个日志需要重新更改）</description><content>&lt;p>导入要点&lt;/p>
&lt;ol>
&lt;li>使用HTTPS的方式会容易一些，SSH的方式会有一些认证问题（这个极有可能是伪命题，因为第2条的原因）&lt;/li>
&lt;li>先通过命令行把库拖下来，最好不要放在eclipse的workplace中&lt;/li>
&lt;li>然后新建一个项目，在Team|Share|&amp;hellip;|Git一路选下去就好&lt;/li>
&lt;/ol>
&lt;p>（这个日志需要重新更改）&lt;/p></content></item><item><title>如何给WordPress博客换一个Favicon图标</title><link>https://blog.formalscience.com/2012/06/03/2012-06-03_%E5%A6%82%E4%BD%95%E7%BB%99wordpress%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%B8%80%E4%B8%AAfavicon%E5%9B%BE%E6%A0%87/</link><pubDate>Sun, 03 Jun 2012 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2012/06/03/2012-06-03_%E5%A6%82%E4%BD%95%E7%BB%99wordpress%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%B8%80%E4%B8%AAfavicon%E5%9B%BE%E6%A0%87/</guid><description>整个过程大约分为以下几步
制作favicon.ico
在网站http://www.favicon.cc/里上传一张图片，通过点击“Import Image” 然后就可以根据各种选项对图片进行调整 最后通过点击“Download Favicon”进行下载 注：如果你有天赋可以自己设计图标，那么在那个编辑器里创作也是可以的 上传到博客目录，比如我上传到mydomain/blog目录下了，链接为http://www.formalscience.com/blog/favicon.ico
修改对应主题内的header.php，在&amp;lt;head&amp;gt;和&amp;lt;/head&amp;gt;之间添加如下代码：
&amp;amp;lt;LINK rel=icon type=image/x-icon href=&amp;quot;http://yourdomain/favicon.ico&amp;quot;&amp;amp;gt;
&amp;amp;lt;LINK rel=&amp;quot;shortcut icon&amp;quot; type=image/x-icon href=&amp;quot;yourdomain/favicon.ico&amp;quot;&amp;amp;gt;
对于我的博客来说就是
&amp;amp;lt;LINK rel=icon type=image/x-icon href=&amp;quot;http://www.formalscience.com/blog/favicon.ico&amp;quot;&amp;amp;gt;
&amp;amp;lt;LINK rel=&amp;quot;shortcut icon&amp;quot; type=image/x-icon href=&amp;quot;http://www.formalscience.com/blog/favicon.ico&amp;quot;&amp;amp;gt;
完成以上步骤后清空下浏览器缓存就可以看到效果了。
参考链接：
给WP地址栏添加一个Favicon图标
WordPress 博客添加个性标志favicon.ico</description><content>&lt;p>整个过程大约分为以下几步&lt;/p>
&lt;ol>
&lt;li>
&lt;p>制作favicon.ico&lt;/p>
&lt;ul>
&lt;li>在网站&lt;a href="http://www.favicon.cc/" title="favicon.cc">http://www.favicon.cc/&lt;/a>里上传一张图片，通过点击“Import Image”&lt;/li>
&lt;li>然后就可以根据各种选项对图片进行调整&lt;/li>
&lt;li>最后通过点击“Download Favicon”进行下载&lt;/li>
&lt;li>注：如果你有天赋可以自己设计图标，那么在那个编辑器里创作也是可以的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>上传到博客目录，比如我上传到mydomain/blog目录下了，链接为&lt;a href="http://www.formalscience.com/blog/favicon.ico" title="favicon.ico">http://www.formalscience.com/blog/favicon.ico&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改对应主题内的header.php，在&amp;lt;head&amp;gt;和&amp;lt;/head&amp;gt;之间添加如下代码：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;code>&amp;amp;lt;LINK rel=icon type=image/x-icon href=&amp;quot;http://yourdomain/favicon.ico&amp;quot;&amp;amp;gt;&lt;/code>&lt;/p>
&lt;p>&lt;code>&amp;amp;lt;LINK rel=&amp;quot;shortcut icon&amp;quot; type=image/x-icon href=&amp;quot;yourdomain/favicon.ico&amp;quot;&amp;amp;gt;&lt;/code>&lt;/p>
&lt;p>对于我的博客来说就是&lt;/p>
&lt;p>&lt;code>&amp;amp;lt;LINK rel=icon type=image/x-icon href=&amp;quot;http://www.formalscience.com/blog/favicon.ico&amp;quot;&amp;amp;gt;&lt;/code>&lt;/p>
&lt;p>&lt;code>&amp;amp;lt;LINK rel=&amp;quot;shortcut icon&amp;quot; type=image/x-icon href=&amp;quot;http://www.formalscience.com/blog/favicon.ico&amp;quot;&amp;amp;gt;&lt;/code>&lt;/p>
&lt;p>完成以上步骤后清空下浏览器缓存就可以看到效果了。&lt;/p>
&lt;p>参考链接：&lt;/p>
&lt;p>&lt;a href="http://www.xmlas.com/wordpress-add-favicon-ico.html" title="ref 1"> 给WP地址栏添加一个Favicon图标&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.boke8.net/wordpress-favicon-ico.html" title="ref 2">WordPress 博客添加个性标志favicon.ico&lt;/a>&lt;/p></content></item></channel></rss>