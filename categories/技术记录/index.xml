<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术记录 on 不是追风少年</title><link>https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/</link><description>Recent content in 技术记录 on 不是追风少年</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 26 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.formalscience.com/categories/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/index.xml" rel="self" type="application/rss+xml"/><item><title>Go to Rust （一）</title><link>https://blog.formalscience.com/go-to-rust/</link><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/go-to-rust/</guid><description>这几天看了 Rust 文档，把一些概念整理一下。
通过 cargo 新建一个项目，然后去管理其生命流程，这种现代做法很方便。 对于 statement 和 expression 的使用方式和 scheme 有些类似，可以返回最后一个 expression 的值。 可能返回错误的地方使用 Result 类型，很类似 Haskell 的处理流程。 模式匹配的方式很像 Ocaml 。 ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。 Option 类型就是 Haskell 的 Maybe 。 generics 的设计不知道有没有参考 C++ 的 template 概念。 目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。</description></item><item><title>pip 离线安装包</title><link>https://blog.formalscience.com/pip-install-package-offline/</link><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/pip-install-package-offline/</guid><description>1. 使用场景 在没有网络的设备上使用 pip 安装包。下面以 sklearn 包为例展示如何在没有网络的环境下安装包。
2. 下载包到本地缓存 首先进入一个目录，在这个例子里是 /Users/bef0rewind/Downloads/pip-tmp 目录。
pip download sklearn 我这里下载到了一个缓存目录 /Users/bef0rewind/Downloads/pip-tmp，随便选一个就好。pip download 只会下载对应的包，不会进行安装。
此时使用，pip freeze 可以看到已经安装的包，如果之前没有安装过 sklearn，显示的列表里是没有这个包的。
3. 断网安装 为了展示没有网络的情况下如何安装，我断开网络进行了验证。
pip install --no-index --find-links=/Users/bef0rewind/Downloads/pip-tmp sklearn 其中 --find-links 要 pip 从指定的目录里寻找安装包。
4. 其他 如果要用 Python3，而系统默认的版本是 Python 2，则可以将 pip 命令换成 pip3。</description></item><item><title>Escape from escape analysis</title><link>https://blog.formalscience.com/escape-from-escape-analysis/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/escape-from-escape-analysis/</guid><description>1. 逃逸分析背景 Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。 特点是全局停顿时间比较少，在一些场景下是十微秒级别的。
垃圾回收算法针对的是堆（heap）中的内存。 为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。 这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。
而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。 如这篇文章《Golang escape analysis》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。
对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。 这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。
2. Go 版本 使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。
ThinkPad-X1-Carbon:bin bef0rewind$ ./go version go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64 3. 示例 // file: escape.go package main import &amp;#34;fmt&amp;#34; type BigTempObject struct { /// ... field1 int } func causeEscape(i interface{}) { switch i.</description></item><item><title>Golang Receiver Type 探索</title><link>https://blog.formalscience.com/golang-receiver-type/</link><pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/golang-receiver-type/</guid><description>1. 参考 在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。
https://golang.google.cn/ref/spec#Method_sets https://golang.google.cn/ref/spec#Types https://golang.google.cn/ref/spec#Struct_types https://golang.google.cn/ref/spec#Composite_literals 核心的概念是 method sets：
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T).</description></item><item><title>defer, panic and recover in Golang</title><link>https://blog.formalscience.com/golang_exception_handling/</link><pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/golang_exception_handling/</guid><description>1. 什么是异常处理 程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。 一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 try/catch/finally 机制（https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、 Python 的 try/raise/except/finally 机制（https://docs.python.org/3/tutorial/errors.html）等。
2. Go 语言中的异常处理机制 Go 语言中使用的是 defer/panic/recover 机制来处理异常。Go 语言官方博客的《Defer, Panic, and Recover》讲述了这个机制的具体应用方式。
还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：
The Right Places To Call The recover Function：https://go101.org/article/panic-and-recover-more.html ，几种使用 recover 恢复 Go 语言中 panic 的适用场景 7.异常处理：https://www.kancloud.cn/liupengjie/go/578555 ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节 如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 defer + recover 处理一个 panic，defer 结构要在 panic 触发之前被定义而且 recover 要直接在在 defer 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。
3. defer 语法糖的部分原理 在讲述 defer 机制的文章中，都会提到一个函数中多个 defer 结构执行的顺序和定义顺序是相反的，即后定义的 defer 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：</description></item><item><title>Useful Commands</title><link>https://blog.formalscience.com/commands/</link><pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/commands/</guid><description>Convert images to a video ffmpeg -r 30 -start_number 3455 -i _IMG%d.jpg -s 960X600 -pix_fmt yuv420p 30fps-960.mov -r 30: 30 frames per second -s 960X600: resolution -pix_fmt yuv420p: for OsX youtube-dl video and extract audio file youtube-dl --proxy socks5://127.0.0.1:1080 -x --audio-format mp3 youtube-url
virtualenvwrapper WORKON_HOME: which directory your environments are created in /usr/local/bin/virtualenvwrapper.sh: default location for its configuration file mkvirtualenv test --python=python3: make a virtual environment &amp;rsquo;test&amp;rsquo; with python3 rmvirtualenv test: remove a virtual environment &amp;rsquo;test' workon test3 or lsvirtualenv -b test3: activate a virtual environment &amp;rsquo;test' deactivate: exit current environment more details: search engine how to avoid globa packages how to copy an environment node &amp;amp;&amp;amp; npm npm complains: Error: Cannot find module 'process-nextick-args'</description></item><item><title>Upgrade DigitalOcean's Ubuntu 17.04 to LTS version in 2018-06</title><link>https://blog.formalscience.com/update_vps_ubuntu_version/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/update_vps_ubuntu_version/</guid><description>What happened? I found my proxy for accessing some websites stopped working today, so I had to change my VPS&amp;rsquo;s IP address. After some trials, everything seemed OK and I started watching a skiing video made by NorthFace on Youtube.
Emmmm, I noticed 12 packages needed to be updated. Well, I typed sudo apt-get update and got messages like this (I didn&amp;rsquo;t save the error messages then):
404 Not Found [IP: 91.</description></item><item><title>理解 C++ Traits</title><link>https://blog.formalscience.com/%E7%90%86%E8%A7%A3_c++_traits/</link><pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/%E7%90%86%E8%A7%A3_c++_traits/</guid><description>C++ 是我学习的第一种编程语言，当时是 2007 年。现在 C++ 标准委员会已经在讨论 2020 年要发布的特性了，我连 2011 年发布的 Traits 都还不知道是啥。今天下定决心了解总结一下。
C++ 之父 Bjarne Stroustrup 说：
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine “policy” or “implementation details”.
嗯，这段描述也比较抽象。我的理解是，trait 把不同类型的特定信息进行打包，用在算法或者其他对象中。这样算法或者其他对象的设计可以做到更加通用，通过 trait 打包的信息进行策略选择或者实现细节。
这段代码判断两个类型的关系。第 4 行的模板以两个类型作为参数，通过结构体 type_relation 的成员 relation 获取比较结果。当前代码输出：
type_relation&amp;lt;bool, int&amp;gt;: different type_relation&amp;lt;int, int&amp;gt;: different 这段代码并未实现预期功能，因为比较 bool 和 int，以及 int 和 int 时，都输出 &amp;quot;different&amp;quot; 。下面继续完善这个 trait 实现。</description></item><item><title>‘How Does Monero Work?' 笔记</title><link>https://blog.formalscience.com/how-does-monero-work-%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 21 Jan 2018 15:46:20 +0000</pubDate><guid>https://blog.formalscience.com/how-does-monero-work-%E7%AC%94%E8%AE%B0/</guid><description>Monero 门罗币的一个介绍视频
我刚买到 1070Ti 显卡时曾经想要挖过这个币，后来放弃了，觉得没有意义。不过了解这个技术的一些原理还是有价值的。
Siraj Raval 的免责声明： 
Monero 是一种不可追踪的加密货币，网络上很多非法买卖东西的人会使用它。他介绍这个技术的原因是：你应当对你的数据有控制权，而很多数据是交易数据（transactional data）。目前很多公司可以从中免费挖掘信息，用来预测你的购买行为，以便向你展示广告。理想情况下他们应当为你的数据付费，而他们付费的唯一可能是你控制着数据，而唯一控制数据的方式为数据是匿名的。为了查阅你的交易历史，</description></item><item><title>两个玻璃球（网上流传的面试题）</title><link>https://blog.formalscience.com/%E4%B8%A4%E4%B8%AA%E7%8E%BB%E7%92%83%E7%90%83%E7%BD%91%E4%B8%8A%E6%B5%81%E4%BC%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Wed, 17 Jan 2018 19:57:18 +0000</pubDate><guid>https://blog.formalscience.com/%E4%B8%A4%E4%B8%AA%E7%8E%BB%E7%92%83%E7%90%83%E7%BD%91%E4%B8%8A%E6%B5%81%E4%BC%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>据说这是 Google 的一个面试题：
有一栋 100 层高的大楼，有两个完全相同的玻璃球。假设从某一层开始丢下玻璃球会摔碎，利用手中的两个玻璃球确定是第几层。最少扔几次玻璃球可以确定这个临界楼层（玻璃球在这一层以及更高的楼层扔下会摔碎）？
就如孔子说过的那句名言 &amp;ldquo;I Never Said All That Shit&amp;rdquo; 一样，这个题目出自哪里我也没有去考证。下面把我的思路整理一下。
如果只有一个玻璃球，能做的就是从 1 层开始尝试扔下玻璃球，然后尝试 2 层、3 层 ……，直到某一层扔下玻璃球后摔碎。而现在有两个玻璃球，我们可以用一个玻璃球从 1 层、11 层、21 层 …… 扔下去，确定一个较小的破碎范围，然后使用第二个玻璃球确定具体的楼层。
假如总共 N 层，我们从第 X 层扔下第一个玻璃球，有两种可能性：玻璃球摔碎或者没碎。如果玻璃球摔碎，说明临界楼层在 1~X 中；如果没摔碎，则临界楼层在 X+1~N 中。
如果临界楼层在 1~N 中是均匀分布的，那么 $N &amp;gt; 2$ 时确定临界楼层需要扔玻璃球的最少次数可以由以下公式表示：
$$ f(N)= \min_{X \in [1, N]} {1 + f(N-X)\frac{N-X}{N} + g(X)\frac{X}{N}} $$
$f(N)$ 为使用两个玻璃球确定区间长度为 N 时的临界楼层所用次数，$g(X)$ 为使用一个玻璃球确定区间长度为 N 时的临界楼层所用次数。这个公式的三部分分别对应：
一次扔玻璃球的尝试 玻璃球未摔碎概率$\times$此时继续尝试需要的次数 $f(N-X)$（两个玻璃球） 玻璃球摔碎概率$\times$此时继续尝试需要的次数 $g(X)$（一个玻璃球）。 显然有 $f(1)=0$，$g(N)=N-1$。可以用动态规划求解 $N=100$ 时需要的最少次数。</description></item><item><title>Golang 系统调用/Syscall</title><link>https://blog.formalscience.com/golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</link><pubDate>Mon, 15 Jan 2018 20:59:11 +0000</pubDate><guid>https://blog.formalscience.com/golang-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall/</guid><description>概述 很多和系统相关的函数都需要调用系统 API，例如读写文件的函数。Golang 对一些系统调用接口进行了封装，提供了 Golang 函数让用户调用，例如：
func Read(fd int, p []byte) (n int, err error) func Write(fd int, p []byte) (n int, err error) 同时，Golang 也提供了对 Syscall 的直接调用支持：
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) RawSyscall 和 RawSyscall6 是对操作系统 Syscall 的直接调用；Syscall 和 Syscall6 会在调用操作系统 Syscall 前调用 runtime·entersyscall ，在操作系统 Syscall 返回后调用 runtime·exitsyscall 。</description></item><item><title>Golang 中学到的新东西</title><link>https://blog.formalscience.com/golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</link><pubDate>Sun, 14 Jan 2018 11:53:30 +0000</pubDate><guid>https://blog.formalscience.com/golang-%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</guid><description>数据类型 string 类型 string 类型使用 2 个 word（64 bit 系统为 8 byte * 2）表示：一个 word 是指针，指向字符串存储区域；一个 word 表示长度数据。
slice $\leftrightarrow$ unsafe.Pointer s := make([]byte, 200) ptr := unsafe.Pointer(&amp;amp;s[0]) var ptr unsafe.Pointer s := ((*[1&amp;lt;&amp;lt;10]byte)(ptr))[:200] or
var ptr unsafe.Pointer var s1 = struct { addr uintptr len int cap int }{ptr, length, length} s := *(*[]byte)(unsafe.Pointer(&amp;amp;s1)) or
var o []byte sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;amp;o))) sliceHeader.Cap = length sliceHeader.Len = length sliceHeader.</description></item><item><title>使用 Nvidia 显卡加速机器学习算法的一些资料</title><link>https://blog.formalscience.com/%E4%BD%BF%E7%94%A8-nvidia-%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/</link><pubDate>Sat, 13 Jan 2018 13:14:09 +0000</pubDate><guid>https://blog.formalscience.com/%E4%BD%BF%E7%94%A8-nvidia-%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/</guid><description>Nnidia 显卡可以用来加速机器学习算法（特别是深度学习），但安装驱动过程中总会碰到这样或者那样的问题。 一个难点是安装库的时候没有下载链接，比如 Nvidia 的 Cuda/cuDNN 主页经常会出现这样的提示：
NVIDIA Developer Site is under going maintenance. The site will be back by shortly. We apologize for any inconvenience. 虽然不能按照官方路径进行下载，但经过搜索总能找到一些入口。下面是我收集的一些链接：
cuDNN 下载页面：https://developer.nvidia.com/rdp/cudnn-download 这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 cuDNN v5.1 到 cuDNN 7.0.5 的版本 CUDA 下载页面：https://developer.nvidia.com/cuda-toolkit-archive 这个页面需要注册 Nvidia 开发者账号并登录，当前包含从 CUDA Toolkit 1.0 到 CUDA Toolkit 9.0 的版本，最新的 CUDA Toolkit 9.1 的链接仍然指向正在维护的提示页面 Ubuntu 16.04 CUDA Toolkit 9.1 下载链接：http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_9.1.85-1_amd64.deb 此外可以在这个页面找到其他 Linux 发行版的安装包：http://developer.download.nvidia.com/compute/cuda/repos/ Windows 10 版本的 CUDA Toolkit 9.</description></item><item><title>一些有趣的项目 Protocol Labs</title><link>https://blog.formalscience.com/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE_protocol_labs/</link><pubDate>Fri, 12 Jan 2018 21:37:21 +0000</pubDate><guid>https://blog.formalscience.com/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE_protocol_labs/</guid><description>最初在 3Blue1Brown 发布的一个介绍区块链原理的视频中看到了这个组织的连接。发现比较有意思，给大家分享一下~
项目的使命：
We believe the internet has become humanity&amp;rsquo;s most important technology. We build protocols, systems, and tools to improve how it works. Today, we are focused on how we store, locate, and move information.
我们相信互联网已成为人类最重要的技术。我们构建提升互联网工作能力的协议、系统和工具。当前我们集中在如何存储、定位和移动信息的工作上。
这段文字翻译得有点机器翻译风格。
项目地址：https://protocol.ai/projects/ ，目前上面有 5 个项目：
Filecoin 加密货币，Miners 通过向网络提供存储空间来获取 Filecoin ，使用者通过消耗 Filecoin 来在去中心化的网络中存储加密后的文件。 IPFS (InterPlanetary File System) 一种新型协议，用来使网络去中心化。IPFS 通过内容寻址和数字签名来创建完全去中心化和分布式的应用。IPFS 使得网络更快、更安全以及更加开放。 这是一段 YouTube 上的介绍视频：https://www.youtube.com/watch?v=8CMxDNuuAiQ ，介绍了 IPFS 的一些基本使用方法。根据我的理解，这是通过 content-address（immutable hash） 访问的分布式加密文件系统，可以通过命令行、网页界面等多种方式进行访问，有点类似 Samba，不过是分布式的。Siraj Raval 制作的一个视频：https://www.</description></item><item><title>Ingress_Passcode_自动提交</title><link>https://blog.formalscience.com/ingress-passcode-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/</link><pubDate>Wed, 18 Jan 2017 13:10:10 +0000</pubDate><guid>https://blog.formalscience.com/ingress-passcode-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/</guid><description>什么是 Passcode？ 根据 Ingress 中文游戏指南 的讲解，Passcode 是 Ingress 提供的一种奖励。
使用 Investigation Board 来了解 Ingress 的最新剧情并寻求对 Niantic Project, NIA, XM, Shapers 以及各阵营不同问题的答案。 可以使用隐藏在这些报告之中的 Passcode 来兑换道具（Resonator，XMP 等），XM 或者 AP。
另外，一些官方活动会向到场者赠送包含 Passcode 的卡片，特定的官方周边也会赠送此类卡片。卡片上的 Passcode 一般能够兑换活动徽章。
注：在很多社交网站上可以找到有效的 Passcode
在 iOS 平台的 Ingress 客户端上 Passcode 兑换功能不可用，因此只能使用 Intel Map 来兑换。
在 Intel Map 上兑换 在右上方点击 Passcode 输入你的 passcode，然后点击 SUBMIT 兑换 自动化 Intel Map 兑换过程 可以通过浏览器的调试页面，自动将搜寻到的 passcode 提交，进行物品兑换。
表单提交 document.</description></item><item><title>如何构建一个 Java Agent</title><link>https://blog.formalscience.com/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA_java_agent/</link><pubDate>Mon, 16 Jan 2017 18:58:28 +0000</pubDate><guid>https://blog.formalscience.com/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA_java_agent/</guid><description>First. Implement a static premain (as an analogy to main) method, like this:
import java.lang.instrument.Instrumentation; class Example { public static void premain(String args, Instrumentation inst) { ... } } Second. Create a manifest file (say, manifest.txt) marking this class for pre-main execution. Its contents are:
Premain-Class: Example
Third. Compile the class and package this class into a JAR archive:
javac Example.java jar cmf manifest.txt yourAwesomeAgent.jar *.class</description></item><item><title>Windows 推荐软件</title><link>https://blog.formalscience.com/windows_%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6/</link><pubDate>Fri, 16 Sep 2016 10:56:11 +0000</pubDate><guid>https://blog.formalscience.com/windows_%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6/</guid><description>在知乎上看了一些推荐
Total Commander Listary AutoHotKey Internet Download Manager paint.net pot player Tickeys 7-zip Beyond Compare PowerTab (Powershell auto complete) Fiddler ZoomIt Postman - Chrome 里的 HTTP/REST 客户端，Web 服务专用神器 Pixie - 简单，可爱，便携的取色器 快捷键
Windows+Tab调出虚拟桌面 Alt+Tab 切换不同的窗口 Windows+Ctrl+D 创建新的虚拟桌面 Windows+Ｃtrl+F4 关闭当前虚拟桌面 Ctrl＋Windows＋左右箭头　虚拟桌面切换</description></item><item><title>函数式语言课程期末考试判卷中遇到的一个问题</title><link>https://blog.formalscience.com/%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%88%A4%E5%8D%B7%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 03 Feb 2016 10:36:57 +0000</pubDate><guid>https://blog.formalscience.com/%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%88%A4%E5%8D%B7%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</guid><description>在使用半自动化 Judge 系统对同学的答题进行评测的时候，遇到了一个奇怪的问题，总是会提示: Test_1: output.txt: openFile: resource busy (file is locked)
起初以为是 haskell 惰性求值导致的 IO 问题，因为搜索引擎也把猜测引导向这个原因，但是始终解决不了。
后来改变了思路，“现在看来好像是模块引入带来的 main 函数重名问题”，这是后面的猜疑。
继而发现将函数改名字也解决不了问题，实际也不是，就是 IO 的问题。因为如果先移除 output.txt， 那么使用 ghc 执行就不会出现之前的错误提示，不过在 ghci 中执行总是不会出错。
使用如下代码测试一下：
dir = &amp;quot;/home/user-name/Downloads/auto_check/work/2015final/ref/tests/words&amp;quot; main :: IO () main = do print &amp;quot;hehe&amp;quot; solution = runTest (map (\f -&amp;amp;gt; combine dir f) [&amp;quot;input1-1.txt&amp;quot;, &amp;quot;input1-2.txt&amp;quot;, &amp;quot;input1-3.txt&amp;quot;]) (combine dir &amp;quot;output1.txt&amp;quot;) `&amp;lt;/pre&amp;gt; 执行得到如下结果： &amp;lt;pre&amp;gt;`➜ test ghci Test_1.hs GHCi, version 7.8.4: http://www.haskell.org/ghc/ :? for help Loading package ghc-prim .</description></item><item><title>为什么 Haskell 中 函数类型 不是 “Show” 类型类的实例</title><link>https://blog.formalscience.com/%E4%B8%BA%E4%BB%80%E4%B9%88_haskell_%E4%B8%AD_%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B_%E4%B8%8D%E6%98%AF_show_%E7%B1%BB%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B/</link><pubDate>Wed, 03 Feb 2016 10:01:41 +0000</pubDate><guid>https://blog.formalscience.com/%E4%B8%BA%E4%BB%80%E4%B9%88_haskell_%E4%B8%AD_%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B_%E4%B8%8D%E6%98%AF_show_%E7%B1%BB%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B/</guid><description>问题 为什么函数类型不是 show 类型类的实例以显示参数和值的类型？
为什么我不能在 GHCi 或者 Hugs 中输入 \x -&amp;amp;gt; x + x ，在结果中看到同样的表达式形式作为输出。
为什么存在一个 Show 实例，却只打印函数的类型？
Prelude&amp;amp;gt; :m + Text.Show.Functions Prelude Text.Show.Functions&amp;amp;gt; show Char.ord &amp;quot;&amp;amp;lt;function&amp;amp;gt;&amp;quot; `&amp;lt;/pre&amp;gt; 如何让 lambdabot 有如下显示： &amp;lt;pre&amp;gt;`dons &amp;amp;gt; ord lambdabot&amp;amp;gt; &amp;amp;lt;Char -&amp;amp;gt; Int&amp;amp;gt; `&amp;lt;/pre&amp;gt; # 答案 ## 实践中的答案 Haskell 编译器并不保持表达式原本的形式，而是将它们转成机器代码或者其他的底层表示。 函数 `\x -&amp;amp;gt; x - x + x :: Int -&amp;amp;gt; Int` 也许被优化成 `\x -&amp;amp;gt; x :: Int -&amp;amp;gt; Int` 。没有那个地方l存储了变量名 `x` 。 你也许会想，Haskell 是一门脚本语言，在运行时环境中维护着表达式的内容。情况并非如此，[Lambda 表达式](https://wiki.</description></item><item><title>關於 LLVM Pass 的一些基本操作</title><link>https://blog.formalscience.com/%E9%97%9C%E6%96%BC_llvm_pass_%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 09 Jan 2016 21:46:48 +0000</pubDate><guid>https://blog.formalscience.com/%E9%97%9C%E6%96%BC_llvm_pass_%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid><description>關於 LLVM Pass 的一些基本操作 記錄一下關於 LLVM Pass 的一些操作，主要是一些配置工作。雖然目前的工作流程不是很優雅，但是可以自定義 LLVM Pass 的處理過程，通過進一步學習可以作出更有意思的東西。
本文的 GitHub 地址： https://github.com/ronhuafeng/HandleLLVMPassBasic ，有這篇文章和一些粗糙的源代碼。
網絡上已經有一下教程了，我也參考了這些教程。
使用 clang 加載 LLVM 的 Pass LLVM - Run Own Pass automatically with clang stack overflow 上的回答，試圖使用 clang 加載 LLVM 的 Pass。 Polly 库加載 LLVM Pass 的方法也是一个解决思路，我參考了這裏面的很多：Load Polly into clang and automatically run it at -O3 具体的加載過程參考了 Adrian Sampson 博客 Run an LLVM Pass Automatically with Clang 中提到的操作。 工作流程 準備工作 將系統中自帶的 llvm 和 clang 都卸載掉，保證 llvm 和 clang 版本的一致性（非常重要），即保證使用的 clang 和 編譯出的 Pass 的動態鏈接庫文件 .</description></item><item><title>Thinkpad T430 Windows&amp;Ubuntu Dual Boot</title><link>https://blog.formalscience.com/thinkpad_t430_windowsubuntu_dual_boot/</link><pubDate>Fri, 11 Dec 2015 10:03:56 +0000</pubDate><guid>https://blog.formalscience.com/thinkpad_t430_windowsubuntu_dual_boot/</guid><description>在 Thinkpad T430 带有原装操作系统（其实是原声的 EFI 分区）的情形下，UEFI 模式下安装 Ubuntu 并成功启动进入 Ubuntu 系统。主要难度是原装电脑启动时会首先加载一个 “LenovoBT.efi” 的文件，然后 Lenovo 直接会去找 Windows 系统相关的 efi 文件，然后忽略其他的系统。T440s 预装win8.1 GPT+EFI ubuntu 双系统 图文过程中提到这样的启动处理：
加载 /EFI/Boot/LenovoBT.EFI /EFI/Boot/bootx64.efi，加载windows的boot loader /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi，启动windows 因此这个文档记录了如何把这个流程给截断，使得 Ubuntu 的启动引导文件可以被看到。
首先说明没有起作用的教程：
Windows 10 Pro + Ubuntu 14.04.3 LTS 雙系統安裝 中提到最后在 Windows 的命令行中使用如下命令 bcdedit /set {bootmgr} path \EFI\ubuntu\grubx64.efi 并没有生效 百度贴吧一个教程 - T440s 预装win8.1 GPT+EFI ubuntu 双系统 图文过程 中提到使用 Ubuntu 的引导文件 “grubx64.efi” 替换 “EFI/Boot” 里面的 “bootx64.efi”，没有效果，可能是 “LenovoBT.efi” 没有走前文提到的处理流程。 有效的教程 Windows 8 removes Grub as default boot manager：</description></item><item><title>那些关于函数式编程和函数式编程语言的神话（译）</title><link>https://blog.formalscience.com/%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/</link><pubDate>Thu, 22 Oct 2015 07:37:41 +0000</pubDate><guid>https://blog.formalscience.com/%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%AF%91/</guid><description>这是翻译自 Quora 一个问题“What are some myths about functional programming and functional programming languages?” 的一个高票答案，我也不记得当初决定翻译它时的心情，不过历经多次组会，最终完工了。
下面是我能想到的，更具体的一些细节会在后面给出：
“函数式编程”是定义明确的概念 函数式编程仅仅是命令式编程的特殊形式 函数式编程本来就很难 函数式编程本来就是复杂的 函数式编程不宜编写图形用户界面 Haskell 仅仅是函数式的 你需要大量的数学知识来进行函数式编程 函数式程序员必须非常聪明而且擅长计算机科学 “函数式编程” 是一个（明确的）概念 它不是。它是计算机科学中定义最糟糕的术语之一 —— 甚至不如“面向对象”，但比“声明式编程”好一点点。弄清楚一种语言是否是“函数式的”是一个人类学（anthropology）上的练习而非计算机科学。
没有任何一种“函数式编程”的技术定义不会引发众人抱怨。有些定义过于宽泛 —— 如果你想要的是 lambda 表达式，那么一切从 C ++ 到 Java 到 Python 的语言突然都变得“函数式”了，只有 C 和汇编不是！如果你要一个数学上的定义，那么只有 Coq、Agda 和它们的朋友们是函数式的，因为就算是 Haskell 都允许部分函数和非终止性。还有异常。哦，上帝，异常！
就我个人来讲，称每一种带有“脉冲”的语言（即任何具有 lambda 表达式的语言，lambda 的符号为 λ，像一个脉冲）为“函数式的”并没什么用。当我说“函数式的”，我通常是指像 Haskell 或至少是 ML 的语言，而不是像 Java、Python、 JavaScript，或者甚至是 Common Lisp 的语言。Scheme 和 Clojure 有点是函数式的，但我不会对它们谈论过多，即便我的确有大量关于前者（Scheme）的经验。
好吧，实话说，我的意思只是“Haskell”，除非我明确提出不是。是啊，这是为了你们的语言学上的定义。（脑补出这个翻译）如果你花更少的时间用命令式语言和更多的时间阅读我的思维，你就会明白3。
当然，有些人倾向于给“函数式编程”一个更杂糅的定义！
函数式编程仅仅是少了某些东西的命令式编程 这也许是最有害的神话，因为它广泛流传，特别具有误导性，通常未被明确说出。人们随意假设进行函数式编程就像一个穿着紧身衣的“正常”编程。并不是！一点也不。相反，函数式编程为编程提供了一个新的基础。你使用不同的方式表达事情。通常是全然不同的。事实上，大多数时间，在你使用命令式方法完成的事情和使用函数式方法完成的事情之间，不存在一个一一映射。</description></item><item><title>为什么用Clojure，以及一点感悟</title><link>https://blog.formalscience.com/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8clojure%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Mon, 02 Sep 2013 12:12:39 +0000</pubDate><guid>https://blog.formalscience.com/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8clojure%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>1.Java互操作Clojure和Java互操作还是比较简单的，网上有很多案例。
首先讲下Java中调用Clojure。
一种方式是用过clojure.lang中的一些方法引入一个命名空间中的函数和变量，然后使用，这种方法就要注意ClassPath和ClassLoader的问题，这在Eclipse的RCP开发中还是比较烦的。另外要注意如果有Clojure源码文件被编译成Class文件了，调用这些文件的Clojure.jar和编译出这些文件的Clojure.jar版本一定要一致。
另外一种方式就是使用 “:aot :all“ 命令把所有Clojure源码编译成JVM的Class文件，然后调用genclass方法产生的类和函数。这个可以比较方便地把接口暴露出来。这篇文章针对genclass的各种用法讲得很好。
在Clojure中调用Java就很简单了，随便一搜就是一大堆，官方文档也有很多例子。
2.编程模式Clojure本身就是JVM上的一个Lisp方言，所以编程模式主要就是函数式。当然我对函数式这个术语理解也不是很透彻，目前理解的函数式语言的特点就是：函数是第一公民、尽量保持无状态操作、有利于并行化操作、具有较强的作为meta language的能力（可以用来构建DSL）。这个可以看一下SCIP（计算机程序的构造和解释）这本书。
3.初衷我本来想用Scala的好嘛！其实，当时主要想做BIP（这个还是高端大气上档次的）这个形式化语言的一个解释器，然后依靠那个不靠谱的方案和一个还不存在的同步形式化语言解释器进行对接，构建一个仿真环境。
其实同为JVM上寄生的函数式语言，明显Scala做这个工作更有优势一点：基于OCaml（这个的前身ML我之前用过）、有方便的类型模式匹配机制（这个机制在写解释器时应该比较有用）。Clojure我也调研过，但是当时是没有这个想法用它的。但是呢，但是呢，亚马逊给我推送了一封邮件，里面就有《Clojure编程》这本书，然后我还顺着广告点过去买了。于是在我刚开始做这个工作的时候，Clojure就被选中了。
都是缘分啊！
4.困难
困难一部分来自对Clojure一些库不了解，对一些常见的实现习惯不了解，后来实践中逐渐搜索学习，也就掌握了。
另外一些来自于和实验室主项目集成的时候，Eclipse RCP项目的ClassLoader比较诡异，我之前也没怎么了解过，碰到了各种”ClassNotFound“的错误，后来经过查找还是解决了。这个是我的一个Evernote笔记。
5.编辑环境的的配置和各种尝试
我先后试过Emacs和Intellij IDEA。
Emacs我还是很喜欢的，特别是里面的ParEdit插件，用来进行Lisp中大量的括号相关的操作简直无敌了，就是要先学习一下快捷键，效率会提升很多。但是有一个缺点（我能说Emacs的缺点么？），配置起来麻烦。虽然各种插件我都装上了，用起来也不错，但是过程中遇到的各种陷阱还是很多的，网上的教程也不总是和预想中的一样有效。我还是一直坚持使用Emacs的。后来实验室的另一个工作要在Windows上进行，在Windows下我一直无法用Emacs启动Clojure的REPL，因此转向了神器——Intellij IDEA。
神器只要下个LaClojure的插件和Leiningen插件就好了。各种只能提示啦，测试啦都可以很方便使用，我还把keymap改成了Emacs式的，算是一个念想。不过神器下面没有ParEdit插件，没法那么方便地处理括号，有些不开心。
6.总结
在学校的一个优势呢，就是可以尝试新的东西（虽然想让我赶快完成项目的老板不这样想）。以前我也学习Lisp，ML等函数式语言，但是一直没有实际动手做个东西。这次虽然使用Clojure做这个解释器有些冲动的成分在里面，整体而言还是很满意的。最后解释器效率可能有些问题（我写的程序有问题，和语言无关），但是程序工作起来还比较正确（至少那些单元测试都还能通过），修改起来也比较容易（还需要一些重构）。我对于Java和Clojure的了解也都稍微深刻了那么一点（是在命名空间这方面）。
下次要不要试试其他的语言呢？
7.项目
主要是做了一个BIP的解释器，还没有做完，只是完成了核心的语义解释的一部分。前段的语法解析器没有做，不过这个有现成的。
8.经验
实践出真知！
这首歌我最近一直在单曲循环。
 </description></item><item><title>建模语言</title><link>https://blog.formalscience.com/%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</link><pubDate>Tue, 28 May 2013 16:40:19 +0000</pubDate><guid>https://blog.formalscience.com/%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</guid><description>今天晚上和师兄师弟们一起吃饭。去食堂的路上，一直到食堂为止都特别伤心。自己研究生生活都已经过了快两年，对自己的研究方向依然不能向别人解释清楚。特迷茫，特无助。下面是我的一些理解，不是很全面（不是我全部所想的，未必全部是对的）。
1.何谓建模？
建模就是对一个表示的抽象表示，使得抽象过的表示在一定假设下可以回答原始表示能够回答的问题。例如：
把程序抽象成一个流程图，这个流程图可以回答给定输入产生什么输出的问题； 把程序抽象成一个函数依赖图，可以回答关于函数之间调用关系的问题； 把一个地表的自由落体抽象成成真空中的自由落体，（忽略掉空气阻力和允许一定误差情况下）回答自由落体从指定高度到达地面的时间问题 2.建模语言 语言是一种表现形式，就如眼神一样，直达人的灵魂深处。好吧，我文（che）艺（dan）了。写程序需要（编程）语言，刻画物理现象需要（数学）语言，把听到的曲调记录下来也需要（乐谱使用的）语言。建立这些事物的抽象表示（建模过程）也需要一种语言，称为建模语言，例如：UML、Petri Net、自动机（Automata）、正则表达式、上下文无关文法等。
3.建模语言分类
正如编程语言、数学语言有能力强弱、是否易用、山头派系之分，建模语言也是如此。这里主要针对程序建模语言进行说明。
图灵机是一种基础的建模语言，有许多建模语言都用图灵机作为基础来解释自身语义，或者来比较自己的能力。有一些语言表达能力等价于图灵机，有一些语言表达能力则非常有限。能力强弱并不对应语言的好坏。
其中一些语言的等价性可以用来出一些题目，例如把一个正则表达式转化为一个DFA（确定有限自动机）。
这些语言又可以按照是否有形式化的表示分为：形式化语言（Formal Languages）和非形式化语言（Informal Languages）。形式化语言的形式化表示一般使用数学中的集合和映射表示；非形式化语言一般都会有对应的非形式化的执行语义（即用自然语言说明语言中各种操作的含义，例如普通的C语言）。
按照使用范围会有针对嵌入式系统的建模语言（VHDL）、针对需求的建模语言（UML）、针对算法的建模语言（程序流程图）等等。
还有其他按照各种方法的各种分类，例如同步建模语言、异步建模语言、全局异步局部同步建模语言。我知道的并不全面，每次和大牛交流都感觉到自己的无知。
4.建模语言领域研究什么
如何在增加语言表达能力和易用性同时不影响语言其他方面的性质（语法的简洁性等）。例如图灵机中是没有整形变量的表示的，我们能看到的只有0/1的纸带。因此汇编、C等加入了各种数据结构，但是其需要解释的语义就更复杂了。相比之下Lisp的语法语义就比较简洁。
如何针对特定领域对语言进行封装优化。近些年比较火热的领域特定语言（DSL）目的就是如此。
如何能够支持模型的性质检测。可以参考模型检测领域（Model Checking）的相关知识。
如何能够用建模的模型生成一些代码，即用建模语言作为一种编程语言。这样要求建模语言要有和生成代码使用语言的比较优势（较少的代码量、简洁清晰的语义、更简单的并行并发描述等）。这种使用方式有一个相关概念：模型驱动的开发。
下面的 #5 内容会和 #4 没有那么正交，请海涵。
5.建模语言领域能够贡献的工作
写一种全新的建模语言。嗯，这个一般都是持续N（&amp;gt;10）年的工作。
在一种建模语言基础上添加/封装一些操作符，从而对一些被建模对象的行为提供直接支持（例如支持建模buffered signal transmission）。DSL。
把两种建模语言整合起来。比较难，需要用更低级的语言解释两者语义，以及其他一大堆问题需要处理。
对指定的建模语言生成另一种语言的代码。例如：C to Verilog，Esterel to C等。
给建模语言建立的模型写simulator，即解释建模语言的执行语义。
给建模语言写图形化的编辑器，例如Visual Studio中的GUI绘制工具。
等等一系列，一系列。
6.我在做啥
最近在做对增加了时间表示的BIP模型和增加了时间表示的Esterel模型二者混合模型的执行语义解释。现在正处于用Clojure写没有时间表示的BIP模型执行语义解释的地步。
最近在做把BIP模型生成的代码转化成C语言代码，然后在ARM板卡上执行的流程探索。这条路已经基本走通，我能说今天中午什么事都没有做，然后之前bug的程序就能够在ARM板卡上运行了么。这真是上天不负有（gou）心（shi）人（yun）啊。
  </description></item><item><title>Archlinux Install Notes</title><link>https://blog.formalscience.com/archlinux_install_notes/</link><pubDate>Wed, 27 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/archlinux_install_notes/</guid><description>分区格式化 cfdisk mkfs.ext /dev/sda* mkswap /dev/sdaX swapon /dev/sdaX
挂载当前分区 检查当前磁盘的标识符和布局 lsblk /dev/sda mount /dev/sda1 /mnt mkdir /mnt/home 如果是home独立分区 mount /dev/sda2 /mnt/home
编辑 /etc/pacman.d/mirrorlist 更新 pacman -Syy
使用pacstrap脚本安装基本系统
pacstrap /mnt base base-devel 如果 pacman 报告安装时遇到错误的签名(error: failed to commit transaction (invalid or corrupted package))，请运行如下命令：
pacman-key &amp;ndash;init &amp;amp;&amp;amp; pacman-key &amp;ndash;populate archlinux base 来自 [core] 软件源的最小基本系统。 base-devel 来自 [core] 的附加工具例如make和 automake。大部分新手都应该安装它，后续扩展系统会用到它，安装AUR中软件包时，base-devel也是必须的
生成 fstab
用下面命令生成 fstab。如果想使用 UUIDs，使用 -U 选项；如果想使用标签，用 -L 选项，完成后最好检查一下生成的/etc/fstab。 Note: 后面如果出现问题，请不要再次运行genfstab，如果需要，手动编辑/etc/fstab。
genfstab -U -p /mnt | sed &amp;rsquo;s/rw,relatime,data=ordered/defaults,relatime/&amp;rsquo; &amp;gt;&amp;gt; /mnt/etc/fstab nano /mnt/etc/fstab Chroot 到新系统</description></item><item><title>Python使用smtplib发送邮件</title><link>https://blog.formalscience.com/python%E4%BD%BF%E7%94%A8smtplib%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</link><pubDate>Tue, 13 Nov 2012 10:50:48 +0000</pubDate><guid>https://blog.formalscience.com/python%E4%BD%BF%E7%94%A8smtplib%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</guid><description>from smtplib import SMTP
#这些库是邮件格式使用的 from email.mime.text import MIMEText from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart
smtp = SMTP()
smtp.connect(&amp;lsquo;smtp.163.com&amp;rsquo;)
#这句话是必不可少的 smtp.helo()
#选择认证方式 smtp.esmtp_features[&amp;lsquo;auth&amp;rsquo;] = &amp;lsquo;LOGIN&amp;rsquo; smtp.login(&amp;rsquo;####@163.com&amp;rsquo;, &amp;lsquo;password&amp;rsquo;)
message = MIMEMultipart() message.attach(MIMEText(&amp;lsquo;content&amp;rsquo;)) message[&amp;ldquo;Subject&amp;rdquo;] = &amp;lsquo;subject&amp;rsquo;
smtp.sendmail(&amp;rsquo;####@163.com&amp;rsquo;, [&amp;lsquo;mail_to@163.com&amp;rsquo;], message.as_string())
差不多邮件这样就可以发送出去了</description></item><item><title>基于OpenShift搭建MediaWiki</title><link>https://blog.formalscience.com/%E5%9F%BA%E4%BA%8Eopenshift%E6%90%AD%E5%BB%BAmediawiki/</link><pubDate>Mon, 12 Nov 2012 15:45:19 +0000</pubDate><guid>https://blog.formalscience.com/%E5%9F%BA%E4%BA%8Eopenshift%E6%90%AD%E5%BB%BAmediawiki/</guid><description>1.按照OpenShift建立用用的过程新建一个PHP 5.3应用，可以通过网页方式创建（推荐）；本地完成一些初始化工作（参考官方教程）
2.按照应用页面给出的git地址，把代码库clone到本地，然后把MediaWiki代码push到Master库中。（git使用方法）
3.在应用页面点击那个“Add a Cartridge”，然后加上一个MySql数据库（应该是这样，我在命令行中添加的）和一个phpMyAdmin；把获得的数据库root用户名和密码记下来； 但是如何重新访问这些Cartridge，我还不知道啊，也许从命令行可以过去。
4.进入phpMyAdmin进行管理，左上方有MediaWiki连接数据库要使用的数据库地址（这个地方寻找地址卡了好久，直到安装了phpMyAdmin才得到的sql连接地址，应该还有其他方法的）
5.进入应用URL进行MediaWiki的初始化工作，剩下的就很简单了</description></item><item><title>Spin工具的Eclipse集成</title><link>https://blog.formalscience.com/spin%E5%B7%A5%E5%85%B7%E7%9A%84eclipse%E9%9B%86%E6%88%90/</link><pubDate>Sun, 19 Aug 2012 02:40:45 +0000</pubDate><guid>https://blog.formalscience.com/spin%E5%B7%A5%E5%85%B7%E7%9A%84eclipse%E9%9B%86%E6%88%90/</guid><description>Spin是Promela建模语言的解释器和验证工具。它本身有一个图形化的工具iSpin，不过这个图形化实在有些简陋。下面介绍一个Eclipse的插件，这样我们可以使用Eclipse的编辑环境来使用Spin。
首先，在Eclipse的install new software中添加 http://matrix.uni-mb.si/fileadmin/datoteke/znanost/orodja/ep4s/update-site/ 把Group items by category选项去掉，否则看不到可安装的插件；安装此插件。
然后，在菜单栏中选择Spin项，进入Spin Configuration，
Spin工具可以从其官网下载。
C Complier里的gcc可以用cygwin安装，记得选择直接的版本，不要选择gcc.exe，否则可能出现不能验证通过的错误。
基本上这样就算安装完成了，如果你有什么问题，可以给我留言。</description></item><item><title>Authorization:Basic后面的credentials内容</title><link>https://blog.formalscience.com/authorization-basic%E5%90%8E%E9%9D%A2%E7%9A%84credentials%E5%86%85%E5%AE%B9/</link><pubDate>Tue, 03 Jul 2012 02:23:52 +0000</pubDate><guid>https://blog.formalscience.com/authorization-basic%E5%90%8E%E9%9D%A2%E7%9A%84credentials%E5%86%85%E5%AE%B9/</guid><description>username+”:”+password的简单base64转换</description></item><item><title>如何增加人人网的访问量</title><link>https://blog.formalscience.com/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E4%BA%BA%E4%BA%BA%E7%BD%91%E7%9A%84%E8%AE%BF%E9%97%AE%E9%87%8F/</link><pubDate>Thu, 28 Jun 2012 03:32:39 +0000</pubDate><guid>https://blog.formalscience.com/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E4%BA%BA%E4%BA%BA%E7%BD%91%E7%9A%84%E8%AE%BF%E9%97%AE%E9%87%8F/</guid><description>主要是利用人们的好奇心吸引回访。
用爬虫去爬去一定数量的好友列表，获得一定数量的id文件。 用自己的帐号认证，然后从id文件中取得一个id，然后访问他的页面。 当访问的页面到达一定规模的时候，在这么多人里肯定有些人很好奇想要看看你是谁，然后就点回你的页面。 访问量和好友申请就飕飕涨了。</description></item><item><title>Eclipse导入Github库</title><link>https://blog.formalscience.com/eclipse%E5%AF%BC%E5%85%A5github%E5%BA%93/</link><pubDate>Sun, 17 Jun 2012 13:42:47 +0000</pubDate><guid>https://blog.formalscience.com/eclipse%E5%AF%BC%E5%85%A5github%E5%BA%93/</guid><description>导入要点
使用HTTPS的方式会容易一些，SSH的方式会有一些认证问题（这个极有可能是伪命题，因为第2条的原因） 先通过命令行把库拖下来，最好不要放在eclipse的workplace中 然后新建一个项目，在Team|Share|&amp;hellip;|Git一路选下去就好 （这个日志需要重新更改）</description></item><item><title>如何给WordPress博客换一个Favicon图标</title><link>https://blog.formalscience.com/%E5%A6%82%E4%BD%95%E7%BB%99wordpress%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%B8%80%E4%B8%AAfavicon%E5%9B%BE%E6%A0%87/</link><pubDate>Sun, 03 Jun 2012 16:56:18 +0000</pubDate><guid>https://blog.formalscience.com/%E5%A6%82%E4%BD%95%E7%BB%99wordpress%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%B8%80%E4%B8%AAfavicon%E5%9B%BE%E6%A0%87/</guid><description>整个过程大约分为以下几步
制作favicon.ico
在网站http://www.favicon.cc/里上传一张图片，通过点击“Import Image” 然后就可以根据各种选项对图片进行调整 最后通过点击“Download Favicon”进行下载 注：如果你有天赋可以自己设计图标，那么在那个编辑器里创作也是可以的 上传到博客目录，比如我上传到mydomain/blog目录下了，链接为http://www.formalscience.com/blog/favicon.ico
修改对应主题内的header.php，在&amp;lt;head&amp;gt;和&amp;lt;/head&amp;gt;之间添加如下代码：
&amp;amp;lt;LINK rel=icon type=image/x-icon href=&amp;quot;http://yourdomain/favicon.ico&amp;quot;&amp;amp;gt;
&amp;amp;lt;LINK rel=&amp;quot;shortcut icon&amp;quot; type=image/x-icon href=&amp;quot;yourdomain/favicon.ico&amp;quot;&amp;amp;gt;
对于我的博客来说就是
&amp;amp;lt;LINK rel=icon type=image/x-icon href=&amp;quot;http://www.formalscience.com/blog/favicon.ico&amp;quot;&amp;amp;gt;
&amp;amp;lt;LINK rel=&amp;quot;shortcut icon&amp;quot; type=image/x-icon href=&amp;quot;http://www.formalscience.com/blog/favicon.ico&amp;quot;&amp;amp;gt;
完成以上步骤后清空下浏览器缓存就可以看到效果了。
参考链接：
给WP地址栏添加一个Favicon图标
WordPress 博客添加个性标志favicon.ico</description></item></channel></rss>