<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tech-notes on 不是追风少年</title><link>https://blog.formalscience.com/categories/tech-notes/</link><description>Recent content in tech-notes on 不是追风少年</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 26 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.formalscience.com/categories/tech-notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Go to Rust （一）</title><link>https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/</link><pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/12/26/2018-12-26-go-to-rust/</guid><description>这几天看了 Rust 文档，把一些概念整理一下。
通过 cargo 新建一个项目，然后去管理其生命流程，这种现代做法很方便。 对于 statement 和 expression 的使用方式和 scheme 有些类似，可以返回最后一个 expression 的值。 可能返回错误的地方使用 Result 类型，很类似 Haskell 的处理流程。 模式匹配的方式很像 Ocaml 。 ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。 Option 类型就是 Haskell 的 Maybe 。 generics 的设计不知道有没有参考 C++ 的 template 概念。 目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。</description><content>&lt;p>这几天看了 Rust 文档，把一些概念整理一下。&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>cargo&lt;/code> 新建一个项目，然后去管理其生命流程，这种现代做法很方便。&lt;/li>
&lt;li>对于 &lt;code>statement&lt;/code> 和 &lt;code>expression&lt;/code> 的使用方式和 scheme 有些类似，可以返回最后一个 &lt;code>expression&lt;/code> 的值。&lt;/li>
&lt;li>可能返回错误的地方使用 &lt;code>Result&lt;/code> 类型，很类似 Haskell 的处理流程。&lt;/li>
&lt;li>模式匹配的方式很像 Ocaml 。&lt;/li>
&lt;li>ownership 机制很新颖，限制能够带来巨大的力量。让我想到了《全职猎人》中对某项能力增加限制条件可以增加这个能力的威力的设定。&lt;/li>
&lt;li>&lt;code>Option&lt;/code> 类型就是 Haskell 的 &lt;code>Maybe&lt;/code> 。&lt;/li>
&lt;li>generics 的设计不知道有没有参考 C++ 的 template 概念。&lt;/li>
&lt;/ul>
&lt;p>目前只看到文档的第 11 章，Rust 语言的很多概念都能够在其他语言找到对应，只有 ownership 机制是我第一次见到，觉得新颖有趣。&lt;/p></content></item><item><title>pip 离线安装包</title><link>https://blog.formalscience.com/2018/12/13/2018-12-13-pip-install-package-offline/</link><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/12/13/2018-12-13-pip-install-package-offline/</guid><description>1. 使用场景 在没有网络的设备上使用 pip 安装包。下面以 sklearn 包为例展示如何在没有网络的环境下安装包。
2. 下载包到本地缓存 首先进入一个目录，在这个例子里是 /Users/bef0rewind/Downloads/pip-tmp 目录。
pip download sklearn 我这里下载到了一个缓存目录 /Users/bef0rewind/Downloads/pip-tmp，随便选一个就好。pip download 只会下载对应的包，不会进行安装。
此时使用，pip freeze 可以看到已经安装的包，如果之前没有安装过 sklearn，显示的列表里是没有这个包的。
3. 断网安装 为了展示没有网络的情况下如何安装，我断开网络进行了验证。
pip install --no-index --find-links=/Users/bef0rewind/Downloads/pip-tmp sklearn 其中 --find-links 要 pip 从指定的目录里寻找安装包。
4. 其他 如果要用 Python3，而系统默认的版本是 Python 2，则可以将 pip 命令换成 pip3。</description><content>&lt;h2 id="1-使用场景">1. 使用场景&lt;/h2>
&lt;p>在没有网络的设备上使用 pip 安装包。下面以 &lt;code>sklearn&lt;/code> 包为例展示如何在没有网络的环境下安装包。&lt;/p>
&lt;h2 id="2-下载包到本地缓存">2. 下载包到本地缓存&lt;/h2>
&lt;p>首先进入一个目录，在这个例子里是 &lt;code>/Users/bef0rewind/Downloads/pip-tmp&lt;/code> 目录。&lt;/p>
&lt;pre tabindex="0">&lt;code>pip download sklearn
&lt;/code>&lt;/pre>&lt;p>我这里下载到了一个缓存目录 &lt;code>/Users/bef0rewind/Downloads/pip-tmp&lt;/code>，随便选一个就好。&lt;code>pip download&lt;/code> 只会下载对应的包，不会进行安装。&lt;/p>
&lt;p>此时使用，&lt;code>pip freeze&lt;/code> 可以看到已经安装的包，如果之前没有安装过 &lt;code>sklearn&lt;/code>，显示的列表里是没有这个包的。&lt;/p>
&lt;h2 id="3-断网安装">3. 断网安装&lt;/h2>
&lt;p>为了展示没有网络的情况下如何安装，我断开网络进行了验证。&lt;/p>
&lt;pre tabindex="0">&lt;code>pip install --no-index --find-links=/Users/bef0rewind/Downloads/pip-tmp sklearn
&lt;/code>&lt;/pre>&lt;p>其中 &lt;code>--find-links&lt;/code> 要 &lt;code>pip&lt;/code> 从指定的目录里寻找安装包。&lt;/p>
&lt;h2 id="4-其他">4. 其他&lt;/h2>
&lt;p>如果要用 Python3，而系统默认的版本是 Python 2，则可以将 &lt;code>pip&lt;/code> 命令换成 &lt;code>pip3&lt;/code>。&lt;/p></content></item><item><title>Escape from escape analysis</title><link>https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/11/30/2018-11-30-escape-from-escape-analysis/</guid><description>1. 逃逸分析背景 Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。 特点是全局停顿时间比较少，在一些场景下是十微秒级别的。
垃圾回收算法针对的是堆（heap）中的内存。 为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。 这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。
而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。 如这篇文章《Golang escape analysis》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。
对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。 这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。
2. Go 版本 使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。
ThinkPad-X1-Carbon:bin bef0rewind$ ./go version go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64 3. 示例 // file: escape.go package main import &amp;#34;fmt&amp;#34; type BigTempObject struct { /// ... field1 int } func causeEscape(i interface{}) { switch i.</description><content>&lt;h2 id="1-逃逸分析背景">1. 逃逸分析背景&lt;/h2>
&lt;p>Go 语言采用了并发的（Concurrent）、非移动的（Non-Movable）、非分代的（Non-Generational）、基于三色（Tri-color）标记的垃圾回收（Garbage Collection）算法，只在 特定阶段开启写屏障（write barrier）。
特点是全局停顿时间比较少，在一些场景下是十微秒级别的。&lt;/p>
&lt;p>垃圾回收算法针对的是堆（heap）中的内存。
为了减少垃圾回收的时间消耗，Go 语言在编译阶段通过静态分析算法对程序的结构进行分析，尽可能讲对象分配在栈上（如果这个对象的生命周期在它定义的函数返回时就结束的话）。
这一算法也利用了 Go 语言在函数传递参数时总是传递参数的值这一个语言特性。&lt;/p>
&lt;p>而静态分析不总是完备的，会有一些本来可以分配在栈上的对象被 Go 的编译器分配在了堆上。
如这篇文章《&lt;a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">Golang escape analysis&lt;/a>》所描述的一些例子一样，有些对象本来可以避免逃逸（Escape，指的是对象被分配在堆上）。&lt;/p>
&lt;p>对于某些场景，我们确定一个对象肯定可以（也应当）被分配在栈上，但是它却逃逸了。
这样在某些关键路径上的逃逸的对象会造成大量的分配和垃圾回收。&lt;/p>
&lt;h2 id="2-go-版本">2. Go 版本&lt;/h2>
&lt;p>使用的 Go 版本为今晚刚从 master 分支上 pull 下的源码直接构建。&lt;/p>
&lt;pre tabindex="0">&lt;code>ThinkPad-X1-Carbon:bin bef0rewind$ ./go version
go version devel +42e8b9c3a4 Fri Nov 30 15:17:34 2018 +0000 darwin/amd64
&lt;/code>&lt;/pre>&lt;h2 id="3-示例">3. 示例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// file: escape.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">field1&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>.(&lt;span style="color:#66d9ef">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">addrObj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">addrObj&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>go run -gcflags=&amp;quot;-m -m&amp;quot; escape.go&lt;/code> 可以在运行时输出逃逸分析的结果。&lt;/p>
&lt;pre tabindex="0">&lt;code>./escape.go:10: cannot inline causeEscape: unhandled op TYPESW
./escape.go:19: cannot inline main: non-leaf function
./escape.go:10: leaking param: i
./escape.go:10: from ... argument (arg to ...) at ./escape.go:15
./escape.go:10: from *(... argument) (indirection) at ./escape.go:15
./escape.go:10: from ... argument (passed to call[argument content escapes]) at ./escape.go:15
./escape.go:15: causeEscape ... argument does not escape
./escape.go:23: addrObj escapes to heap
./escape.go:23: from addrObj (passed to call[argument escapes]) at ./escape.go:23
./escape.go:21: &amp;amp;obj escapes to heap
./escape.go:21: from addrObj (assigned) at ./escape.go:21
./escape.go:21: from addrObj (interface-converted) at ./escape.go:23
./escape.go:21: from addrObj (passed to call[argument escapes]) at ./escape.go:23
./escape.go:20: moved to heap: obj
(0x10904e0,0xc420080050)
&lt;/code>&lt;/pre>&lt;p>&lt;code>obj&lt;/code> 可以分配在栈上，因为在 &lt;code>main&lt;/code> 函数返回时（栈退出），这个变量占用的空间就可以安全被用在其他地方了。
但是 “./escape.go:20: moved to heap: obj” 说明 &lt;code>obj&lt;/code> 被分配在了堆上。&lt;/p>
&lt;h2 id="4-小技巧">4. 小技巧&lt;/h2>
&lt;p>如何改变这个分析结果，需要一点小技巧。&lt;/p>
&lt;p>关键词是 &lt;code>uintptr&lt;/code> 类型。
Go 语言中对 &lt;code>uintptr&lt;/code> 是这样描述的：&lt;/p>
&lt;blockquote>
&lt;p>uintptr is an integer type that is large enough to hold the bit pattern of any pointer.&lt;/p>
&lt;/blockquote>
&lt;p>比如在 64-bit Linux 系统上 &lt;code>uintptr&lt;/code> 被定义成为了 &lt;code>uint64&lt;/code>。
Go 中合法的类型转换为：&lt;code>normal pointer&lt;/code> ⟷ &lt;code>unsafe.Pointer&lt;/code> ⟷ &lt;code>uintptr&lt;/code> 。
因此我们可以把上面的程序中的 &lt;code>addrObj&lt;/code> 转换为 &lt;code>uintptr&lt;/code>。
这样 Go 编译器不再认为 &lt;code>addrObj&lt;/code> 同后面函数 &lt;code>causeEscape&lt;/code> 使用的参数 &lt;code>i&lt;/code> 存在引用关系，从而绕过 Escape Analysis Algorithm 。
为了防止垃圾回收过程中 &lt;code>obj&lt;/code> 被回收，可以使用 &lt;code>obj.field1 = 0&lt;/code> 来保持 &lt;code>obj&lt;/code> 活跃。&lt;/p>
&lt;p>修改后的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">field1&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>.(&lt;span style="color:#66d9ef">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">BigTempObject&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">addrObj&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">intAddr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> uintptr(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">addrObj&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">causeEscape&lt;/span>((&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">BigTempObject&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">intAddr&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">obj&lt;/span>.&lt;span style="color:#a6e22e">field1&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>go run -gcflags=&amp;quot;-m -m&amp;quot; escape.go&lt;/code> 运行结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>./escape.go:13: cannot inline causeEscape: unhandled op TYPESW
./escape.go:22: cannot inline main: non-leaf function
./escape.go:13: leaking param: i
./escape.go:13: from ... argument (arg to ...) at ./escape.go:18
./escape.go:13: from *(... argument) (indirection) at ./escape.go:18
./escape.go:13: from ... argument (passed to call[argument content escapes]) at ./escape.go:18
./escape.go:18: causeEscape ... argument does not escape
./escape.go:26: (*BigTempObject)(unsafe.Pointer(intAddr)) escapes to heap
./escape.go:26: from (*BigTempObject)(unsafe.Pointer(intAddr)) (passed to call[argument escapes]) at ./escape.go:26
./escape.go:24: main &amp;amp;obj does not escape
(0x10904e0,0xc42003bf70)
&lt;/code>&lt;/pre>&lt;p>可以看到 &lt;code>obj&lt;/code> 不再逃逸，主要是 &lt;code>intAddr&lt;/code> 中断了逃逸分析算法构建的指针依赖关系（表示为一个有向图）。&lt;/p>
&lt;h2 id="5-一点感想">5. 一点感想&lt;/h2>
&lt;p>我们可以做到不代表一定去做，有风险也不代表禁区，采取什么样的行动是个人权衡后的选择。&lt;br>
什么原因导致了人们做了不同的选择，而人们不同的选择又导致了什么结果？&lt;br>
多样性是这个世界的现状，黑暗面与光明面同在。
May the force be with you.&lt;/p></content></item><item><title>Golang Receiver Type 探索</title><link>https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/</link><pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/11/21/2018-11-21-golang-receiver-type/</guid><description>1. 参考 在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。
https://golang.google.cn/ref/spec#Method_sets https://golang.google.cn/ref/spec#Types https://golang.google.cn/ref/spec#Struct_types https://golang.google.cn/ref/spec#Composite_literals 核心的概念是 method sets：
A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T).</description><content>&lt;h2 id="1-参考">1. 参考&lt;/h2>
&lt;p>在 Go 的官方 spec 中有以下涉及到类型和方法的章节，如果需要了解具体的细节，可以参考阅读。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Method_sets">https://golang.google.cn/ref/spec#Method_sets&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Types">https://golang.google.cn/ref/spec#Types&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Struct_types">https://golang.google.cn/ref/spec#Struct_types&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.google.cn/ref/spec#Composite_literals">https://golang.google.cn/ref/spec#Composite_literals&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>核心的概念是 method sets：&lt;/p>
&lt;blockquote>
&lt;p>A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). Further rules apply to structs containing embedded fields, as described in the section on struct types. Any other type has an empty method set. In a method set, each method must have a unique non-blank method name.&lt;/p>
&lt;p>The method set of a type determines the interfaces that the type implements and the methods that can be called using a receiver of that type.&lt;/p>
&lt;/blockquote>
&lt;p>下面的一些细节基本上都和这段描述相关。&lt;/p>
&lt;h2 id="2-duck-typing-与方法调用">2. Duck typing 与方法调用&lt;/h2>
&lt;p>在很多面向对象的语言中，一个对象都可以“拥有”一些方法，使用例如 &lt;code>obj.f(a, b, c)&lt;/code> 的形式进行调用。结合语言的类型系统，通过“扩展”、“继承”、“实现”等术语，我们可以将不同的类组织起来。在 Go 语言中采用的是 “duck typing”，没有显式的类型关系定义关键字。当一个类型实现了一个接口的全部方法时，那这个类型就被视为实现了这个接口。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Duck&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Bark&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">A&lt;/span>) &lt;span style="color:#a6e22e">Bark&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">iA&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">A&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#a6e22e">iA&lt;/span>).(&lt;span style="color:#a6e22e">Duck&lt;/span>); &lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;A{} is Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;A{} is not Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">iB&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">B&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#a6e22e">iB&lt;/span>).(&lt;span style="color:#a6e22e">Duck&lt;/span>); &lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;B{} is Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;B{} is not Duck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>&amp;amp;A{} is Duck
&amp;amp;B{} is not Duck
&lt;/code>&lt;/pre>&lt;p>我们可以用原始的类型去调用一个方法，也可以使用一个接口去调用方法。这里就涉及到方法调用者的问题：什么样的对象是一个合法的方法调用者？&lt;/p>
&lt;p>至少 &lt;code>A{}&lt;/code> 不是，因为我们实现 &lt;code>Duck&lt;/code> 接口的时候，使用的是 &lt;code>func (*A) Bark()&lt;/code> 进行的定义，而非 &lt;code>func (A) Bark()&lt;/code>。这样就导致了只有 &lt;code>A&lt;/code> 类型对象的指针类型才能作为方法调用者去调用 &lt;code>Bark&lt;/code> 方法。&lt;/p>
&lt;h2 id="3-成员函数的参数">3. 成员函数的参数&lt;/h2>
&lt;p>在实现中，调用某个类型的成员方法，第一个参数其实是这个方法的实现对象自身，即如果是一个指针的方法，就是这个指针的值，如果是一个对象，就是这个对象的值。&lt;/p>
&lt;p>下面使用 Go 1.8.3 展示，因为当前最新的 Go 编译器在打印 stack trace 的时候不再打印函数的参数（这个例子中）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">r&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>0xc420039f70
received 1
panic: just a panic
goroutine 1 [running]:
main.(*R1).f(0xc420039f70, 0x1)
/Users/bef0rewind/Projects/net example/src/main/receiver_type.go:9 +0xa3
main.main()
/Users/bef0rewind/Projects/net example/src/main/receiver_type.go:16 +0x5a
&lt;/code>&lt;/pre>&lt;p>Stack trace 中函数 &lt;code>f&lt;/code> 第一个值是指针 &lt;code>r&lt;/code> 的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span>) &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;received&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#e6db74">&amp;#34;just a panic&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">R1&lt;/span>{&lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">r&lt;/span>).&lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>7
received 1
panic: just a panic
goroutine 1 [running]:
main.R1.g(0x7, 0x9, 0x1)
/Users/bef0rewind/Projects/net example/src/receiver_type/main/args.go:15 +0xa3
main.main()
/Users/bef0rewind/Projects/net example/src/receiver_type/main/args.go:22 +0x58
&lt;/code>&lt;/pre>&lt;p>Stack trace 中函数 &lt;code>g&lt;/code> 第一个值是 &lt;code>r&lt;/code> 的值 &lt;code>7&lt;/code> 和 &lt;code>9&lt;/code>。&lt;/p>
&lt;p>从这个实现方式中我们可以推断以下几点：&lt;/p>
&lt;ul>
&lt;li>Go 语言采用参数传值的方式进行函数调用，因此如果对象很大，使用的对象本身调用函数会带来大量的复制&lt;/li>
&lt;li>不可能在函数调用中改变函数外的调用者，因为传到函数内部的只是调用者的副本&lt;/li>
&lt;/ul>
&lt;h2 id="4-使用接口调用函数">4. 使用接口调用函数&lt;/h2>
&lt;p>基于这样的成员函数实现方式，我们可以尝试另外一种调用方式：使用接口类型调用一个函数。
这里不是将一个对象转换成特定的接口然后去调用函数，而是使用接口类型本身去进行函数调用。
这种方式在 Go 1.9 中开始支持，在 Go 1.10 开始写入 Go 的 specs。这个例子使用的是 Go master 分支的版本，可能是 Go 1.11。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">M&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;I;m M, with&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">IM&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">IM&lt;/span>.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>I;m M, with 7
&lt;/code>&lt;/pre>&lt;p>此外还能使用匿名接口类型去调用函数，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">M&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>) &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;I;m M, with&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">M&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">interface&lt;/span>{&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)}.&lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果与上面的一段采用 &lt;code>IM&lt;/code> 接口定义的例子是一样的。&lt;/p>
&lt;h2 id="5-注入依赖">5. 注入依赖&lt;/h2>
&lt;p>有时候一个对象在实例化的时候，它的一些成员方法的行为可能还没有确定，需要依赖外界注入。此时我们可以在对象类型定义中内嵌一个接口，然后在后期传入一个接口的实例来确定其行为。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">BinaryOp&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ComputeNode&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">BinaryOp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>) &lt;span style="color:#a6e22e">Result&lt;/span>() &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span>.&lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">y&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Add&lt;/span>) &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Multi&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Multi&lt;/span>) &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>{&lt;span style="color:#a6e22e">x&lt;/span>:&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Add&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">BinaryOp&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Multi&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>5
6
&lt;/code>&lt;/pre>&lt;p>注意一定要记得传入接口的实例，在这个例子中如果不给 &lt;code>node&lt;/code> 传入一个 &lt;code>BinaryOp&lt;/code> 接口实例，那 &lt;code>node.BinaryOp&lt;/code> 是 &lt;code>nil&lt;/code>，在调用 &lt;code>Compute&lt;/code> 方法的时候就会发生异常。例如将上面的 &lt;code>main&lt;/code> 函数稍作修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">ComputeNode&lt;/span>{&lt;span style="color:#a6e22e">x&lt;/span>:&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//node.BinaryOp = &amp;amp;Add{}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x104d8d7]
goroutine 1 [running]:
main.(*ComputeNode).Result(...)
/Users/bef0rewind/Projects/net example/src/receiver_type/main/injection.go:13
main.main()
/Users/bef0rewind/Projects/net example/src/receiver_type/main/injection.go:32 +0x47
&lt;/code>&lt;/pre>&lt;h2 id="6-内部机制">6. 内部机制&lt;/h2>
&lt;p>内部机制有一些细节。大体就是一个接口 &lt;code>i&lt;/code> 包含两部分内容（指针），一个是接口代表的方法的集合，一个实现这个接口的具体对象；而一个对象 &lt;code>obj&lt;/code>，它包含了自己的内存中的值，也能通过其类型获取到 &lt;code>obj&lt;/code> 实现的方法集合。&lt;/p>
&lt;p>将这两个概念记住，在实现一些模式的时候就会少很多心智负担。&lt;/p>
&lt;h2 id="7-总结">7. 总结&lt;/h2>
&lt;p>Go 语言的这套基于 “duck typing” 的机制好不好，争论有很多。不过我一向对这些争论没有特别的倾向，至少理解其机制之后按照其设计思路来用还可以正常使用，而且里面没有复杂的概念和例外情形。&lt;/p>
&lt;p>也许我的理解有偏差，但现在还没有发现什么矛盾的地方。&lt;/p></content></item><item><title>defer, panic and recover in Golang</title><link>https://blog.formalscience.com/2018/08/21/2018-08-21_golang_exception_handling/</link><pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/08/21/2018-08-21_golang_exception_handling/</guid><description>1. 什么是异常处理 程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。 一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 try/catch/finally 机制（https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、 Python 的 try/raise/except/finally 机制（https://docs.python.org/3/tutorial/errors.html）等。
2. Go 语言中的异常处理机制 Go 语言中使用的是 defer/panic/recover 机制来处理异常。Go 语言官方博客的《Defer, Panic, and Recover》讲述了这个机制的具体应用方式。
还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：
The Right Places To Call The recover Function：https://go101.org/article/panic-and-recover-more.html ，几种使用 recover 恢复 Go 语言中 panic 的适用场景 7.异常处理：https://www.kancloud.cn/liupengjie/go/578555 ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节 如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 defer + recover 处理一个 panic，defer 结构要在 panic 触发之前被定义而且 recover 要直接在在 defer 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。
3. defer 语法糖的部分原理 在讲述 defer 机制的文章中，都会提到一个函数中多个 defer 结构执行的顺序和定义顺序是相反的，即后定义的 defer 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：
func g(n int) { println(n) } func h(str string) { println(str) } func f() { defer g(0) defer h(&amp;#34;h&amp;#34;) } 调用 f 输出为：</description><content>&lt;h2 id="1-什么是异常处理">1. 什么是异常处理&lt;/h2>
&lt;p>程序在执行过程中有可能出现异常状态，比如获取一个不再有效指针指向的内容、除零等。
一般语言都提供了异常处理机制来应对这些情形，例如 Java 的 &lt;code>try&lt;/code>/&lt;code>catch&lt;/code>/&lt;code>finally&lt;/code> 机制（https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html）、
Python 的 &lt;code>try&lt;/code>/&lt;code>raise&lt;/code>/&lt;code>except&lt;/code>/&lt;code>finally&lt;/code> 机制（https://docs.python.org/3/tutorial/errors.html）等。&lt;/p>
&lt;h2 id="2-go-语言中的异常处理机制">2. Go 语言中的异常处理机制&lt;/h2>
&lt;p>Go 语言中使用的是 &lt;code>defer&lt;/code>/&lt;code>panic&lt;/code>/&lt;code>recover&lt;/code> 机制来处理异常。Go 语言官方博客的《&lt;a href="https://blog.golang.org/defer-panic-and-recover">Defer, Panic, and Recover&lt;/a>》讲述了这个机制的具体应用方式。&lt;/p>
&lt;p>还有一些其他教程对这个机制的使用方法、适用场景进行了进一步阐述：&lt;/p>
&lt;ul>
&lt;li>The Right Places To Call The recover Function：https://go101.org/article/panic-and-recover-more.html ，几种使用 &lt;code>recover&lt;/code> 恢复 Go 语言中 &lt;code>panic&lt;/code> 的适用场景&lt;/li>
&lt;li>7.异常处理：https://www.kancloud.cn/liupengjie/go/578555 ，看云发布的 Go 语言教程中涉及到异常处理的章节，里面涉及到很多使用示例细节&lt;/li>
&lt;/ul>
&lt;p>如果搜索 “golang 异常处理”，类似的教程有很多。里面的核心思想大体就是：用 &lt;code>defer&lt;/code> + &lt;code>recover&lt;/code> 处理一个 &lt;code>panic&lt;/code>，&lt;code>defer&lt;/code> 结构要在 &lt;code>panic&lt;/code> 触发之前被定义而且 &lt;code>recover&lt;/code> 要直接在在 &lt;code>defer&lt;/code> 结构定义的函数中被调用（而不是被直接调用或者在函数内部的其他函数中被调用）。&lt;/p>
&lt;h2 id="3-defer-语法糖的部分原理">3. &lt;code>defer&lt;/code> 语法糖的部分原理&lt;/h2>
&lt;p>在讲述 &lt;code>defer&lt;/code> 机制的文章中，都会提到一个函数中多个 &lt;code>defer&lt;/code> 结构执行的顺序和定义顺序是相反的，即后定义的 &lt;code>defer&lt;/code> 结构总是先被执行。为什么会出现这样的情况？例如下面的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(&lt;span style="color:#a6e22e">str&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#a6e22e">str&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;h&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用 &lt;code>f&lt;/code> 输出为：&lt;/p>
&lt;pre tabindex="0">&lt;code>h
0
&lt;/code>&lt;/pre>&lt;p>常见的函数调用流程为：&lt;/p>
&lt;ul>
&lt;li>将函数使用的参数压入栈&lt;/li>
&lt;li>执行函数指令&lt;/li>
&lt;li>函数执行结束返回到调用点&lt;/li>
&lt;/ul>
&lt;p>如果 &lt;code>defer&lt;/code> 相关的代码也是这么执行的话，那么为什么不是： &lt;code>0&lt;/code> 入栈 - 执行 &lt;code>g&lt;/code> - &lt;code>g&lt;/code> 返回 - &lt;code>&amp;quot;h&amp;quot;&lt;/code> 入栈 - 执行 &lt;code>h&lt;/code> - &lt;code>h&lt;/code> 返回 这个顺序呢？
按照这个顺序执行，调用 &lt;code>f&lt;/code> 输出应该是 &lt;code>0&lt;/code> 在 &lt;code>h&lt;/code> 前面符合预期。是不是 Go 语言中执行 &lt;code>defer&lt;/code> 时采用了特殊的处理流程？&lt;/p>
&lt;p>是，也不是。&lt;/p>
&lt;p>太阳底下无新鲜事，&lt;code>defer&lt;/code> 不过是一个语法糖，用来对一个函数 &lt;code>deferproc&lt;/code> 进行包装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Create a new deferred function fn with siz bytes of arguments.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// The compiler turns a defer statement into a call to this.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:nosplit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">deferproc&lt;/span>(&lt;span style="color:#a6e22e">siz&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>, &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">funcval&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>deferproc&lt;/code> 创建一个延迟调用的函数，其参数为 &lt;code>siz&lt;/code> （延迟调用的函数的参数占用的字节数量）和 &lt;code>fn&lt;/code>（被延迟调用的函数本身）。
当 Go 程序的编译器遇到 &lt;code>defer f()&lt;/code>，会将这条语句翻译为一条 &lt;code>deferproc&lt;/code> 和一条 &lt;code>deferreturn&lt;/code> 。
其中 &lt;code>deferproc&lt;/code> 把被调用的函数及其参数挂载在 goroutine （Go 中的并发单元，协程）结构的一个链表上；
&lt;code>deferreturn&lt;/code> 从链表上取下一个挂载的被延迟执行的函数，执行它。&lt;/p>
&lt;p>如何使用技巧绕过 &lt;code>defer&lt;/code> 关键字，模拟类似效果？
可以使用 &lt;code>linkname&lt;/code> 方法来把 Go 语言运行时的一些关键函数导出，从而进行某些不常见的操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#e6db74">&amp;#34;runtime&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Eface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_type&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">EfaceOf&lt;/span>(&lt;span style="color:#a6e22e">ep&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Eface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Eface&lt;/span>)(&lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>(&lt;span style="color:#a6e22e">ep&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Funcval&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// variable-size, fn-specific data here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:linkname Deferproc runtime.deferproc
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Deferproc&lt;/span>(&lt;span style="color:#a6e22e">siz&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>, &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Funcval&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//go:linkname Deferreturn runtime.deferreturn
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Deferreturn&lt;/span>(&lt;span style="color:#a6e22e">arg0&lt;/span> &lt;span style="color:#66d9ef">uintptr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;hacked defer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fI&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} = &lt;span style="color:#a6e22e">f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Attach a defer struct to the current goroutine struct
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Deferproc&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Funcval&lt;/span>)(&lt;span style="color:#a6e22e">EfaceOf&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">fI&lt;/span>).&lt;span style="color:#a6e22e">Data&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;original defer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Run a deferred function if there is one
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Deferreturn&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码会输出：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-output" data-lang="output">original defer
hacked defer
&lt;/code>&lt;/pre>&lt;p>当然，如果是使用 &lt;code>defer&lt;/code> 关键字，Go 语言的编译器会选择合适的位置插入 &lt;code>deferreturn&lt;/code> 语句，而不是像上述代码中一样手动放在结束位置处。&lt;/p>
&lt;h2 id="4-recover-生效位置的设计原因推测">4. &lt;code>recover&lt;/code> 生效位置的设计原因推测&lt;/h2>
&lt;p>言归正传，&lt;code>panic&lt;/code> 发生后，会根据函数调用顺序逐层上报，直到最后一层被抛出到系统导致崩溃或者被 &lt;code>recover&lt;/code> 机制处理。
那么如果被 &lt;code>recover&lt;/code> 处理，这个过程是怎么生效的？&lt;/p>
&lt;p>很多教程中都提到 &lt;code>recover&lt;/code> 一定要在 &lt;code>defer&lt;/code> 声明的函数里面（既不是这个函数本身也不能是函数里面的其他函数里面）才能正确处理当前的 &lt;code>panic&lt;/code> 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 1, not work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 2, not work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// case 3, work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> recover()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么呢？&lt;/p>
&lt;p>先不考虑实现，先从理念上分析一下。&lt;/p>
&lt;ol>
&lt;li>&lt;code>defer&lt;/code> 直接作用于 &lt;code>recover()&lt;/code>：无法根据 &lt;code>recover()&lt;/code> 的返回值来进行不同类型的 &lt;code>panic&lt;/code> 处理&lt;/li>
&lt;li>在被 &lt;code>defer&lt;/code> 作用的函数内部的函数 &lt;code>g&lt;/code> 中使用 &lt;code>recover()&lt;/code>：如果 &lt;code>g&lt;/code> 是一个第三方库的函数，无法保证其中没有未知的 &lt;code>recover&lt;/code> 意外处理了系统中的 &lt;code>panic&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>因此事实上也只能通过这样的约束来使这个异常处理机制看上去直观易处理一些。当然通过对 Go 编译器进行修改，还是有办法使得上面三种情况下 &lt;code>recover&lt;/code> 都可以中断 &lt;code>panic&lt;/code> 向上层传递过程的。&lt;/p>
&lt;p>此外，由于被 &lt;code>defer&lt;/code> 处理的函数被挂载在 goroutine 结构的一个链表上，因此当 &lt;code>panic&lt;/code> 发生时，可以直接从这个链表上取下被延迟执行的函数一个个执行。
这也是 &lt;code>recover&lt;/code> 要放在 &lt;code>deferred function&lt;/code> 中的原因，因为这些函数是肯定可以执行到的。&lt;/p>
&lt;h2 id="5-总结">5. 总结&lt;/h2>
&lt;p>不能说 Go 中这个异常处理机制有多高明，基本上属于现代语言标配。了解更多背后的原理，在使用时可以更坚定一些。&lt;/p>
&lt;p>此外，最近看到一本书《最好的告别》（https://book.douban.com/subject/26576861/）。&lt;/p>
&lt;p>&lt;img src="https://images-na.ssl-images-amazon.com/images/I/41rwxKTGwXL._SX308_BO1,204,203,200_.jpg" alt="Being Mortal">&lt;/p>
&lt;p>豆瓣上的介绍：&lt;/p>
&lt;blockquote>
&lt;p>当独立、自助的生活不能再维持时，我们该怎么办？在生命临近终点的时刻，我们该和医生谈些什么？应该如何优雅地跨越生命的终点？对于这些问题，大多数人缺少清晰的观念，而只是把命运交由医学、技术和陌生人来掌控。影响世界的医生阿图•葛文德结合其多年的外科医生经验与流畅的文笔，讲述了一个个伤感而发人深省的故事，对在21世纪变老意味着什么进行了清醒、深入的探索。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>defer&lt;/code> / &lt;code>finally&lt;/code> 这些关键字让我们可以控制函数退出时的行为，但是我们自身呢？也许考虑这些问题可以让我们自身活得有意义一些。&lt;/p>
&lt;p>推荐大家看一下。&lt;/p></content></item><item><title>Useful Commands</title><link>https://blog.formalscience.com/2018/07/22/2018-07-22_commands/</link><pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/07/22/2018-07-22_commands/</guid><description>Convert images to a video ffmpeg -r 30 -start_number 3455 -i _IMG%d.jpg -s 960X600 -pix_fmt yuv420p 30fps-960.mov -r 30: 30 frames per second -s 960X600: resolution -pix_fmt yuv420p: for OsX youtube-dl video and extract audio file youtube-dl --proxy socks5://127.0.0.1:1080 -x --audio-format mp3 youtube-url
virtualenvwrapper WORKON_HOME: which directory your environments are created in /usr/local/bin/virtualenvwrapper.sh: default location for its configuration file mkvirtualenv test --python=python3: make a virtual environment &amp;rsquo;test&amp;rsquo; with python3 rmvirtualenv test: remove a virtual environment &amp;rsquo;test' workon test3 or lsvirtualenv -b test3: activate a virtual environment &amp;rsquo;test' deactivate: exit current environment more details: search engine how to avoid globa packages how to copy an environment node &amp;amp;&amp;amp; npm npm complains: Error: Cannot find module 'process-nextick-args'</description><content>&lt;h2 id="convert-images-to-a-video">Convert images to a video&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ffmpeg -r &lt;span style="color:#ae81ff">30&lt;/span> -start_number &lt;span style="color:#ae81ff">3455&lt;/span> -i _IMG%d.jpg -s 960X600 -pix_fmt yuv420p 30fps-960.mov
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>-r 30&lt;/code>: 30 frames per second&lt;/li>
&lt;li>&lt;code>-s 960X600&lt;/code>: resolution&lt;/li>
&lt;li>&lt;code>-pix_fmt yuv420p&lt;/code>: for OsX&lt;/li>
&lt;/ul>
&lt;h2 id="youtube-dl-video-and-extract-audio-file">youtube-dl video and extract audio file&lt;/h2>
&lt;p>&lt;code>youtube-dl --proxy socks5://127.0.0.1:1080 -x --audio-format mp3 youtube-url&lt;/code>&lt;/p>
&lt;h2 id="virtualenvwrapper">virtualenvwrapper&lt;/h2>
&lt;ul>
&lt;li>&lt;code>WORKON_HOME&lt;/code>: which directory your environments are created in&lt;/li>
&lt;li>&lt;code>/usr/local/bin/virtualenvwrapper.sh&lt;/code>: default location for its configuration file&lt;/li>
&lt;li>&lt;code>mkvirtualenv test --python=python3&lt;/code>: make a virtual environment &amp;rsquo;test&amp;rsquo; with python3&lt;/li>
&lt;li>&lt;code>rmvirtualenv test&lt;/code>: remove a virtual environment &amp;rsquo;test'&lt;/li>
&lt;li>&lt;code>workon test3&lt;/code> or &lt;code>lsvirtualenv -b test3&lt;/code>: activate a virtual environment &amp;rsquo;test'&lt;/li>
&lt;li>&lt;code>deactivate&lt;/code>: exit current environment&lt;/li>
&lt;li>more details: search engine
&lt;ul>
&lt;li>how to avoid globa packages&lt;/li>
&lt;li>how to copy an environment&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="node--npm">node &amp;amp;&amp;amp; npm&lt;/h2>
&lt;p>npm complains: &lt;code>Error: Cannot find module 'process-nextick-args'&lt;/code>&lt;/p>
&lt;p>Uninstall node, &lt;code>brew uninstall node&lt;/code>, then by &lt;a href="https://stackoverflow.com/questions/11177954/how-do-i-completely-uninstall-node-js-and-reinstall-from-beginning-mac-os-x">this stackoverflow post&lt;/a>:&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp
sudo rm -rf /opt/local/bin/node /opt/local/include/node /opt/local/lib/node_modules
sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node.1 /usr/local/lib/dtrace/node.d
&lt;/code>&lt;/pre>&lt;p>Just delete something, then &lt;code>brew install npm&lt;/code>.&lt;/p>
&lt;h2 id="delve-dlv-tips">delve (dlv) tips&lt;/h2>
&lt;ul>
&lt;li>funcs [regexp] : get function list&lt;/li>
&lt;li>call : call a function (in a newer a go version, dlv should be installed in the newer go version too)&lt;/li>
&lt;/ul>
&lt;h2 id="shadowsocks">shadowsocks&lt;/h2>
&lt;p>&lt;code>ssserver -c /etc/shadowsocks/config.json&lt;/code>&lt;/p>
&lt;p>&lt;code>sslocal&lt;/code> and &lt;code>ssserver&lt;/code> are all from &lt;code>apt-get install shadowsocks&lt;/code>.&lt;/p>
&lt;h2 id="wsl-2--vmware-switch">WSL 2 &amp;amp;&amp;amp; VMware switch&lt;/h2>
&lt;p>After enabling WSL 2 on Windows 10 insider preview, VMware virtual machine is disabled.
This is because collision between Hyper-V and VMware.&lt;/p>
&lt;p>Turn on VMware&lt;/p>
&lt;pre tabindex="0">&lt;code> bcdedit /set hypervisorlaunchtype off
&lt;/code>&lt;/pre>&lt;p>Turn on Hyper-V &amp;amp;&amp;amp; WSL 2&lt;/p>
&lt;pre tabindex="0">&lt;code> bcdedit /set hypervisorlaunchtype auto
&lt;/code>&lt;/pre>&lt;p>reference: &lt;a href="https://blog.minirplus.com/10268/">https://blog.minirplus.com/10268/&lt;/a>&lt;/p></content></item><item><title>Upgrade DigitalOcean's Ubuntu 17.04 to LTS version in 2018-06</title><link>https://blog.formalscience.com/2018/06/23/2018-06-23_update_vps_ubuntu_version/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://blog.formalscience.com/2018/06/23/2018-06-23_update_vps_ubuntu_version/</guid><description>What happened? I found my proxy for accessing some websites stopped working today, so I had to change my VPS&amp;rsquo;s IP address. After some trials, everything seemed OK and I started watching a skiing video made by NorthFace on Youtube.
Emmmm, I noticed 12 packages needed to be updated. Well, I typed sudo apt-get update and got messages like this (I didn&amp;rsquo;t save the error messages then):
404 Not Found [IP: 91.</description><content>&lt;h2 id="what-happened">What happened?&lt;/h2>
&lt;p>I found my proxy for accessing some websites stopped working today, so I had to change my VPS&amp;rsquo;s IP address.
After some trials, everything seemed OK and I started watching a skiing video made by NorthFace on Youtube.&lt;/p>
&lt;p>Emmmm, I noticed 12 packages needed to be updated.
Well, I typed &lt;code>sudo apt-get update&lt;/code> and got messages like this (I didn&amp;rsquo;t save the error messages then):&lt;/p>
&lt;pre tabindex="0">&lt;code> 404 Not Found [IP: 91.189.91.23 80]
Ign:10 http://us.archive.ubuntu.com/ubuntu zesty-backports InRelease
Err:11 http://us.archive.ubuntu.com/ubuntu zesty Release
404 Not Found [IP: 91.189.91.26 80]
Err:12 http://us.archive.ubuntu.com/ubuntu zesty-updates Release
404 Not Found [IP: 91.189.91.26 80]
Err:13 http://us.archive.ubuntu.com/ubuntu zesty-backports Release
404 Not Found [IP: 91.189.91.26 80]
Reading package lists... Done
E: The repository &amp;#39;http://security.ubuntu.com/ubuntu zesty-security Release&amp;#39; does no longer have a Release file.
N: Updating from such a repository can&amp;#39;t be done securely, and is therefore disabled by default.
N: See apt-secure(8) manpage for repository creation and user configuration details.
E: The repository &amp;#39;http://us.archive.ubuntu.com/ubuntu zesty Release&amp;#39; does no longer have a Release file.
N: Updating from such a repository can&amp;#39;t be done securely, and is therefore disabled by default.
N: See apt-secure(8) manpage for repository creation and user configuration details.
E: The repository &amp;#39;http://us.archive.ubuntu.com/ubuntu zesty-updates Release&amp;#39; does no longer have a Release file.
N: Updating from such a repository can&amp;#39;t be done securely, and is therefore disabled by default.
N: See apt-secure(8) manpage for repository creation and user configuration details.
E: The repository &amp;#39;http://us.archive.ubuntu.com/ubuntu zesty-backports Release&amp;#39; does no longer have a Release file.
N: Updating from such a repository can&amp;#39;t be done securely, and is therefore disabled by default.
N: See apt-secure(8) manpage for repository creation and user configuration details.
&lt;/code>&lt;/pre>&lt;p>Wow, It was the first time I encountered such things.
After some digging, I realized it was because Ubuntu 17.04 (zesty) was not supported any longer.&lt;/p>
&lt;p>According to &lt;a href="https://wiki.ubuntu.com/ZestyZapus/ReleaseNotes">https://wiki.ubuntu.com/ZestyZapus/ReleaseNotes&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Ubuntu 17.04 will be supported for 9 months until January 2018. If you need Long Term Support, it is recommended you use Ubuntu 16.04 LTS instead.&lt;/p>
&lt;/blockquote>
&lt;p>It means my current release version (Ubuntu 17.04) won&amp;rsquo;t receive any updates in the future.&lt;/p>
&lt;p>&lt;img src="https://assets.ubuntu.com/v1/f02f0a4b-r-eol-ubuntu-full-2018-02-28.png" alt="release-end-of-life-date">&lt;/p>
&lt;h2 id="how-to-upgrade">How to upgrade&lt;/h2>
&lt;p>I was struggled to reveal some steps to upgrade my Ubuntu 17.04 (End-of-Life) to 18.04 (LTS version).&lt;/p>
&lt;p>The official guide to upgrade from an Ubuntu release which reaches its “end of life” is: &lt;a href="https://help.ubuntu.com/community/EOLUpgrades">https://help.ubuntu.com/community/EOLUpgrades&lt;/a>&lt;/p>
&lt;h3 id="1-update-sourceslist">1. Update sources.list&lt;/h3>
&lt;p>The path of &lt;em>sources.list&lt;/em> is &lt;em>/etc/apt/sources.list&lt;/em>.&lt;/p>
&lt;pre tabindex="0">&lt;code>## EOL upgrade sources.list
# Required
deb http://old-releases.ubuntu.com/ubuntu/ CODENAME main restricted universe multiverse
deb http://old-releases.ubuntu.com/ubuntu/ CODENAME-updates main restricted universe multiverse
deb http://old-releases.ubuntu.com/ubuntu/ CODENAME-security main restricted universe multiverse
# Optional
#deb http://old-releases.ubuntu.com/ubuntu/ CODENAME-backports main restricted universe multiverse
&lt;/code>&lt;/pre>&lt;p>In my case, &lt;code>CODENAME&lt;/code> should be replaced by &lt;code>zesty&lt;/code>.&lt;/p>
&lt;h3 id="2-upgrade">2. Upgrade&lt;/h3>
&lt;p>Try &lt;code>apt-get upgrade&lt;/code>, and I got:&lt;/p>
&lt;pre tabindex="0">&lt;code>dpkg: dependency problems prevent configuration of ubuntu-standard:
ubuntu-standard depends on libpam-systemd; however:
Package libpam-systemd:amd64 is not configured yet.
&lt;/code>&lt;/pre>&lt;p>By some method suggested by stackoverflowers, I finally got over it by these commands:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo dpkg --force-all -P libpam-systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get -f install libpam-systemd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-dist-upgrade">3. Dist Upgrade&lt;/h3>
&lt;p>These are some normal steps for an upgrade.&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo apt-get dist-upgrade
sudo do-release-upgrade
&lt;/code>&lt;/pre>&lt;p>If you&amp;rsquo;re unlucky like me, you will not upgrade to a newer release completely.
You may see:&lt;/p>
&lt;pre tabindex="0">&lt;code>Package grub-efi-amd64 is not configured yet.
&lt;/code>&lt;/pre>&lt;p>According to &lt;a href="https://askubuntu.com/questions/330531/unable-to-fix-broken-package-system">a question&lt;/a> asked by someone, you can try this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo dpkg --force-all -P grub-efi-amd64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo dpkg --force-all -P grub-efi-amd64-signed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Execute &lt;code>sudo apt-get update&lt;/code> and &lt;code>sudo apt-get upgrade&lt;/code>.&lt;/p>
&lt;h3 id="4-thoughts">4. Thoughts&lt;/h3>
&lt;p>I first upgraded to Ubuntu 17.10 then Ubuntu 18.04.&lt;/p>
&lt;p>To see if I have done the right things, I check the release version by &lt;code>sudo lsb_release -a&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>Distributor ID: Ubuntu
Description: Ubuntu 18.04 LTS
Release: 18.04
Codename: bionic
&lt;/code>&lt;/pre>&lt;p>Is it the DigitalOcean&amp;rsquo;s customized release makes the upgrade so complex for a non-expert programmer or the Ubuntu release itself?&lt;/p>
&lt;p>But apparently, I&amp;rsquo;m not the only one who is confused by the error messages and asks questions on the web. Luckily I&amp;rsquo;ve found helping answers I need.&lt;/p>
&lt;p>The commands with words like &lt;code>force&lt;/code> or &lt;code>-f&lt;/code> make me feel anxious.&lt;/p>
&lt;blockquote>
&lt;p>These violent delights have violent ends.
&amp;mdash; by Shakespeare&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://cdn.vox-cdn.com/thumbor/NxFcQHzIb1eqgk5EXafSzFwy2UU=/0x0:5100x3400/920x613/filters:focal(1816x555:2632x1371):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/52220535/westworld_dolores.0.jpeg" alt="Dolores">&lt;/p>
&lt;p>Anyway, it works.&lt;/p></content></item></channel></rss>